Index: fuse-2.8.5/example/hello.c
===================================================================
--- fuse-2.8.5.orig/example/hello.c
+++ fuse-2.8.5/example/hello.c
@@ -1,91 +1,114 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU GPL.
   See the file COPYING.
 
   gcc -Wall `pkg-config fuse --cflags --libs` hello.c -o hello
 */
 
 #define FUSE_USE_VERSION 26
 
 #include <fuse.h>
 #include <stdio.h>
 #include <string.h>
 #include <errno.h>
 #include <fcntl.h>
 
-static const char *hello_str = "Hello World!\n";
+static const char *hello_str = "Hello World!\n                                                                                          "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                       "
+"                                                                                                                                54321\n";
+
 static const char *hello_path = "/hello";
 
 static int hello_getattr(const char *path, struct stat *stbuf)
 {
 	int res = 0;
+	fprintf(stderr, "hello.c: hello_getattr `%s'\n", path);
 
 	memset(stbuf, 0, sizeof(struct stat));
 	if (strcmp(path, "/") == 0) {
 		stbuf->st_mode = S_IFDIR | 0755;
 		stbuf->st_nlink = 2;
 	} else if (strcmp(path, hello_path) == 0) {
 		stbuf->st_mode = S_IFREG | 0444;
 		stbuf->st_nlink = 1;
 		stbuf->st_size = strlen(hello_str);
 	} else
 		res = -ENOENT;
 
 	return res;
 }
 
 static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
 			 off_t offset, struct fuse_file_info *fi)
 {
 	(void) offset;
 	(void) fi;
+	fprintf(stderr, "hello.c: hello_readdir `%s'\n", path);
 
 	if (strcmp(path, "/") != 0)
 		return -ENOENT;
 
 	filler(buf, ".", NULL, 0);
 	filler(buf, "..", NULL, 0);
 	filler(buf, hello_path + 1, NULL, 0);
 
 	return 0;
 }
 
 static int hello_open(const char *path, struct fuse_file_info *fi)
 {
-	if (strcmp(path, hello_path) != 0)
+	fprintf(stderr, "hello.c: hello_open `%s'\n", path);
+	if (strcmp(path, hello_path) != 0) {
+		fprintf(stderr, "hello.c: hello_open: (%d)`%s' != (%d)`%s'\n", strlen(path), path, strlen(hello_path), hello_path);
 		return -ENOENT;
+	}
 
 	if ((fi->flags & 3) != O_RDONLY)
 		return -EACCES;
 
 	return 0;
 }
 
 static int hello_read(const char *path, char *buf, size_t size, off_t offset,
 		      struct fuse_file_info *fi)
 {
 	size_t len;
 	(void) fi;
+	fprintf(stderr, "hello.c: hello_read `%s' (off: %ld, len: %ld)\n", path, offset, size);
 	if(strcmp(path, hello_path) != 0)
 		return -ENOENT;
 
 	len = strlen(hello_str);
 	if (offset < len) {
 		if (offset + size > len)
 			size = len - offset;
 		memcpy(buf, hello_str + offset, size);
 	} else
 		size = 0;
 
 	return size;
 }
 
 static struct fuse_operations hello_oper = {
 	.getattr	= hello_getattr,
 	.readdir	= hello_readdir,
 	.open		= hello_open,
 	.read		= hello_read,
 };
Index: fuse-2.8.5/fakekern/fuseclient.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/fakekern/fuseclient.c
@@ -0,0 +1,60 @@
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <netinet/in.h>
+#include <wchar.h>
+#include "fuse_kernel.h"
+
+int main(void) {
+    char* path = "/dev/fuse";
+    int fd, res;
+    struct sockaddr_un addr;
+    size_t size;
+    int status = 0;
+
+    FUSE_REQUEST request;
+    wcscpy(request.MountPoint, L"hw");
+    request.MountPointLength = wcslen(request.MountPoint);
+
+    fd = socket(PF_UNIX, SOCK_DGRAM, 0);
+    printf("Response to opening socket is %d\n", fd);
+
+    if(fd < 0) {
+        status = fd;
+        goto SHUTDOWN_CLIENT;
+    }
+    
+    strcpy(addr.sun_path, path);
+    addr.sun_family = AF_UNIX;
+
+    size = offsetof(struct sockaddr_un, sun_path) + strlen(addr.sun_path) + 1;
+    res = connect(fd, (struct sockaddr*)&addr, size);
+    printf("Response to connecting to %s is %d\n", path, res);
+    printf("errno is %d\n", errno);
+
+    if(res != 0) {
+        status = res;
+        goto SHUTDOWN_CLIENT;
+    }
+
+    printf("Sending request\n");
+
+    // send request to "kernel"
+    send(fd, &request, sizeof(FUSE_REQUEST), 0);
+
+    printf("Reading back response\n");
+
+    // read response from "kernel"
+    read(fd, &request, sizeof(FUSE_REQUEST));
+
+SHUTDOWN_CLIENT:
+    shutdown(fd, SHUT_RDWR);
+    close(fd);
+
+    return fd;
+}
+
+
Index: fuse-2.8.5/fakekern/fuseserver.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/fakekern/fuseserver.c
@@ -0,0 +1,78 @@
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <netinet/in.h>
+#include <signal.h>
+#include "fuse_kernel.h"
+
+int socketHandle;
+
+void handleBreak(int sig) {
+    shutdown(socketHandle, SHUT_RDWR);
+    close(socketHandle);
+}
+
+int main(void) {
+    char* path = "/dev/fuse";
+    int res;
+    struct sockaddr_un addr;
+    size_t size;
+    int status = 0;
+
+    FUSE_REQUEST request;
+
+    signal(SIGINT, handleBreak);
+
+    socketHandle = socket(PF_UNIX, SOCK_DGRAM, 0);
+    printf("Response to opening socket is %d\n", socketHandle);
+
+    if(socketHandle < 0) {
+        status = socketHandle;
+        goto SHUTDOWN_SERVER;
+    }
+    
+    strcpy(addr.sun_path, path);
+    addr.sun_family = AF_UNIX;
+
+    size = offsetof(struct sockaddr_un, sun_path) + strlen(addr.sun_path) + 1;
+    res = bind(socketHandle, (struct sockaddr*)&addr, size);
+    printf("Response to binding socket to address is %d\n", res);
+    printf("errno is %d\n", errno);
+
+    if(res != 0) {
+        status = res;
+        goto SHUTDOWN_SERVER;
+    }
+
+    for(;;) {
+        res = read(socketHandle, &request, sizeof(FUSE_REQUEST));
+
+        printf("Response to reading is %d\n", res);
+
+        if(res != sizeof(FUSE_REQUEST)) {
+            printf("Invalid number of bytes read\n");
+            status = res;
+            goto SHUTDOWN_SERVER;
+        }
+
+        printf("Requested mount point is %S\n", request.MountPoint);
+
+        // send same request back at sender
+        res = send(socketHandle, &request, sizeof(FUSE_REQUEST), 0);
+
+        printf("Sent reply with status %d\n", res);
+        printf("errno is %d\n", errno);
+    }
+
+SHUTDOWN_SERVER:
+    shutdown(socketHandle, SHUT_RDWR);
+    close(socketHandle);
+    unlink(path);
+
+    return status;
+}
+
+
Index: fuse-2.8.5/fakekern/Makefile
===================================================================
--- /dev/null
+++ fuse-2.8.5/fakekern/Makefile
@@ -0,0 +1,19 @@
+CC=gcc
+CFLAGS=-c -g -Wall -I ../include
+
+all: fuseserver.exe fuseclient.exe
+
+clean:
+	rm *.exe *.o
+
+fuseserver.exe: fuseserver.o
+	$(CC) fuseserver.o -o fuseserver.exe
+
+fuseserver.o: fuseserver.c
+	$(CC) $(CFLAGS) fuseserver.c
+
+fuseclient.exe: fuseclient.o
+	$(CC) fuseclient.o -o fuseclient.exe
+
+fuseclient.o: fuseclient.c
+	$(CC) $(CFLAGS) fuseclient.c
Index: fuse-2.8.5/include/config.h.in
===================================================================
--- fuse-2.8.5.orig/include/config.h.in
+++ fuse-2.8.5/include/config.h.in
@@ -16,71 +16,74 @@
 #undef HAVE_INTTYPES_H
 
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
 /* Define to 1 if you have the `setxattr' function. */
 #undef HAVE_SETXATTR
 
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
 /* Define to 1 if you have the <strings.h> header file. */
 #undef HAVE_STRINGS_H
 
 /* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
-/* Define to 1 if `st_atim' is member of `struct stat'. */
+/* Define to 1 if `st_atim' is a member of `struct stat'. */
 #undef HAVE_STRUCT_STAT_ST_ATIM
 
-/* Define to 1 if `st_atimespec' is member of `struct stat'. */
+/* Define to 1 if `st_atimespec' is a member of `struct stat'. */
 #undef HAVE_STRUCT_STAT_ST_ATIMESPEC
 
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
 /* Define to 1 if you have the <sys/types.h> header file. */
 #undef HAVE_SYS_TYPES_H
 
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
 /* Define as const if the declaration of iconv() needs const. */
 #undef ICONV_CONST
 
 /* Don't update /etc/mtab */
 #undef IGNORE_MTAB
 
 /* Define to the sub-directory in which libtool stores uninstalled libraries.
    */
 #undef LT_OBJDIR
 
 /* Define to 1 if your C compiler doesn't accept -c and -o together. */
 #undef NO_MINUS_C_MINUS_O
 
 /* Name of package */
 #undef PACKAGE
 
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
 /* Define to the full name of this package. */
 #undef PACKAGE_NAME
 
 /* Define to the full name and version of this package. */
 #undef PACKAGE_STRING
 
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
 /* Version number of package */
 #undef VERSION
Index: fuse-2.8.5/include/fuse_lowlevel_compat.h
===================================================================
--- fuse-2.8.5.orig/include/fuse_lowlevel_compat.h
+++ fuse-2.8.5/include/fuse_lowlevel_compat.h
@@ -1,31 +1,33 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB.
 */
 
 /* these definitions provide source compatibility to prior versions.
    Do not include this file directly! */
 
+#ifndef __CYGWIN__
+
 struct fuse_lowlevel_ops_compat25 {
 	void (*init) (void *userdata);
 	void (*destroy) (void *userdata);
 	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
 	void (*forget) (fuse_req_t req, fuse_ino_t ino, unsigned long nlookup);
 	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
 			 struct fuse_file_info *fi);
 	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
 			 int to_set, struct fuse_file_info *fi);
 	void (*readlink) (fuse_req_t req, fuse_ino_t ino);
 	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
 		       mode_t mode, dev_t rdev);
 	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
 		       mode_t mode);
 	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
 	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
 	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
 			 const char *name);
 	void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
 			fuse_ino_t newparent, const char *newname);
@@ -50,46 +52,48 @@ struct fuse_lowlevel_ops_compat25 {
 	void (*releasedir) (fuse_req_t req, fuse_ino_t ino,
 			    struct fuse_file_info *fi);
 	void (*fsyncdir) (fuse_req_t req, fuse_ino_t ino, int datasync,
 			  struct fuse_file_info *fi);
 	void (*statfs) (fuse_req_t req);
 	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
 			  const char *value, size_t size, int flags);
 	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
 			  size_t size);
 	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);
 	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);
 	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);
 	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
 			mode_t mode, struct fuse_file_info *fi);
 };
 
 struct fuse_session *fuse_lowlevel_new_compat25(struct fuse_args *args,
 				const struct fuse_lowlevel_ops_compat25 *op,
 				size_t op_size, void *userdata);
 
+#endif
+
 size_t fuse_dirent_size(size_t namelen);
 
 char *fuse_add_dirent(char *buf, const char *name, const struct stat *stbuf,
 		      off_t off);
 
-#ifndef __FreeBSD__
+#if !defined __FreeBSD__ && !defined __CYGWIN__
 
 #include <sys/statfs.h>
 
 struct fuse_lowlevel_ops_compat {
 	void (*init) (void *userdata);
 	void (*destroy) (void *userdata);
 	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
 	void (*forget) (fuse_req_t req, fuse_ino_t ino, unsigned long nlookup);
 	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
 			 struct fuse_file_info_compat *fi);
 	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
 			 int to_set, struct fuse_file_info_compat *fi);
 	void (*readlink) (fuse_req_t req, fuse_ino_t ino);
 	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
 		       mode_t mode, dev_t rdev);
 	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
 		       mode_t mode);
 	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
 	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
 	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
@@ -122,34 +126,42 @@ struct fuse_lowlevel_ops_compat {
 	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
 			  const char *value, size_t size, int flags);
 	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
 			  size_t size);
 	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);
 	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);
 	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);
 	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
 			mode_t mode, struct fuse_file_info_compat *fi);
 };
 
 int fuse_reply_statfs_compat(fuse_req_t req, const struct statfs *stbuf);
 
 int fuse_reply_open_compat(fuse_req_t req,
 			   const struct fuse_file_info_compat *fi);
 
 struct fuse_session *fuse_lowlevel_new_compat(const char *opts,
 				const struct fuse_lowlevel_ops_compat *op,
 				size_t op_size, void *userdata);
 
-#endif /* __FreeBSD__ */
+#endif /* __FreeBSD__ || __CYGWIN__*/
+
+#ifndef __CYGWIN__
 
 struct fuse_chan_ops_compat24 {
 	int (*receive)(struct fuse_chan *ch, char *buf, size_t size);
 	int (*send)(struct fuse_chan *ch, const struct iovec iov[],
 		    size_t count);
 	void (*destroy)(struct fuse_chan *ch);
 };
 
 struct fuse_chan *fuse_chan_new_compat24(struct fuse_chan_ops_compat24 *op,
 					 int fd, size_t bufsize, void *data);
 
+#endif /* __CYGWIN__ */
+
 int fuse_chan_receive(struct fuse_chan *ch, char *buf, size_t size);
+#if defined __CYGWIN__
+struct fuse_chan *fuse_kern_chan_new(HANDLE fd);
+#else
 struct fuse_chan *fuse_kern_chan_new(int fd);
+#endif
Index: fuse-2.8.5/include/fuse_lowlevel.h
===================================================================
--- fuse-2.8.5.orig/include/fuse_lowlevel.h
+++ fuse-2.8.5/include/fuse_lowlevel.h
@@ -15,40 +15,44 @@
  *
  * IMPORTANT: you should define FUSE_USE_VERSION before including this
  * header.  To use the newest API define it to 26 (recommended for any
  * new application), to use the old API define it to 24 (default) or
  * 25
  */
 
 #ifndef FUSE_USE_VERSION
 #define FUSE_USE_VERSION 24
 #endif
 
 #include "fuse_common.h"
 
 #include <utime.h>
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/statvfs.h>
 #include <sys/uio.h>
 
+#ifdef __CYGWIN__
+# include <windows.h>
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* ----------------------------------------------------------- *
  * Miscellaneous definitions				       *
  * ----------------------------------------------------------- */
 
 /** The node ID of the root inode */
 #define FUSE_ROOT_ID 1
 
 /** Inode number type */
 typedef unsigned long fuse_ino_t;
 
 /** Request pointer type */
 typedef struct fuse_req *fuse_req_t;
 
 /**
  * Session
  *
@@ -1463,50 +1467,60 @@ struct fuse_chan_ops {
 	int (*send)(struct fuse_chan *ch, const struct iovec iov[],
 		    size_t count);
 
 	/**
 	 * Destroy the channel
 	 *
 	 * @param ch the channel
 	 */
 	void (*destroy)(struct fuse_chan *ch);
 };
 
 /**
  * Create a new channel
  *
  * @param op channel operations
  * @param fd file descriptor of the channel
  * @param bufsize the minimal receive buffer size
  * @param data user data
  * @return the new channel object, or NULL on failure
  */
-struct fuse_chan *fuse_chan_new(struct fuse_chan_ops *op, int fd,
+struct fuse_chan *fuse_chan_new(struct fuse_chan_ops *op,
+#if defined __CYGWIN__
+				HANDLE fd,
+#else
+				int fd,
+#endif
 				size_t bufsize, void *data);
 
 /**
  * Query the file descriptor of the channel
  *
  * @param ch the channel
  * @return the file descriptor passed to fuse_chan_new()
  */
-int fuse_chan_fd(struct fuse_chan *ch);
+#if defined __CYGWIN__
+HANDLE
+#else
+int
+#endif
+fuse_chan_fd(struct fuse_chan *ch);
 
 /**
  * Query the minimal receive buffer size
  *
  * @param ch the channel
  * @return the buffer size passed to fuse_chan_new()
  */
 size_t fuse_chan_bufsize(struct fuse_chan *ch);
 
 /**
  * Query the user data
  *
  * @param ch the channel
  * @return the user data passed to fuse_chan_new()
  */
 void *fuse_chan_data(struct fuse_chan *ch);
 
 /**
  * Query the session to which this channel is assigned
  *
Index: fuse-2.8.5/include/fusent_proto.h
===================================================================
--- /dev/null
+++ fuse-2.8.5/include/fusent_proto.h
@@ -0,0 +1,144 @@
+/*
+  FUSE-NT: Filesystem in Userspace (for Windows NT)
+  Copyright (C) 2011  The FUSE-NT Authors
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file LGPLv2.txt.
+*/
+
+#ifdef __CYGWIN__
+#ifndef NTPROTO_H
+#define NTPROTO_H
+
+// Protocol structs, shared types, etc.
+
+// Why don't any of the windows headers include the headers they depend on
+// to define types (ULONG, NTSTATUS, CSHORT, WCHAR, ...)? Retarded.
+//
+// Why don't they just use the standard types (uint32_t, ...)?!?
+#define NTOSAPI /**/
+#define DDKAPI /**/
+#include <windef.h>
+#include <winnt.h>
+#include <ntdef.h>
+#include <ddk/ntddk.h>
+#include <ddk/winddk.h>
+#include <stdint.h>
+#include <ddk/ntifs.h>
+
+//
+//  NtFsControlFile FSCTL codes. These functions codes are chosen to be
+//  outside of Microsoft's reserved range
+//
+
+// The control code for a request by a module to the driver asking the
+// driver to allocate any necessary structures before the module assigns
+// itself a drive letter
+#define IRP_FUSE_MOUNT CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 3131, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// The control code for a response from a module to the driver. Whenever a
+// module finishes a create, read, write, etc. as requested by a userspace
+// application, it calls down to the driver with this control code and a
+// FUSENT_RESP in its buffer
+#define IRP_FUSE_MODULE_RESPONSE CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 3132, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+// The control code for a request for work by a module to the driver.
+// The driver takes requests for work from modules and assigns userspace
+// requests to them
+#define IRP_FUSE_MODULE_REQUEST CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 3133, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+//
+// Requests from Kernel to Userspace
+//
+
+typedef struct _FUSENT_REQ {
+	PIRP pirp;
+	PFILE_OBJECT fop;
+	IRP irp;
+	IO_STACK_LOCATION iostack[0];
+} FUSENT_REQ;
+
+typedef struct _FUSENT_CREATE_REQ {
+	PIRP pirp;
+	PFILE_OBJECT fop;
+	IRP irp;
+	IO_STACK_LOCATION iostack[0];
+
+	// Followed by:
+	// uint32_t fnamelen; // in bytes
+	// uint16_t fname[0]; // fnamelen bytes of UTF-16LE file name
+} FUSENT_CREATE_REQ;
+
+// Takes a FUSE_CREATE_REQ and finds the variably-located fields:
+void fusent_decode_request_create(FUSENT_CREATE_REQ *req, uint32_t *outfnamelen,
+		uint16_t **outfnamep);
+
+typedef struct _FUSENT_WRITE_REQ {
+	PIRP pirp;
+	PFILE_OBJECT fop;
+	IRP irp;
+	IO_STACK_LOCATION iostack[0];
+
+	// Followed by:
+	// uint32_t buflen;
+	// uint8_t buf[0]; // buflen bytes of write data
+} FUSENT_WRITE_REQ;
+
+// Takes a FUSE_WRITE_REQ and finds the variably-located fields:
+void fusent_decode_request_write(FUSENT_WRITE_REQ *req, uint32_t *outbuflen,
+		uint8_t **outbufp);
+
+//
+// Responses (Userspace to Kernelspace)
+//
+
+typedef struct _FUSENT_MOUNT { // weird special-case "response"
+	uint32_t mtptlen; // in bytes
+	uint32_t mtoptslen; // in bytes
+	uint8_t rem[0]; // mtptlen bytes of UTF-16LE mount path,
+	// followed by mtoptslen bytes of mount options
+	// (mtptlen should be word-sized and nul-padded to make
+	// mtopts aligned)
+} FUSENT_MOUNT;
+
+typedef struct _FUSENT_FILE_INFORMATION {
+	LARGE_INTEGER CreationTime;
+	LARGE_INTEGER LastAccessTime;
+	LARGE_INTEGER LastWriteTime;
+	LARGE_INTEGER ChangeTime;
+	ULONG FileAttributes;
+	LARGE_INTEGER AllocationSize;
+	LARGE_INTEGER EndOfFile;
+	ULONG NumberOfLinks;
+	BOOLEAN DeletePending;
+	BOOLEAN Directory;
+} FUSENT_FILE_INFORMATION;
+
+typedef struct _FUSENT_RESP {
+	PIRP pirp;
+	PFILE_OBJECT fop;
+	int error; // all high-level fuse operations return int
+	// negative is error (-errno); zero is OK
+	NTSTATUS status;
+	union {
+		struct {
+			uint32_t buflen;
+			//uint8_t buf[0]; buf is defined as following the FUSENT_RESP header.
+		} read;
+		struct {
+			uint32_t written;
+		} write;
+		struct {
+			uint32_t buflen;
+			// defined as following the FUSENT_RESP header
+		} query;
+		struct {
+			uint32_t buflen;
+			// FILE_DIRECTORY_INFORMATION dirinfo[0]; defined as following the FUSENT_RESP header.
+		} dirctrl;
+		// potentially other kinds of responses here...
+	} params;
+} FUSENT_RESP;
+
+#endif /* NTPROTO_H */
+#endif /* __CYGWIN__ */
Index: fuse-2.8.5/include/fusent_routines.h
===================================================================
--- /dev/null
+++ fuse-2.8.5/include/fusent_routines.h
@@ -0,0 +1,44 @@
+/*
+  FUSE-NT: Filesystem in Userspace (for Windows NT)
+  Copyright (C) 2011  The FUSE-NT Authors
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file LGPLv2.txt.
+*/
+
+#ifdef __CYGWIN__
+#ifndef IRPDECODE_H
+#define IRPDECODE_H
+
+// Windows headers don't pull in their own dependencies... see fusent_proto.h:
+#define NTOSAPI /**/
+#ifndef DDKAPI
+# define DDKAPI /**/
+#endif
+#include <windef.h>
+#include <winnt.h>
+#include <ntdef.h>
+#include <ddk/ntddk.h>
+#include <ddk/winddk.h>
+#include <stdint.h>
+#include <time.h>
+
+#include <iconv.h>
+
+// Decodes an IRP (and associated IO stack) to locate the current stack entry
+// and the IRP major number.
+//
+// Returns non-negative on success.
+int fusent_decode_irp(IRP *irp, IO_STACK_LOCATION *iosp, uint8_t *outirptype,
+		IO_STACK_LOCATION **outiosp);
+
+// Translates a string from one encoding to another.
+//
+// Returns negative on error, or the number of bytes output on success.
+size_t fusent_transcode(void *src, size_t s_len, void *dst, size_t d_len, const char *in_enc, const char *out_enc);
+
+// Translates (roughly) a Unix time_t (seconds since unix epoch) to a Windows' LARGE_INTEGER time (100-ns intervals since Jan 1, 1601).
+void fusent_unixtime_to_wintime(time_t t, LARGE_INTEGER *wintime);
+
+#endif /* IRPDECODE_H */
+#endif /* __CYGWIN__ */
Index: fuse-2.8.5/include/fusent_translate.h
===================================================================
--- /dev/null
+++ fuse-2.8.5/include/fusent_translate.h
@@ -0,0 +1,23 @@
+/*
+  FUSE-NT: Filesystem in Userspace (for Windows NT)
+  Copyright (C) 2011  The FUSE-NT Authors
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file LGPLv2.txt.
+*/
+
+#ifdef __CYGWIN__
+#ifndef FUSENT_TRANSLATE_H
+#define FUSENT_TRANSLATE_H
+
+#include "fusent_proto.h"
+
+// Sets up any data structures fusent_translate will need to persist
+// across calls.
+void fusent_translate_setup(void);
+
+// Destroys any persistant data structures at shut down.
+void fusent_translate_teardown(void);
+
+#endif /* FUSENT_TRANSLATE_H */
+#endif /* __CYGWIN__ */
Index: fuse-2.8.5/include/st.h
===================================================================
--- /dev/null
+++ fuse-2.8.5/include/st.h
@@ -0,0 +1,122 @@
+/* This is a public domain general purpose hash table package written by Peter Moore @ UCB. */
+
+/* @(#) st.h 5.1 89/12/14 */
+
+#ifndef ST_H
+#define ST_H 1
+
+#if defined(__cplusplus)
+extern "C" {
+#if 0
+} /* satisfy cc-mode */
+#endif
+#endif
+
+#include <stddef.h>
+#include <stdint.h>
+#include <inttypes.h>
+
+#if defined __GNUC__ && __GNUC__ >= 4
+#pragma GCC visibility push(default)
+#endif
+
+typedef uintptr_t st_data_t;
+#define ST_DATA_T_DEFINED
+
+#ifndef CHAR_BIT
+# define CHAR_BIT 8
+#endif
+#ifndef _
+# define _(args) args
+#endif
+#ifndef ANYARGS
+# ifdef __cplusplus
+#   define ANYARGS ...
+# else
+#   define ANYARGS
+# endif
+#endif
+
+typedef struct st_table st_table;
+
+typedef st_data_t st_index_t;
+typedef int st_compare_func(st_data_t, st_data_t);
+typedef st_index_t st_hash_func(st_data_t);
+
+struct st_hash_type {
+    int (*compare)(ANYARGS /*st_data_t, st_data_t*/); /* st_compare_func* */
+    st_index_t (*hash)(ANYARGS /*st_data_t*/);        /* st_hash_func* */
+};
+
+#define ST_INDEX_BITS (sizeof(st_index_t) * CHAR_BIT)
+
+struct st_table {
+    const struct st_hash_type *type;
+    st_index_t num_bins;
+    unsigned int entries_packed : 1;
+#ifdef __GNUC__
+    /*
+     * C spec says,
+     *   A bit-field shall have a type that is a qualified or unqualified
+     *   version of _Bool, signed int, unsigned int, or some other
+     *   implementation-defined type. It is implementation-defined whether
+     *   atomic types are permitted.
+     * In short, long and long long bit-field are implementation-defined
+     * feature. Therefore we want to supress a warning explicitly.
+     */
+    __extension__
+#endif
+    st_index_t num_entries : ST_INDEX_BITS - 1;
+    struct st_table_entry **bins;
+    struct st_table_entry *head, *tail;
+};
+
+#define st_is_member(table,key) st_lookup((table),(key),(st_data_t *)0)
+
+enum st_retval {ST_CONTINUE, ST_STOP, ST_DELETE, ST_CHECK};
+
+st_table *st_init_table(const struct st_hash_type *);
+st_table *st_init_table_with_size(const struct st_hash_type *, st_index_t);
+st_table *st_init_numtable(void);
+st_table *st_init_numtable_with_size(st_index_t);
+st_table *st_init_strtable(void);
+st_table *st_init_strtable_with_size(st_index_t);
+st_table *st_init_strcasetable(void);
+st_table *st_init_strcasetable_with_size(st_index_t);
+int st_delete(st_table *, st_data_t *, st_data_t *); /* returns 0:notfound 1:deleted */
+int st_delete_safe(st_table *, st_data_t *, st_data_t *, st_data_t);
+int st_insert(st_table *, st_data_t, st_data_t);
+int st_insert2(st_table *, st_data_t, st_data_t, st_data_t (*)(st_data_t));
+int st_lookup(st_table *, st_data_t, st_data_t *);
+int st_get_key(st_table *, st_data_t, st_data_t *);
+int st_foreach(st_table *, int (*)(ANYARGS), st_data_t);
+int st_reverse_foreach(st_table *, int (*)(ANYARGS), st_data_t);
+void st_add_direct(st_table *, st_data_t, st_data_t);
+void st_free_table(st_table *);
+void st_cleanup_safe(st_table *, st_data_t);
+void st_clear(st_table *);
+st_table *st_copy(st_table *);
+int st_numcmp(st_data_t, st_data_t);
+st_index_t st_numhash(st_data_t);
+int st_strcasecmp(const char *s1, const char *s2);
+int st_strncasecmp(const char *s1, const char *s2, size_t n);
+size_t st_memsize(const st_table *);
+st_index_t st_hash(const void *ptr, size_t len, st_index_t h);
+st_index_t st_hash_uint32(st_index_t h, uint32_t i);
+st_index_t st_hash_uint(st_index_t h, st_index_t i);
+st_index_t st_hash_end(st_index_t h);
+st_index_t st_hash_start(st_index_t h);
+#define st_hash_start(h) ((st_index_t)(h))
+
+#if defined __GNUC__ && __GNUC__ >= 4
+#pragma GCC visibility pop
+#endif
+
+#if defined(__cplusplus)
+#if 0
+{ /* satisfy cc-mode */
+#endif
+}  /* extern "C" { */
+#endif
+
+#endif /* ST_H */
Index: fuse-2.8.5/kernel/control.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/control.c
@@ -0,0 +1,359 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+
+#define FUSE_CTL_SUPER_MAGIC 0x65735543
+
+/*
+ * This is non-NULL when the single instance of the control filesystem
+ * exists.  Protected by fuse_mutex
+ */
+static struct super_block *fuse_control_sb;
+
+static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)
+{
+	struct fuse_conn *fc;
+	mutex_lock(&fuse_mutex);
+	fc = file->f_path.dentry->d_inode->i_private;
+	if (fc)
+		fc = fuse_conn_get(fc);
+	mutex_unlock(&fuse_mutex);
+	return fc;
+}
+
+static ssize_t fuse_conn_abort_write(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	struct fuse_conn *fc = fuse_ctl_file_conn_get(file);
+	if (fc) {
+		fuse_abort_conn(fc);
+		fuse_conn_put(fc);
+	}
+	return count;
+}
+
+static ssize_t fuse_conn_waiting_read(struct file *file, char __user *buf,
+				      size_t len, loff_t *ppos)
+{
+	char tmp[32];
+	size_t size;
+
+	if (!*ppos) {
+		long value;
+		struct fuse_conn *fc = fuse_ctl_file_conn_get(file);
+		if (!fc)
+			return 0;
+
+		value = atomic_read(&fc->num_waiting);
+		file->private_data = (void *)value;
+		fuse_conn_put(fc);
+	}
+	size = sprintf(tmp, "%ld\n", (long)file->private_data);
+	return simple_read_from_buffer(buf, len, ppos, tmp, size);
+}
+
+static ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,
+				    size_t len, loff_t *ppos, unsigned val)
+{
+	char tmp[32];
+	size_t size = sprintf(tmp, "%u\n", val);
+
+	return simple_read_from_buffer(buf, len, ppos, tmp, size);
+}
+
+static ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos, unsigned *val,
+				     unsigned global_limit)
+{
+	unsigned long t;
+	char tmp[32];
+	unsigned limit = (1 << 16) - 1;
+	int err;
+
+	if (*ppos || count >= sizeof(tmp) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EINVAL;
+
+	tmp[count] = '\0';
+
+	err = strict_strtoul(tmp, 0, &t);
+	if (err)
+		return err;
+
+	if (!capable(CAP_SYS_ADMIN))
+		limit = min(limit, global_limit);
+
+	if (t > limit)
+		return -EINVAL;
+
+	*val = t;
+
+	return count;
+}
+
+static ssize_t fuse_conn_max_background_read(struct file *file,
+					     char __user *buf, size_t len,
+					     loff_t *ppos)
+{
+	struct fuse_conn *fc;
+	unsigned val;
+
+	fc = fuse_ctl_file_conn_get(file);
+	if (!fc)
+		return 0;
+
+	val = fc->max_background;
+	fuse_conn_put(fc);
+
+	return fuse_conn_limit_read(file, buf, len, ppos, val);
+}
+
+static ssize_t fuse_conn_max_background_write(struct file *file,
+					      const char __user *buf,
+					      size_t count, loff_t *ppos)
+{
+	unsigned val;
+	ssize_t ret;
+
+	ret = fuse_conn_limit_write(file, buf, count, ppos, &val,
+				    max_user_bgreq);
+	if (ret > 0) {
+		struct fuse_conn *fc = fuse_ctl_file_conn_get(file);
+		if (fc) {
+			fc->max_background = val;
+			fuse_conn_put(fc);
+		}
+	}
+
+	return ret;
+}
+
+static ssize_t fuse_conn_congestion_threshold_read(struct file *file,
+						   char __user *buf, size_t len,
+						   loff_t *ppos)
+{
+	struct fuse_conn *fc;
+	unsigned val;
+
+	fc = fuse_ctl_file_conn_get(file);
+	if (!fc)
+		return 0;
+
+	val = fc->congestion_threshold;
+	fuse_conn_put(fc);
+
+	return fuse_conn_limit_read(file, buf, len, ppos, val);
+}
+
+static ssize_t fuse_conn_congestion_threshold_write(struct file *file,
+						    const char __user *buf,
+						    size_t count, loff_t *ppos)
+{
+	unsigned val;
+	ssize_t ret;
+
+	ret = fuse_conn_limit_write(file, buf, count, ppos, &val,
+				    max_user_congthresh);
+	if (ret > 0) {
+		struct fuse_conn *fc = fuse_ctl_file_conn_get(file);
+		if (fc) {
+			fc->congestion_threshold = val;
+			fuse_conn_put(fc);
+		}
+	}
+
+	return ret;
+}
+
+static const struct file_operations fuse_ctl_abort_ops = {
+	.open = nonseekable_open,
+	.write = fuse_conn_abort_write,
+	.llseek = no_llseek,
+};
+
+static const struct file_operations fuse_ctl_waiting_ops = {
+	.open = nonseekable_open,
+	.read = fuse_conn_waiting_read,
+	.llseek = no_llseek,
+};
+
+static const struct file_operations fuse_conn_max_background_ops = {
+	.open = nonseekable_open,
+	.read = fuse_conn_max_background_read,
+	.write = fuse_conn_max_background_write,
+	.llseek = no_llseek,
+};
+
+static const struct file_operations fuse_conn_congestion_threshold_ops = {
+	.open = nonseekable_open,
+	.read = fuse_conn_congestion_threshold_read,
+	.write = fuse_conn_congestion_threshold_write,
+	.llseek = no_llseek,
+};
+
+static struct dentry *fuse_ctl_add_dentry(struct dentry *parent,
+					  struct fuse_conn *fc,
+					  const char *name,
+					  int mode, int nlink,
+					  const struct inode_operations *iop,
+					  const struct file_operations *fop)
+{
+	struct dentry *dentry;
+	struct inode *inode;
+
+	BUG_ON(fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES);
+	dentry = d_alloc_name(parent, name);
+	if (!dentry)
+		return NULL;
+
+	fc->ctl_dentry[fc->ctl_ndents++] = dentry;
+	inode = new_inode(fuse_control_sb);
+	if (!inode)
+		return NULL;
+
+	inode->i_ino = get_next_ino();
+	inode->i_mode = mode;
+	inode->i_uid = fc->user_id;
+	inode->i_gid = fc->group_id;
+	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	/* setting ->i_op to NULL is not allowed */
+	if (iop)
+		inode->i_op = iop;
+	inode->i_fop = fop;
+	inode->i_nlink = nlink;
+	inode->i_private = fc;
+	d_add(dentry, inode);
+	return dentry;
+}
+
+/*
+ * Add a connection to the control filesystem (if it exists).  Caller
+ * must hold fuse_mutex
+ */
+int fuse_ctl_add_conn(struct fuse_conn *fc)
+{
+	struct dentry *parent;
+	char name[32];
+
+	if (!fuse_control_sb)
+		return 0;
+
+	parent = fuse_control_sb->s_root;
+	inc_nlink(parent->d_inode);
+	sprintf(name, "%u", fc->dev);
+	parent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,
+				     &simple_dir_inode_operations,
+				     &simple_dir_operations);
+	if (!parent)
+		goto err;
+
+	if (!fuse_ctl_add_dentry(parent, fc, "waiting", S_IFREG | 0400, 1,
+				 NULL, &fuse_ctl_waiting_ops) ||
+	    !fuse_ctl_add_dentry(parent, fc, "abort", S_IFREG | 0200, 1,
+				 NULL, &fuse_ctl_abort_ops) ||
+	    !fuse_ctl_add_dentry(parent, fc, "max_background", S_IFREG | 0600,
+				 1, NULL, &fuse_conn_max_background_ops) ||
+	    !fuse_ctl_add_dentry(parent, fc, "congestion_threshold",
+				 S_IFREG | 0600, 1, NULL,
+				 &fuse_conn_congestion_threshold_ops))
+		goto err;
+
+	return 0;
+
+ err:
+	fuse_ctl_remove_conn(fc);
+	return -ENOMEM;
+}
+
+/*
+ * Remove a connection from the control filesystem (if it exists).
+ * Caller must hold fuse_mutex
+ */
+void fuse_ctl_remove_conn(struct fuse_conn *fc)
+{
+	int i;
+
+	if (!fuse_control_sb)
+		return;
+
+	for (i = fc->ctl_ndents - 1; i >= 0; i--) {
+		struct dentry *dentry = fc->ctl_dentry[i];
+		dentry->d_inode->i_private = NULL;
+		d_drop(dentry);
+		dput(dentry);
+	}
+	drop_nlink(fuse_control_sb->s_root->d_inode);
+}
+
+static int fuse_ctl_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct tree_descr empty_descr = {""};
+	struct fuse_conn *fc;
+	int err;
+
+	err = simple_fill_super(sb, FUSE_CTL_SUPER_MAGIC, &empty_descr);
+	if (err)
+		return err;
+
+	mutex_lock(&fuse_mutex);
+	BUG_ON(fuse_control_sb);
+	fuse_control_sb = sb;
+	list_for_each_entry(fc, &fuse_conn_list, entry) {
+		err = fuse_ctl_add_conn(fc);
+		if (err) {
+			fuse_control_sb = NULL;
+			mutex_unlock(&fuse_mutex);
+			return err;
+		}
+	}
+	mutex_unlock(&fuse_mutex);
+
+	return 0;
+}
+
+static struct dentry *fuse_ctl_mount(struct file_system_type *fs_type,
+			int flags, const char *dev_name, void *raw_data)
+{
+	return mount_single(fs_type, flags, raw_data, fuse_ctl_fill_super);
+}
+
+static void fuse_ctl_kill_sb(struct super_block *sb)
+{
+	struct fuse_conn *fc;
+
+	mutex_lock(&fuse_mutex);
+	fuse_control_sb = NULL;
+	list_for_each_entry(fc, &fuse_conn_list, entry)
+		fc->ctl_ndents = 0;
+	mutex_unlock(&fuse_mutex);
+
+	kill_litter_super(sb);
+}
+
+static struct file_system_type fuse_ctl_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "fusectl",
+	.mount		= fuse_ctl_mount,
+	.kill_sb	= fuse_ctl_kill_sb,
+};
+
+int __init fuse_ctl_init(void)
+{
+	return register_filesystem(&fuse_ctl_fs_type);
+}
+
+void fuse_ctl_cleanup(void)
+{
+	unregister_filesystem(&fuse_ctl_fs_type);
+}
Index: fuse-2.8.5/kernel/cuse.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/cuse.c
@@ -0,0 +1,620 @@
+/*
+ * CUSE: Character device in Userspace
+ *
+ * Copyright (C) 2008-2009  SUSE Linux Products GmbH
+ * Copyright (C) 2008-2009  Tejun Heo <tj@kernel.org>
+ *
+ * This file is released under the GPLv2.
+ *
+ * CUSE enables character devices to be implemented from userland much
+ * like FUSE allows filesystems.  On initialization /dev/cuse is
+ * created.  By opening the file and replying to the CUSE_INIT request
+ * userland CUSE server can create a character device.  After that the
+ * operation is very similar to FUSE.
+ *
+ * A CUSE instance involves the following objects.
+ *
+ * cuse_conn	: contains fuse_conn and serves as bonding structure
+ * channel	: file handle connected to the userland CUSE server
+ * cdev		: the implemented character device
+ * dev		: generic device for cdev
+ *
+ * Note that 'channel' is what 'dev' is in FUSE.  As CUSE deals with
+ * devices, it's called 'channel' to reduce confusion.
+ *
+ * channel determines when the character device dies.  When channel is
+ * closed, everything begins to destruct.  The cuse_conn is taken off
+ * the lookup table preventing further access from cdev, cdev and
+ * generic device are removed and the base reference of cuse_conn is
+ * put.
+ *
+ * On each open, the matching cuse_conn is looked up and if found an
+ * additional reference is taken which is released when the file is
+ * closed.
+ */
+
+#include <linux/fuse.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/kdev_t.h>
+#include <linux/kthread.h>
+#include <linux/list.h>
+#include <linux/magic.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/stat.h>
+
+#include "fuse_i.h"
+
+#define CUSE_CONNTBL_LEN	64
+
+struct cuse_conn {
+	struct list_head	list;	/* linked on cuse_conntbl */
+	struct fuse_conn	fc;	/* fuse connection */
+	struct cdev		*cdev;	/* associated character device */
+	struct device		*dev;	/* device representing @cdev */
+
+	/* init parameters, set once during initialization */
+	bool			unrestricted_ioctl;
+};
+
+static DEFINE_SPINLOCK(cuse_lock);		/* protects cuse_conntbl */
+static struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];
+static struct class *cuse_class;
+
+static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)
+{
+	return container_of(fc, struct cuse_conn, fc);
+}
+
+static struct list_head *cuse_conntbl_head(dev_t devt)
+{
+	return &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];
+}
+
+
+/**************************************************************************
+ * CUSE frontend operations
+ *
+ * These are file operations for the character device.
+ *
+ * On open, CUSE opens a file from the FUSE mnt and stores it to
+ * private_data of the open file.  All other ops call FUSE ops on the
+ * FUSE file.
+ */
+
+static ssize_t cuse_read(struct file *file, char __user *buf, size_t count,
+			 loff_t *ppos)
+{
+	loff_t pos = 0;
+
+	return fuse_direct_io(file, buf, count, &pos, 0);
+}
+
+static ssize_t cuse_write(struct file *file, const char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	loff_t pos = 0;
+	/*
+	 * No locking or generic_write_checks(), the server is
+	 * responsible for locking and sanity checks.
+	 */
+	return fuse_direct_io(file, buf, count, &pos, 1);
+}
+
+static int cuse_open(struct inode *inode, struct file *file)
+{
+	dev_t devt = inode->i_cdev->dev;
+	struct cuse_conn *cc = NULL, *pos;
+	int rc;
+
+	/* look up and get the connection */
+	spin_lock(&cuse_lock);
+	list_for_each_entry(pos, cuse_conntbl_head(devt), list)
+		if (pos->dev->devt == devt) {
+			fuse_conn_get(&pos->fc);
+			cc = pos;
+			break;
+		}
+	spin_unlock(&cuse_lock);
+
+	/* dead? */
+	if (!cc)
+		return -ENODEV;
+
+	/*
+	 * Generic permission check is already done against the chrdev
+	 * file, proceed to open.
+	 */
+	rc = fuse_do_open(&cc->fc, 0, file, 0);
+	if (rc)
+		fuse_conn_put(&cc->fc);
+	return rc;
+}
+
+static int cuse_release(struct inode *inode, struct file *file)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = ff->fc;
+
+	fuse_sync_release(ff, file->f_flags);
+	fuse_conn_put(fc);
+
+	return 0;
+}
+
+static long cuse_file_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	struct fuse_file *ff = file->private_data;
+	struct cuse_conn *cc = fc_to_cc(ff->fc);
+	unsigned int flags = 0;
+
+	if (cc->unrestricted_ioctl)
+		flags |= FUSE_IOCTL_UNRESTRICTED;
+
+	return fuse_do_ioctl(file, cmd, arg, flags);
+}
+
+static long cuse_file_compat_ioctl(struct file *file, unsigned int cmd,
+				   unsigned long arg)
+{
+	struct fuse_file *ff = file->private_data;
+	struct cuse_conn *cc = fc_to_cc(ff->fc);
+	unsigned int flags = FUSE_IOCTL_COMPAT;
+
+	if (cc->unrestricted_ioctl)
+		flags |= FUSE_IOCTL_UNRESTRICTED;
+
+	return fuse_do_ioctl(file, cmd, arg, flags);
+}
+
+static const struct file_operations cuse_frontend_fops = {
+	.owner			= THIS_MODULE,
+	.read			= cuse_read,
+	.write			= cuse_write,
+	.open			= cuse_open,
+	.release		= cuse_release,
+	.unlocked_ioctl		= cuse_file_ioctl,
+	.compat_ioctl		= cuse_file_compat_ioctl,
+	.poll			= fuse_file_poll,
+	.llseek		= noop_llseek,
+};
+
+
+/**************************************************************************
+ * CUSE channel initialization and destruction
+ */
+
+struct cuse_devinfo {
+	const char		*name;
+};
+
+/**
+ * cuse_parse_one - parse one key=value pair
+ * @pp: i/o parameter for the current position
+ * @end: points to one past the end of the packed string
+ * @keyp: out parameter for key
+ * @valp: out parameter for value
+ *
+ * *@pp points to packed strings - "key0=val0\0key1=val1\0" which ends
+ * at @end - 1.  This function parses one pair and set *@keyp to the
+ * start of the key and *@valp to the start of the value.  Note that
+ * the original string is modified such that the key string is
+ * terminated with '\0'.  *@pp is updated to point to the next string.
+ *
+ * RETURNS:
+ * 1 on successful parse, 0 on EOF, -errno on failure.
+ */
+static int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)
+{
+	char *p = *pp;
+	char *key, *val;
+
+	while (p < end && *p == '\0')
+		p++;
+	if (p == end)
+		return 0;
+
+	if (end[-1] != '\0') {
+		printk(KERN_ERR "CUSE: info not properly terminated\n");
+		return -EINVAL;
+	}
+
+	key = val = p;
+	p += strlen(p);
+
+	if (valp) {
+		strsep(&val, "=");
+		if (!val)
+			val = key + strlen(key);
+		key = strstrip(key);
+		val = strstrip(val);
+	} else
+		key = strstrip(key);
+
+	if (!strlen(key)) {
+		printk(KERN_ERR "CUSE: zero length info key specified\n");
+		return -EINVAL;
+	}
+
+	*pp = p;
+	*keyp = key;
+	if (valp)
+		*valp = val;
+
+	return 1;
+}
+
+/**
+ * cuse_parse_dev_info - parse device info
+ * @p: device info string
+ * @len: length of device info string
+ * @devinfo: out parameter for parsed device info
+ *
+ * Parse @p to extract device info and store it into @devinfo.  String
+ * pointed to by @p is modified by parsing and @devinfo points into
+ * them, so @p shouldn't be freed while @devinfo is in use.
+ *
+ * RETURNS:
+ * 0 on success, -errno on failure.
+ */
+static int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)
+{
+	char *end = p + len;
+	char *key, *val;
+	int rc;
+
+	while (true) {
+		rc = cuse_parse_one(&p, end, &key, &val);
+		if (rc < 0)
+			return rc;
+		if (!rc)
+			break;
+		if (strcmp(key, "DEVNAME") == 0)
+			devinfo->name = val;
+		else
+			printk(KERN_WARNING "CUSE: unknown device info \"%s\"\n",
+			       key);
+	}
+
+	if (!devinfo->name || !strlen(devinfo->name)) {
+		printk(KERN_ERR "CUSE: DEVNAME unspecified\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void cuse_gendev_release(struct device *dev)
+{
+	kfree(dev);
+}
+
+/**
+ * cuse_process_init_reply - finish initializing CUSE channel
+ *
+ * This function creates the character device and sets up all the
+ * required data structures for it.  Please read the comment at the
+ * top of this file for high level overview.
+ */
+static void cuse_process_init_reply(struct fuse_conn *fc, struct fuse_req *req)
+{
+	struct cuse_conn *cc = fc_to_cc(fc);
+	struct cuse_init_out *arg = req->out.args[0].value;
+	struct page *page = req->pages[0];
+	struct cuse_devinfo devinfo = { };
+	struct device *dev;
+	struct cdev *cdev;
+	dev_t devt;
+	int rc;
+
+	if (req->out.h.error ||
+	    arg->major != FUSE_KERNEL_VERSION || arg->minor < 11) {
+		goto err;
+	}
+
+	fc->minor = arg->minor;
+	fc->max_read = max_t(unsigned, arg->max_read, 4096);
+	fc->max_write = max_t(unsigned, arg->max_write, 4096);
+
+	/* parse init reply */
+	cc->unrestricted_ioctl = arg->flags & CUSE_UNRESTRICTED_IOCTL;
+
+	rc = cuse_parse_devinfo(page_address(page), req->out.args[1].size,
+				&devinfo);
+	if (rc)
+		goto err;
+
+	/* determine and reserve devt */
+	devt = MKDEV(arg->dev_major, arg->dev_minor);
+	if (!MAJOR(devt))
+		rc = alloc_chrdev_region(&devt, MINOR(devt), 1, devinfo.name);
+	else
+		rc = register_chrdev_region(devt, 1, devinfo.name);
+	if (rc) {
+		printk(KERN_ERR "CUSE: failed to register chrdev region\n");
+		goto err;
+	}
+
+	/* devt determined, create device */
+	rc = -ENOMEM;
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		goto err_region;
+
+	device_initialize(dev);
+	dev_set_uevent_suppress(dev, 1);
+	dev->class = cuse_class;
+	dev->devt = devt;
+	dev->release = cuse_gendev_release;
+	dev_set_drvdata(dev, cc);
+	dev_set_name(dev, "%s", devinfo.name);
+
+	rc = device_add(dev);
+	if (rc)
+		goto err_device;
+
+	/* register cdev */
+	rc = -ENOMEM;
+	cdev = cdev_alloc();
+	if (!cdev)
+		goto err_device;
+
+	cdev->owner = THIS_MODULE;
+	cdev->ops = &cuse_frontend_fops;
+
+	rc = cdev_add(cdev, devt, 1);
+	if (rc)
+		goto err_cdev;
+
+	cc->dev = dev;
+	cc->cdev = cdev;
+
+	/* make the device available */
+	spin_lock(&cuse_lock);
+	list_add(&cc->list, cuse_conntbl_head(devt));
+	spin_unlock(&cuse_lock);
+
+	/* announce device availability */
+	dev_set_uevent_suppress(dev, 0);
+	kobject_uevent(&dev->kobj, KOBJ_ADD);
+out:
+	kfree(arg);
+	__free_page(page);
+	return;
+
+err_cdev:
+	cdev_del(cdev);
+err_device:
+	put_device(dev);
+err_region:
+	unregister_chrdev_region(devt, 1);
+err:
+	fc->conn_error = 1;
+	goto out;
+}
+
+static int cuse_send_init(struct cuse_conn *cc)
+{
+	int rc;
+	struct fuse_req *req;
+	struct page *page;
+	struct fuse_conn *fc = &cc->fc;
+	struct cuse_init_in *arg;
+	void *outarg;
+
+	BUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req)) {
+		rc = PTR_ERR(req);
+		goto err;
+	}
+
+	rc = -ENOMEM;
+	page = alloc_page(GFP_KERNEL | __GFP_ZERO);
+	if (!page)
+		goto err_put_req;
+
+	outarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);
+	if (!outarg)
+		goto err_free_page;
+
+	arg = &req->misc.cuse_init_in;
+	arg->major = FUSE_KERNEL_VERSION;
+	arg->minor = FUSE_KERNEL_MINOR_VERSION;
+	arg->flags |= CUSE_UNRESTRICTED_IOCTL;
+	req->in.h.opcode = CUSE_INIT;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(struct cuse_init_in);
+	req->in.args[0].value = arg;
+	req->out.numargs = 2;
+	req->out.args[0].size = sizeof(struct cuse_init_out);
+	req->out.args[0].value = outarg;
+	req->out.args[1].size = CUSE_INIT_INFO_MAX;
+	req->out.argvar = 1;
+	req->out.argpages = 1;
+	req->pages[0] = page;
+	req->num_pages = 1;
+	req->end = cuse_process_init_reply;
+	fuse_request_send_background(fc, req);
+
+	return 0;
+
+err_free_page:
+	__free_page(page);
+err_put_req:
+	fuse_put_request(fc, req);
+err:
+	return rc;
+}
+
+static void cuse_fc_release(struct fuse_conn *fc)
+{
+	struct cuse_conn *cc = fc_to_cc(fc);
+	kfree(cc);
+}
+
+/**
+ * cuse_channel_open - open method for /dev/cuse
+ * @inode: inode for /dev/cuse
+ * @file: file struct being opened
+ *
+ * Userland CUSE server can create a CUSE device by opening /dev/cuse
+ * and replying to the initialization request kernel sends.  This
+ * function is responsible for handling CUSE device initialization.
+ * Because the fd opened by this function is used during
+ * initialization, this function only creates cuse_conn and sends
+ * init.  The rest is delegated to a kthread.
+ *
+ * RETURNS:
+ * 0 on success, -errno on failure.
+ */
+static int cuse_channel_open(struct inode *inode, struct file *file)
+{
+	struct cuse_conn *cc;
+	int rc;
+
+	/* set up cuse_conn */
+	cc = kzalloc(sizeof(*cc), GFP_KERNEL);
+	if (!cc)
+		return -ENOMEM;
+
+	fuse_conn_init(&cc->fc);
+
+	INIT_LIST_HEAD(&cc->list);
+	cc->fc.release = cuse_fc_release;
+
+	cc->fc.connected = 1;
+	cc->fc.blocked = 0;
+	rc = cuse_send_init(cc);
+	if (rc) {
+		fuse_conn_put(&cc->fc);
+		return rc;
+	}
+	file->private_data = &cc->fc;	/* channel owns base reference to cc */
+
+	return 0;
+}
+
+/**
+ * cuse_channel_release - release method for /dev/cuse
+ * @inode: inode for /dev/cuse
+ * @file: file struct being closed
+ *
+ * Disconnect the channel, deregister CUSE device and initiate
+ * destruction by putting the default reference.
+ *
+ * RETURNS:
+ * 0 on success, -errno on failure.
+ */
+static int cuse_channel_release(struct inode *inode, struct file *file)
+{
+	struct cuse_conn *cc = fc_to_cc(file->private_data);
+	int rc;
+
+	/* remove from the conntbl, no more access from this point on */
+	spin_lock(&cuse_lock);
+	list_del_init(&cc->list);
+	spin_unlock(&cuse_lock);
+
+	/* remove device */
+	if (cc->dev)
+		device_unregister(cc->dev);
+	if (cc->cdev) {
+		unregister_chrdev_region(cc->cdev->dev, 1);
+		cdev_del(cc->cdev);
+	}
+
+	/* kill connection and shutdown channel */
+	fuse_conn_kill(&cc->fc);
+	rc = fuse_dev_release(inode, file);	/* puts the base reference */
+
+	return rc;
+}
+
+static struct file_operations cuse_channel_fops; /* initialized during init */
+
+
+/**************************************************************************
+ * Misc stuff and module initializatiion
+ *
+ * CUSE exports the same set of attributes to sysfs as fusectl.
+ */
+
+static ssize_t cuse_class_waiting_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct cuse_conn *cc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", atomic_read(&cc->fc.num_waiting));
+}
+
+static ssize_t cuse_class_abort_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct cuse_conn *cc = dev_get_drvdata(dev);
+
+	fuse_abort_conn(&cc->fc);
+	return count;
+}
+
+static struct device_attribute cuse_class_dev_attrs[] = {
+	__ATTR(waiting, S_IFREG | 0400, cuse_class_waiting_show, NULL),
+	__ATTR(abort, S_IFREG | 0200, NULL, cuse_class_abort_store),
+	{ }
+};
+
+static struct miscdevice cuse_miscdev = {
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "cuse",
+	.fops		= &cuse_channel_fops,
+};
+
+static int __init cuse_init(void)
+{
+	int i, rc;
+
+	/* init conntbl */
+	for (i = 0; i < CUSE_CONNTBL_LEN; i++)
+		INIT_LIST_HEAD(&cuse_conntbl[i]);
+
+	/* inherit and extend fuse_dev_operations */
+	cuse_channel_fops		= fuse_dev_operations;
+	cuse_channel_fops.owner		= THIS_MODULE;
+	cuse_channel_fops.open		= cuse_channel_open;
+	cuse_channel_fops.release	= cuse_channel_release;
+
+	cuse_class = class_create(THIS_MODULE, "cuse");
+	if (IS_ERR(cuse_class))
+		return PTR_ERR(cuse_class);
+
+	cuse_class->dev_attrs = cuse_class_dev_attrs;
+
+	rc = misc_register(&cuse_miscdev);
+	if (rc) {
+		class_destroy(cuse_class);
+		return rc;
+	}
+
+	return 0;
+}
+
+static void __exit cuse_exit(void)
+{
+	misc_deregister(&cuse_miscdev);
+	class_destroy(cuse_class);
+}
+
+module_init(cuse_init);
+module_exit(cuse_exit);
+
+MODULE_AUTHOR("Tejun Heo <tj@kernel.org>");
+MODULE_DESCRIPTION("Character device in Userspace");
+MODULE_LICENSE("GPL");
Index: fuse-2.8.5/kernel/dev.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/dev.c
@@ -0,0 +1,2036 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/uio.h>
+#include <linux/miscdevice.h>
+#include <linux/pagemap.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/pipe_fs_i.h>
+#include <linux/swap.h>
+#include <linux/splice.h>
+
+MODULE_ALIAS_MISCDEV(FUSE_MINOR);
+MODULE_ALIAS("devname:fuse");
+
+static struct kmem_cache *fuse_req_cachep;
+
+static struct fuse_conn *fuse_get_conn(struct file *file)
+{
+	/*
+	 * Lockless access is OK, because file->private data is set
+	 * once during mount and is valid until the file is released.
+	 */
+	return file->private_data;
+}
+
+static void fuse_request_init(struct fuse_req *req)
+{
+	memset(req, 0, sizeof(*req));
+	INIT_LIST_HEAD(&req->list);
+	INIT_LIST_HEAD(&req->intr_entry);
+	init_waitqueue_head(&req->waitq);
+	atomic_set(&req->count, 1);
+}
+
+struct fuse_req *fuse_request_alloc(void)
+{
+	struct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, GFP_KERNEL);
+	if (req)
+		fuse_request_init(req);
+	return req;
+}
+EXPORT_SYMBOL_GPL(fuse_request_alloc);
+
+struct fuse_req *fuse_request_alloc_nofs(void)
+{
+	struct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, GFP_NOFS);
+	if (req)
+		fuse_request_init(req);
+	return req;
+}
+
+void fuse_request_free(struct fuse_req *req)
+{
+	kmem_cache_free(fuse_req_cachep, req);
+}
+
+static void block_sigs(sigset_t *oldset)
+{
+	sigset_t mask;
+
+	siginitsetinv(&mask, sigmask(SIGKILL));
+	sigprocmask(SIG_BLOCK, &mask, oldset);
+}
+
+static void restore_sigs(sigset_t *oldset)
+{
+	sigprocmask(SIG_SETMASK, oldset, NULL);
+}
+
+static void __fuse_get_request(struct fuse_req *req)
+{
+	atomic_inc(&req->count);
+}
+
+/* Must be called with > 1 refcount */
+static void __fuse_put_request(struct fuse_req *req)
+{
+	BUG_ON(atomic_read(&req->count) < 2);
+	atomic_dec(&req->count);
+}
+
+static void fuse_req_init_context(struct fuse_req *req)
+{
+	req->in.h.uid = current_fsuid();
+	req->in.h.gid = current_fsgid();
+	req->in.h.pid = current->pid;
+}
+
+struct fuse_req *fuse_get_req(struct fuse_conn *fc)
+{
+	struct fuse_req *req;
+	sigset_t oldset;
+	int intr;
+	int err;
+
+	atomic_inc(&fc->num_waiting);
+	block_sigs(&oldset);
+	intr = wait_event_interruptible(fc->blocked_waitq, !fc->blocked);
+	restore_sigs(&oldset);
+	err = -EINTR;
+	if (intr)
+		goto out;
+
+	err = -ENOTCONN;
+	if (!fc->connected)
+		goto out;
+
+	req = fuse_request_alloc();
+	err = -ENOMEM;
+	if (!req)
+		goto out;
+
+	fuse_req_init_context(req);
+	req->waiting = 1;
+	return req;
+
+ out:
+	atomic_dec(&fc->num_waiting);
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(fuse_get_req);
+
+/*
+ * Return request in fuse_file->reserved_req.  However that may
+ * currently be in use.  If that is the case, wait for it to become
+ * available.
+ */
+static struct fuse_req *get_reserved_req(struct fuse_conn *fc,
+					 struct file *file)
+{
+	struct fuse_req *req = NULL;
+	struct fuse_file *ff = file->private_data;
+
+	do {
+		wait_event(fc->reserved_req_waitq, ff->reserved_req);
+		spin_lock(&fc->lock);
+		if (ff->reserved_req) {
+			req = ff->reserved_req;
+			ff->reserved_req = NULL;
+			get_file(file);
+			req->stolen_file = file;
+		}
+		spin_unlock(&fc->lock);
+	} while (!req);
+
+	return req;
+}
+
+/*
+ * Put stolen request back into fuse_file->reserved_req
+ */
+static void put_reserved_req(struct fuse_conn *fc, struct fuse_req *req)
+{
+	struct file *file = req->stolen_file;
+	struct fuse_file *ff = file->private_data;
+
+	spin_lock(&fc->lock);
+	fuse_request_init(req);
+	BUG_ON(ff->reserved_req);
+	ff->reserved_req = req;
+	wake_up_all(&fc->reserved_req_waitq);
+	spin_unlock(&fc->lock);
+	fput(file);
+}
+
+/*
+ * Gets a requests for a file operation, always succeeds
+ *
+ * This is used for sending the FLUSH request, which must get to
+ * userspace, due to POSIX locks which may need to be unlocked.
+ *
+ * If allocation fails due to OOM, use the reserved request in
+ * fuse_file.
+ *
+ * This is very unlikely to deadlock accidentally, since the
+ * filesystem should not have it's own file open.  If deadlock is
+ * intentional, it can still be broken by "aborting" the filesystem.
+ */
+struct fuse_req *fuse_get_req_nofail(struct fuse_conn *fc, struct file *file)
+{
+	struct fuse_req *req;
+
+	atomic_inc(&fc->num_waiting);
+	wait_event(fc->blocked_waitq, !fc->blocked);
+	req = fuse_request_alloc();
+	if (!req)
+		req = get_reserved_req(fc, file);
+
+	fuse_req_init_context(req);
+	req->waiting = 1;
+	return req;
+}
+
+void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)
+{
+	if (atomic_dec_and_test(&req->count)) {
+		if (req->waiting)
+			atomic_dec(&fc->num_waiting);
+
+		if (req->stolen_file)
+			put_reserved_req(fc, req);
+		else
+			fuse_request_free(req);
+	}
+}
+EXPORT_SYMBOL_GPL(fuse_put_request);
+
+static unsigned len_args(unsigned numargs, struct fuse_arg *args)
+{
+	unsigned nbytes = 0;
+	unsigned i;
+
+	for (i = 0; i < numargs; i++)
+		nbytes += args[i].size;
+
+	return nbytes;
+}
+
+static u64 fuse_get_unique(struct fuse_conn *fc)
+{
+	fc->reqctr++;
+	/* zero is special */
+	if (fc->reqctr == 0)
+		fc->reqctr = 1;
+
+	return fc->reqctr;
+}
+
+static void queue_request(struct fuse_conn *fc, struct fuse_req *req)
+{
+	req->in.h.len = sizeof(struct fuse_in_header) +
+		len_args(req->in.numargs, (struct fuse_arg *) req->in.args);
+	list_add_tail(&req->list, &fc->pending);
+	req->state = FUSE_REQ_PENDING;
+	if (!req->waiting) {
+		req->waiting = 1;
+		atomic_inc(&fc->num_waiting);
+	}
+	wake_up(&fc->waitq);
+	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
+}
+
+void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,
+		       u64 nodeid, u64 nlookup)
+{
+	forget->forget_one.nodeid = nodeid;
+	forget->forget_one.nlookup = nlookup;
+
+	spin_lock(&fc->lock);
+	fc->forget_list_tail->next = forget;
+	fc->forget_list_tail = forget;
+	wake_up(&fc->waitq);
+	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
+	spin_unlock(&fc->lock);
+}
+
+static void flush_bg_queue(struct fuse_conn *fc)
+{
+	while (fc->active_background < fc->max_background &&
+	       !list_empty(&fc->bg_queue)) {
+		struct fuse_req *req;
+
+		req = list_entry(fc->bg_queue.next, struct fuse_req, list);
+		list_del(&req->list);
+		fc->active_background++;
+		req->in.h.unique = fuse_get_unique(fc);
+		queue_request(fc, req);
+	}
+}
+
+/*
+ * This function is called when a request is finished.  Either a reply
+ * has arrived or it was aborted (and not yet sent) or some error
+ * occurred during communication with userspace, or the device file
+ * was closed.  The requester thread is woken up (if still waiting),
+ * the 'end' callback is called if given, else the reference to the
+ * request is released
+ *
+ * Called with fc->lock, unlocks it
+ */
+static void request_end(struct fuse_conn *fc, struct fuse_req *req)
+__releases(fc->lock)
+{
+	void (*end) (struct fuse_conn *, struct fuse_req *) = req->end;
+	req->end = NULL;
+	list_del(&req->list);
+	list_del(&req->intr_entry);
+	req->state = FUSE_REQ_FINISHED;
+	if (req->background) {
+		if (fc->num_background == fc->max_background) {
+			fc->blocked = 0;
+			wake_up_all(&fc->blocked_waitq);
+		}
+		if (fc->num_background == fc->congestion_threshold &&
+		    fc->connected && fc->bdi_initialized) {
+			clear_bdi_congested(&fc->bdi, BLK_RW_SYNC);
+			clear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);
+		}
+		fc->num_background--;
+		fc->active_background--;
+		flush_bg_queue(fc);
+	}
+	spin_unlock(&fc->lock);
+	wake_up(&req->waitq);
+	if (end)
+		end(fc, req);
+	fuse_put_request(fc, req);
+}
+
+static void wait_answer_interruptible(struct fuse_conn *fc,
+				      struct fuse_req *req)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	if (signal_pending(current))
+		return;
+
+	spin_unlock(&fc->lock);
+	wait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);
+	spin_lock(&fc->lock);
+}
+
+static void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)
+{
+	list_add_tail(&req->intr_entry, &fc->interrupts);
+	wake_up(&fc->waitq);
+	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
+}
+
+static void request_wait_answer(struct fuse_conn *fc, struct fuse_req *req)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	if (!fc->no_interrupt) {
+		/* Any signal may interrupt this */
+		wait_answer_interruptible(fc, req);
+
+		if (req->aborted)
+			goto aborted;
+		if (req->state == FUSE_REQ_FINISHED)
+			return;
+
+		req->interrupted = 1;
+		if (req->state == FUSE_REQ_SENT)
+			queue_interrupt(fc, req);
+	}
+
+	if (!req->force) {
+		sigset_t oldset;
+
+		/* Only fatal signals may interrupt this */
+		block_sigs(&oldset);
+		wait_answer_interruptible(fc, req);
+		restore_sigs(&oldset);
+
+		if (req->aborted)
+			goto aborted;
+		if (req->state == FUSE_REQ_FINISHED)
+			return;
+
+		/* Request is not yet in userspace, bail out */
+		if (req->state == FUSE_REQ_PENDING) {
+			list_del(&req->list);
+			__fuse_put_request(req);
+			req->out.h.error = -EINTR;
+			return;
+		}
+	}
+
+	/*
+	 * Either request is already in userspace, or it was forced.
+	 * Wait it out.
+	 */
+	spin_unlock(&fc->lock);
+	wait_event(req->waitq, req->state == FUSE_REQ_FINISHED);
+	spin_lock(&fc->lock);
+
+	if (!req->aborted)
+		return;
+
+ aborted:
+	BUG_ON(req->state != FUSE_REQ_FINISHED);
+	if (req->locked) {
+		/* This is uninterruptible sleep, because data is
+		   being copied to/from the buffers of req.  During
+		   locked state, there mustn't be any filesystem
+		   operation (e.g. page fault), since that could lead
+		   to deadlock */
+		spin_unlock(&fc->lock);
+		wait_event(req->waitq, !req->locked);
+		spin_lock(&fc->lock);
+	}
+}
+
+void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)
+{
+	req->isreply = 1;
+	spin_lock(&fc->lock);
+	if (!fc->connected)
+		req->out.h.error = -ENOTCONN;
+	else if (fc->conn_error)
+		req->out.h.error = -ECONNREFUSED;
+	else {
+		req->in.h.unique = fuse_get_unique(fc);
+		queue_request(fc, req);
+		/* acquire extra reference, since request is still needed
+		   after request_end() */
+		__fuse_get_request(req);
+
+		request_wait_answer(fc, req);
+	}
+	spin_unlock(&fc->lock);
+}
+EXPORT_SYMBOL_GPL(fuse_request_send);
+
+static void fuse_request_send_nowait_locked(struct fuse_conn *fc,
+					    struct fuse_req *req)
+{
+	req->background = 1;
+	fc->num_background++;
+	if (fc->num_background == fc->max_background)
+		fc->blocked = 1;
+	if (fc->num_background == fc->congestion_threshold &&
+	    fc->bdi_initialized) {
+		set_bdi_congested(&fc->bdi, BLK_RW_SYNC);
+		set_bdi_congested(&fc->bdi, BLK_RW_ASYNC);
+	}
+	list_add_tail(&req->list, &fc->bg_queue);
+	flush_bg_queue(fc);
+}
+
+static void fuse_request_send_nowait(struct fuse_conn *fc, struct fuse_req *req)
+{
+	spin_lock(&fc->lock);
+	if (fc->connected) {
+		fuse_request_send_nowait_locked(fc, req);
+		spin_unlock(&fc->lock);
+	} else {
+		req->out.h.error = -ENOTCONN;
+		request_end(fc, req);
+	}
+}
+
+void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req)
+{
+	req->isreply = 1;
+	fuse_request_send_nowait(fc, req);
+}
+EXPORT_SYMBOL_GPL(fuse_request_send_background);
+
+static int fuse_request_send_notify_reply(struct fuse_conn *fc,
+					  struct fuse_req *req, u64 unique)
+{
+	int err = -ENODEV;
+
+	req->isreply = 0;
+	req->in.h.unique = unique;
+	spin_lock(&fc->lock);
+	if (fc->connected) {
+		queue_request(fc, req);
+		err = 0;
+	}
+	spin_unlock(&fc->lock);
+
+	return err;
+}
+
+/*
+ * Called under fc->lock
+ *
+ * fc->connected must have been checked previously
+ */
+void fuse_request_send_background_locked(struct fuse_conn *fc,
+					 struct fuse_req *req)
+{
+	req->isreply = 1;
+	fuse_request_send_nowait_locked(fc, req);
+}
+
+/*
+ * Lock the request.  Up to the next unlock_request() there mustn't be
+ * anything that could cause a page-fault.  If the request was already
+ * aborted bail out.
+ */
+static int lock_request(struct fuse_conn *fc, struct fuse_req *req)
+{
+	int err = 0;
+	if (req) {
+		spin_lock(&fc->lock);
+		if (req->aborted)
+			err = -ENOENT;
+		else
+			req->locked = 1;
+		spin_unlock(&fc->lock);
+	}
+	return err;
+}
+
+/*
+ * Unlock request.  If it was aborted during being locked, the
+ * requester thread is currently waiting for it to be unlocked, so
+ * wake it up.
+ */
+static void unlock_request(struct fuse_conn *fc, struct fuse_req *req)
+{
+	if (req) {
+		spin_lock(&fc->lock);
+		req->locked = 0;
+		if (req->aborted)
+			wake_up(&req->waitq);
+		spin_unlock(&fc->lock);
+	}
+}
+
+struct fuse_copy_state {
+	struct fuse_conn *fc;
+	int write;
+	struct fuse_req *req;
+	const struct iovec *iov;
+	struct pipe_buffer *pipebufs;
+	struct pipe_buffer *currbuf;
+	struct pipe_inode_info *pipe;
+	unsigned long nr_segs;
+	unsigned long seglen;
+	unsigned long addr;
+	struct page *pg;
+	void *mapaddr;
+	void *buf;
+	unsigned len;
+	unsigned move_pages:1;
+};
+
+static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,
+			   int write,
+			   const struct iovec *iov, unsigned long nr_segs)
+{
+	memset(cs, 0, sizeof(*cs));
+	cs->fc = fc;
+	cs->write = write;
+	cs->iov = iov;
+	cs->nr_segs = nr_segs;
+}
+
+/* Unmap and put previous page of userspace buffer */
+static void fuse_copy_finish(struct fuse_copy_state *cs)
+{
+	if (cs->currbuf) {
+		struct pipe_buffer *buf = cs->currbuf;
+
+		if (!cs->write) {
+			buf->ops->unmap(cs->pipe, buf, cs->mapaddr);
+		} else {
+			kunmap(buf->page);
+			buf->len = PAGE_SIZE - cs->len;
+		}
+		cs->currbuf = NULL;
+		cs->mapaddr = NULL;
+	} else if (cs->mapaddr) {
+		kunmap(cs->pg);
+		if (cs->write) {
+			flush_dcache_page(cs->pg);
+			set_page_dirty_lock(cs->pg);
+		}
+		put_page(cs->pg);
+		cs->mapaddr = NULL;
+	}
+}
+
+/*
+ * Get another pagefull of userspace buffer, and map it to kernel
+ * address space, and lock request
+ */
+static int fuse_copy_fill(struct fuse_copy_state *cs)
+{
+	unsigned long offset;
+	int err;
+
+	unlock_request(cs->fc, cs->req);
+	fuse_copy_finish(cs);
+	if (cs->pipebufs) {
+		struct pipe_buffer *buf = cs->pipebufs;
+
+		if (!cs->write) {
+			err = buf->ops->confirm(cs->pipe, buf);
+			if (err)
+				return err;
+
+			BUG_ON(!cs->nr_segs);
+			cs->currbuf = buf;
+			cs->mapaddr = buf->ops->map(cs->pipe, buf, 0);
+			cs->len = buf->len;
+			cs->buf = cs->mapaddr + buf->offset;
+			cs->pipebufs++;
+			cs->nr_segs--;
+		} else {
+			struct page *page;
+
+			if (cs->nr_segs == cs->pipe->buffers)
+				return -EIO;
+
+			page = alloc_page(GFP_HIGHUSER);
+			if (!page)
+				return -ENOMEM;
+
+			buf->page = page;
+			buf->offset = 0;
+			buf->len = 0;
+
+			cs->currbuf = buf;
+			cs->mapaddr = kmap(page);
+			cs->buf = cs->mapaddr;
+			cs->len = PAGE_SIZE;
+			cs->pipebufs++;
+			cs->nr_segs++;
+		}
+	} else {
+		if (!cs->seglen) {
+			BUG_ON(!cs->nr_segs);
+			cs->seglen = cs->iov[0].iov_len;
+			cs->addr = (unsigned long) cs->iov[0].iov_base;
+			cs->iov++;
+			cs->nr_segs--;
+		}
+		err = get_user_pages_fast(cs->addr, 1, cs->write, &cs->pg);
+		if (err < 0)
+			return err;
+		BUG_ON(err != 1);
+		offset = cs->addr % PAGE_SIZE;
+		cs->mapaddr = kmap(cs->pg);
+		cs->buf = cs->mapaddr + offset;
+		cs->len = min(PAGE_SIZE - offset, cs->seglen);
+		cs->seglen -= cs->len;
+		cs->addr += cs->len;
+	}
+
+	return lock_request(cs->fc, cs->req);
+}
+
+/* Do as much copy to/from userspace buffer as we can */
+static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)
+{
+	unsigned ncpy = min(*size, cs->len);
+	if (val) {
+		if (cs->write)
+			memcpy(cs->buf, *val, ncpy);
+		else
+			memcpy(*val, cs->buf, ncpy);
+		*val += ncpy;
+	}
+	*size -= ncpy;
+	cs->len -= ncpy;
+	cs->buf += ncpy;
+	return ncpy;
+}
+
+static int fuse_check_page(struct page *page)
+{
+	if (page_mapcount(page) ||
+	    page->mapping != NULL ||
+	    page_count(page) != 1 ||
+	    (page->flags & PAGE_FLAGS_CHECK_AT_PREP &
+	     ~(1 << PG_locked |
+	       1 << PG_referenced |
+	       1 << PG_uptodate |
+	       1 << PG_lru |
+	       1 << PG_active |
+	       1 << PG_reclaim))) {
+		printk(KERN_WARNING "fuse: trying to steal weird page\n");
+		printk(KERN_WARNING "  page=%p index=%li flags=%08lx, count=%i, mapcount=%i, mapping=%p\n", page, page->index, page->flags, page_count(page), page_mapcount(page), page->mapping);
+		return 1;
+	}
+	return 0;
+}
+
+static int fuse_try_move_page(struct fuse_copy_state *cs, struct page **pagep)
+{
+	int err;
+	struct page *oldpage = *pagep;
+	struct page *newpage;
+	struct pipe_buffer *buf = cs->pipebufs;
+	struct address_space *mapping;
+	pgoff_t index;
+
+	unlock_request(cs->fc, cs->req);
+	fuse_copy_finish(cs);
+
+	err = buf->ops->confirm(cs->pipe, buf);
+	if (err)
+		return err;
+
+	BUG_ON(!cs->nr_segs);
+	cs->currbuf = buf;
+	cs->len = buf->len;
+	cs->pipebufs++;
+	cs->nr_segs--;
+
+	if (cs->len != PAGE_SIZE)
+		goto out_fallback;
+
+	if (buf->ops->steal(cs->pipe, buf) != 0)
+		goto out_fallback;
+
+	newpage = buf->page;
+
+	if (WARN_ON(!PageUptodate(newpage)))
+		return -EIO;
+
+	ClearPageMappedToDisk(newpage);
+
+	if (fuse_check_page(newpage) != 0)
+		goto out_fallback_unlock;
+
+	mapping = oldpage->mapping;
+	index = oldpage->index;
+
+	/*
+	 * This is a new and locked page, it shouldn't be mapped or
+	 * have any special flags on it
+	 */
+	if (WARN_ON(page_mapped(oldpage)))
+		goto out_fallback_unlock;
+	if (WARN_ON(page_has_private(oldpage)))
+		goto out_fallback_unlock;
+	if (WARN_ON(PageDirty(oldpage) || PageWriteback(oldpage)))
+		goto out_fallback_unlock;
+	if (WARN_ON(PageMlocked(oldpage)))
+		goto out_fallback_unlock;
+
+	err = replace_page_cache_page(oldpage, newpage, GFP_KERNEL);
+	if (err) {
+		unlock_page(newpage);
+		return err;
+	}
+
+	page_cache_get(newpage);
+
+	if (!(buf->flags & PIPE_BUF_FLAG_LRU))
+		lru_cache_add_file(newpage);
+
+	err = 0;
+	spin_lock(&cs->fc->lock);
+	if (cs->req->aborted)
+		err = -ENOENT;
+	else
+		*pagep = newpage;
+	spin_unlock(&cs->fc->lock);
+
+	if (err) {
+		unlock_page(newpage);
+		page_cache_release(newpage);
+		return err;
+	}
+
+	unlock_page(oldpage);
+	page_cache_release(oldpage);
+	cs->len = 0;
+
+	return 0;
+
+out_fallback_unlock:
+	unlock_page(newpage);
+out_fallback:
+	cs->mapaddr = buf->ops->map(cs->pipe, buf, 1);
+	cs->buf = cs->mapaddr + buf->offset;
+
+	err = lock_request(cs->fc, cs->req);
+	if (err)
+		return err;
+
+	return 1;
+}
+
+static int fuse_ref_page(struct fuse_copy_state *cs, struct page *page,
+			 unsigned offset, unsigned count)
+{
+	struct pipe_buffer *buf;
+
+	if (cs->nr_segs == cs->pipe->buffers)
+		return -EIO;
+
+	unlock_request(cs->fc, cs->req);
+	fuse_copy_finish(cs);
+
+	buf = cs->pipebufs;
+	page_cache_get(page);
+	buf->page = page;
+	buf->offset = offset;
+	buf->len = count;
+
+	cs->pipebufs++;
+	cs->nr_segs++;
+	cs->len = 0;
+
+	return 0;
+}
+
+/*
+ * Copy a page in the request to/from the userspace buffer.  Must be
+ * done atomically
+ */
+static int fuse_copy_page(struct fuse_copy_state *cs, struct page **pagep,
+			  unsigned offset, unsigned count, int zeroing)
+{
+	int err;
+	struct page *page = *pagep;
+
+	if (page && zeroing && count < PAGE_SIZE)
+		clear_highpage(page);
+
+	while (count) {
+		if (cs->write && cs->pipebufs && page) {
+			return fuse_ref_page(cs, page, offset, count);
+		} else if (!cs->len) {
+			if (cs->move_pages && page &&
+			    offset == 0 && count == PAGE_SIZE) {
+				err = fuse_try_move_page(cs, pagep);
+				if (err <= 0)
+					return err;
+			} else {
+				err = fuse_copy_fill(cs);
+				if (err)
+					return err;
+			}
+		}
+		if (page) {
+			void *mapaddr = kmap_atomic(page, KM_USER0);
+			void *buf = mapaddr + offset;
+			offset += fuse_copy_do(cs, &buf, &count);
+			kunmap_atomic(mapaddr, KM_USER0);
+		} else
+			offset += fuse_copy_do(cs, NULL, &count);
+	}
+	if (page && !cs->write)
+		flush_dcache_page(page);
+	return 0;
+}
+
+/* Copy pages in the request to/from userspace buffer */
+static int fuse_copy_pages(struct fuse_copy_state *cs, unsigned nbytes,
+			   int zeroing)
+{
+	unsigned i;
+	struct fuse_req *req = cs->req;
+	unsigned offset = req->page_offset;
+	unsigned count = min(nbytes, (unsigned) PAGE_SIZE - offset);
+
+	for (i = 0; i < req->num_pages && (nbytes || zeroing); i++) {
+		int err;
+
+		err = fuse_copy_page(cs, &req->pages[i], offset, count,
+				     zeroing);
+		if (err)
+			return err;
+
+		nbytes -= count;
+		count = min(nbytes, (unsigned) PAGE_SIZE);
+		offset = 0;
+	}
+	return 0;
+}
+
+/* Copy a single argument in the request to/from userspace buffer */
+static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size)
+{
+	while (size) {
+		if (!cs->len) {
+			int err = fuse_copy_fill(cs);
+			if (err)
+				return err;
+		}
+		fuse_copy_do(cs, &val, &size);
+	}
+	return 0;
+}
+
+/* Copy request arguments to/from userspace buffer */
+static int fuse_copy_args(struct fuse_copy_state *cs, unsigned numargs,
+			  unsigned argpages, struct fuse_arg *args,
+			  int zeroing)
+{
+	int err = 0;
+	unsigned i;
+
+	for (i = 0; !err && i < numargs; i++)  {
+		struct fuse_arg *arg = &args[i];
+		if (i == numargs - 1 && argpages)
+			err = fuse_copy_pages(cs, arg->size, zeroing);
+		else
+			err = fuse_copy_one(cs, arg->value, arg->size);
+	}
+	return err;
+}
+
+static int forget_pending(struct fuse_conn *fc)
+{
+	return fc->forget_list_head.next != NULL;
+}
+
+static int request_pending(struct fuse_conn *fc)
+{
+	return !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||
+		forget_pending(fc);
+}
+
+/* Wait until a request is available on the pending list */
+static void request_wait(struct fuse_conn *fc)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	add_wait_queue_exclusive(&fc->waitq, &wait);
+	while (fc->connected && !request_pending(fc)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (signal_pending(current))
+			break;
+
+		spin_unlock(&fc->lock);
+		schedule();
+		spin_lock(&fc->lock);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&fc->waitq, &wait);
+}
+
+/*
+ * Transfer an interrupt request to userspace
+ *
+ * Unlike other requests this is assembled on demand, without a need
+ * to allocate a separate fuse_req structure.
+ *
+ * Called with fc->lock held, releases it
+ */
+static int fuse_read_interrupt(struct fuse_conn *fc, struct fuse_copy_state *cs,
+			       size_t nbytes, struct fuse_req *req)
+__releases(fc->lock)
+{
+	struct fuse_in_header ih;
+	struct fuse_interrupt_in arg;
+	unsigned reqsize = sizeof(ih) + sizeof(arg);
+	int err;
+
+	list_del_init(&req->intr_entry);
+	req->intr_unique = fuse_get_unique(fc);
+	memset(&ih, 0, sizeof(ih));
+	memset(&arg, 0, sizeof(arg));
+	ih.len = reqsize;
+	ih.opcode = FUSE_INTERRUPT;
+	ih.unique = req->intr_unique;
+	arg.unique = req->in.h.unique;
+
+	spin_unlock(&fc->lock);
+	if (nbytes < reqsize)
+		return -EINVAL;
+
+	err = fuse_copy_one(cs, &ih, sizeof(ih));
+	if (!err)
+		err = fuse_copy_one(cs, &arg, sizeof(arg));
+	fuse_copy_finish(cs);
+
+	return err ? err : reqsize;
+}
+
+static struct fuse_forget_link *dequeue_forget(struct fuse_conn *fc,
+					       unsigned max,
+					       unsigned *countp)
+{
+	struct fuse_forget_link *head = fc->forget_list_head.next;
+	struct fuse_forget_link **newhead = &head;
+	unsigned count;
+
+	for (count = 0; *newhead != NULL && count < max; count++)
+		newhead = &(*newhead)->next;
+
+	fc->forget_list_head.next = *newhead;
+	*newhead = NULL;
+	if (fc->forget_list_head.next == NULL)
+		fc->forget_list_tail = &fc->forget_list_head;
+
+	if (countp != NULL)
+		*countp = count;
+
+	return head;
+}
+
+static int fuse_read_single_forget(struct fuse_conn *fc,
+				   struct fuse_copy_state *cs,
+				   size_t nbytes)
+__releases(fc->lock)
+{
+	int err;
+	struct fuse_forget_link *forget = dequeue_forget(fc, 1, NULL);
+	struct fuse_forget_in arg = {
+		.nlookup = forget->forget_one.nlookup,
+	};
+	struct fuse_in_header ih = {
+		.opcode = FUSE_FORGET,
+		.nodeid = forget->forget_one.nodeid,
+		.unique = fuse_get_unique(fc),
+		.len = sizeof(ih) + sizeof(arg),
+	};
+
+	spin_unlock(&fc->lock);
+	kfree(forget);
+	if (nbytes < ih.len)
+		return -EINVAL;
+
+	err = fuse_copy_one(cs, &ih, sizeof(ih));
+	if (!err)
+		err = fuse_copy_one(cs, &arg, sizeof(arg));
+	fuse_copy_finish(cs);
+
+	if (err)
+		return err;
+
+	return ih.len;
+}
+
+static int fuse_read_batch_forget(struct fuse_conn *fc,
+				   struct fuse_copy_state *cs, size_t nbytes)
+__releases(fc->lock)
+{
+	int err;
+	unsigned max_forgets;
+	unsigned count;
+	struct fuse_forget_link *head;
+	struct fuse_batch_forget_in arg = { .count = 0 };
+	struct fuse_in_header ih = {
+		.opcode = FUSE_BATCH_FORGET,
+		.unique = fuse_get_unique(fc),
+		.len = sizeof(ih) + sizeof(arg),
+	};
+
+	if (nbytes < ih.len) {
+		spin_unlock(&fc->lock);
+		return -EINVAL;
+	}
+
+	max_forgets = (nbytes - ih.len) / sizeof(struct fuse_forget_one);
+	head = dequeue_forget(fc, max_forgets, &count);
+	spin_unlock(&fc->lock);
+
+	arg.count = count;
+	ih.len += count * sizeof(struct fuse_forget_one);
+	err = fuse_copy_one(cs, &ih, sizeof(ih));
+	if (!err)
+		err = fuse_copy_one(cs, &arg, sizeof(arg));
+
+	while (head) {
+		struct fuse_forget_link *forget = head;
+
+		if (!err) {
+			err = fuse_copy_one(cs, &forget->forget_one,
+					    sizeof(forget->forget_one));
+		}
+		head = forget->next;
+		kfree(forget);
+	}
+
+	fuse_copy_finish(cs);
+
+	if (err)
+		return err;
+
+	return ih.len;
+}
+
+static int fuse_read_forget(struct fuse_conn *fc, struct fuse_copy_state *cs,
+			    size_t nbytes)
+__releases(fc->lock)
+{
+	if (fc->minor < 16 || fc->forget_list_head.next->next == NULL)
+		return fuse_read_single_forget(fc, cs, nbytes);
+	else
+		return fuse_read_batch_forget(fc, cs, nbytes);
+}
+
+/*
+ * Read a single request into the userspace filesystem's buffer.  This
+ * function waits until a request is available, then removes it from
+ * the pending list and copies request data to userspace buffer.  If
+ * no reply is needed (FORGET) or request has been aborted or there
+ * was an error during the copying then it's finished by calling
+ * request_end().  Otherwise add it to the processing list, and set
+ * the 'sent' flag.
+ */
+static ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,
+				struct fuse_copy_state *cs, size_t nbytes)
+{
+	int err;
+	struct fuse_req *req;
+	struct fuse_in *in;
+	unsigned reqsize;
+
+ restart:
+	spin_lock(&fc->lock);
+	err = -EAGAIN;
+	if ((file->f_flags & O_NONBLOCK) && fc->connected &&
+	    !request_pending(fc))
+		goto err_unlock;
+
+	request_wait(fc);
+	err = -ENODEV;
+	if (!fc->connected)
+		goto err_unlock;
+	err = -ERESTARTSYS;
+	if (!request_pending(fc))
+		goto err_unlock;
+
+	if (!list_empty(&fc->interrupts)) {
+		req = list_entry(fc->interrupts.next, struct fuse_req,
+				 intr_entry);
+		return fuse_read_interrupt(fc, cs, nbytes, req);
+	}
+
+	if (forget_pending(fc)) {
+		if (list_empty(&fc->pending) || fc->forget_batch-- > 0)
+			return fuse_read_forget(fc, cs, nbytes);
+
+		if (fc->forget_batch <= -8)
+			fc->forget_batch = 16;
+	}
+
+	req = list_entry(fc->pending.next, struct fuse_req, list);
+	req->state = FUSE_REQ_READING;
+	list_move(&req->list, &fc->io);
+
+	in = &req->in;
+	reqsize = in->h.len;
+	/* If request is too large, reply with an error and restart the read */
+	if (nbytes < reqsize) {
+		req->out.h.error = -EIO;
+		/* SETXATTR is special, since it may contain too large data */
+		if (in->h.opcode == FUSE_SETXATTR)
+			req->out.h.error = -E2BIG;
+		request_end(fc, req);
+		goto restart;
+	}
+	spin_unlock(&fc->lock);
+	cs->req = req;
+	err = fuse_copy_one(cs, &in->h, sizeof(in->h));
+	if (!err)
+		err = fuse_copy_args(cs, in->numargs, in->argpages,
+				     (struct fuse_arg *) in->args, 0);
+	fuse_copy_finish(cs);
+	spin_lock(&fc->lock);
+	req->locked = 0;
+	if (req->aborted) {
+		request_end(fc, req);
+		return -ENODEV;
+	}
+	if (err) {
+		req->out.h.error = -EIO;
+		request_end(fc, req);
+		return err;
+	}
+	if (!req->isreply)
+		request_end(fc, req);
+	else {
+		req->state = FUSE_REQ_SENT;
+		list_move_tail(&req->list, &fc->processing);
+		if (req->interrupted)
+			queue_interrupt(fc, req);
+		spin_unlock(&fc->lock);
+	}
+	return reqsize;
+
+ err_unlock:
+	spin_unlock(&fc->lock);
+	return err;
+}
+
+static ssize_t fuse_dev_read(struct kiocb *iocb, const struct iovec *iov,
+			      unsigned long nr_segs, loff_t pos)
+{
+	struct fuse_copy_state cs;
+	struct file *file = iocb->ki_filp;
+	struct fuse_conn *fc = fuse_get_conn(file);
+	if (!fc)
+		return -EPERM;
+
+	fuse_copy_init(&cs, fc, 1, iov, nr_segs);
+
+	return fuse_dev_do_read(fc, file, &cs, iov_length(iov, nr_segs));
+}
+
+static int fuse_dev_pipe_buf_steal(struct pipe_inode_info *pipe,
+				   struct pipe_buffer *buf)
+{
+	return 1;
+}
+
+static const struct pipe_buf_operations fuse_dev_pipe_buf_ops = {
+	.can_merge = 0,
+	.map = generic_pipe_buf_map,
+	.unmap = generic_pipe_buf_unmap,
+	.confirm = generic_pipe_buf_confirm,
+	.release = generic_pipe_buf_release,
+	.steal = fuse_dev_pipe_buf_steal,
+	.get = generic_pipe_buf_get,
+};
+
+static ssize_t fuse_dev_splice_read(struct file *in, loff_t *ppos,
+				    struct pipe_inode_info *pipe,
+				    size_t len, unsigned int flags)
+{
+	int ret;
+	int page_nr = 0;
+	int do_wakeup = 0;
+	struct pipe_buffer *bufs;
+	struct fuse_copy_state cs;
+	struct fuse_conn *fc = fuse_get_conn(in);
+	if (!fc)
+		return -EPERM;
+
+	bufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);
+	if (!bufs)
+		return -ENOMEM;
+
+	fuse_copy_init(&cs, fc, 1, NULL, 0);
+	cs.pipebufs = bufs;
+	cs.pipe = pipe;
+	ret = fuse_dev_do_read(fc, in, &cs, len);
+	if (ret < 0)
+		goto out;
+
+	ret = 0;
+	pipe_lock(pipe);
+
+	if (!pipe->readers) {
+		send_sig(SIGPIPE, current, 0);
+		if (!ret)
+			ret = -EPIPE;
+		goto out_unlock;
+	}
+
+	if (pipe->nrbufs + cs.nr_segs > pipe->buffers) {
+		ret = -EIO;
+		goto out_unlock;
+	}
+
+	while (page_nr < cs.nr_segs) {
+		int newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
+		struct pipe_buffer *buf = pipe->bufs + newbuf;
+
+		buf->page = bufs[page_nr].page;
+		buf->offset = bufs[page_nr].offset;
+		buf->len = bufs[page_nr].len;
+		buf->ops = &fuse_dev_pipe_buf_ops;
+
+		pipe->nrbufs++;
+		page_nr++;
+		ret += buf->len;
+
+		if (pipe->inode)
+			do_wakeup = 1;
+	}
+
+out_unlock:
+	pipe_unlock(pipe);
+
+	if (do_wakeup) {
+		smp_mb();
+		if (waitqueue_active(&pipe->wait))
+			wake_up_interruptible(&pipe->wait);
+		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
+	}
+
+out:
+	for (; page_nr < cs.nr_segs; page_nr++)
+		page_cache_release(bufs[page_nr].page);
+
+	kfree(bufs);
+	return ret;
+}
+
+static int fuse_notify_poll(struct fuse_conn *fc, unsigned int size,
+			    struct fuse_copy_state *cs)
+{
+	struct fuse_notify_poll_wakeup_out outarg;
+	int err = -EINVAL;
+
+	if (size != sizeof(outarg))
+		goto err;
+
+	err = fuse_copy_one(cs, &outarg, sizeof(outarg));
+	if (err)
+		goto err;
+
+	fuse_copy_finish(cs);
+	return fuse_notify_poll_wakeup(fc, &outarg);
+
+err:
+	fuse_copy_finish(cs);
+	return err;
+}
+
+static int fuse_notify_inval_inode(struct fuse_conn *fc, unsigned int size,
+				   struct fuse_copy_state *cs)
+{
+	struct fuse_notify_inval_inode_out outarg;
+	int err = -EINVAL;
+
+	if (size != sizeof(outarg))
+		goto err;
+
+	err = fuse_copy_one(cs, &outarg, sizeof(outarg));
+	if (err)
+		goto err;
+	fuse_copy_finish(cs);
+
+	down_read(&fc->killsb);
+	err = -ENOENT;
+	if (fc->sb) {
+		err = fuse_reverse_inval_inode(fc->sb, outarg.ino,
+					       outarg.off, outarg.len);
+	}
+	up_read(&fc->killsb);
+	return err;
+
+err:
+	fuse_copy_finish(cs);
+	return err;
+}
+
+static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,
+				   struct fuse_copy_state *cs)
+{
+	struct fuse_notify_inval_entry_out outarg;
+	int err = -ENOMEM;
+	char *buf;
+	struct qstr name;
+
+	buf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);
+	if (!buf)
+		goto err;
+
+	err = -EINVAL;
+	if (size < sizeof(outarg))
+		goto err;
+
+	err = fuse_copy_one(cs, &outarg, sizeof(outarg));
+	if (err)
+		goto err;
+
+	err = -ENAMETOOLONG;
+	if (outarg.namelen > FUSE_NAME_MAX)
+		goto err;
+
+	name.name = buf;
+	name.len = outarg.namelen;
+	err = fuse_copy_one(cs, buf, outarg.namelen + 1);
+	if (err)
+		goto err;
+	fuse_copy_finish(cs);
+	buf[outarg.namelen] = 0;
+	name.hash = full_name_hash(name.name, name.len);
+
+	down_read(&fc->killsb);
+	err = -ENOENT;
+	if (fc->sb)
+		err = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);
+	up_read(&fc->killsb);
+	kfree(buf);
+	return err;
+
+err:
+	kfree(buf);
+	fuse_copy_finish(cs);
+	return err;
+}
+
+static int fuse_notify_store(struct fuse_conn *fc, unsigned int size,
+			     struct fuse_copy_state *cs)
+{
+	struct fuse_notify_store_out outarg;
+	struct inode *inode;
+	struct address_space *mapping;
+	u64 nodeid;
+	int err;
+	pgoff_t index;
+	unsigned int offset;
+	unsigned int num;
+	loff_t file_size;
+	loff_t end;
+
+	err = -EINVAL;
+	if (size < sizeof(outarg))
+		goto out_finish;
+
+	err = fuse_copy_one(cs, &outarg, sizeof(outarg));
+	if (err)
+		goto out_finish;
+
+	err = -EINVAL;
+	if (size - sizeof(outarg) != outarg.size)
+		goto out_finish;
+
+	nodeid = outarg.nodeid;
+
+	down_read(&fc->killsb);
+
+	err = -ENOENT;
+	if (!fc->sb)
+		goto out_up_killsb;
+
+	inode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);
+	if (!inode)
+		goto out_up_killsb;
+
+	mapping = inode->i_mapping;
+	index = outarg.offset >> PAGE_CACHE_SHIFT;
+	offset = outarg.offset & ~PAGE_CACHE_MASK;
+	file_size = i_size_read(inode);
+	end = outarg.offset + outarg.size;
+	if (end > file_size) {
+		file_size = end;
+		fuse_write_update_size(inode, file_size);
+	}
+
+	num = outarg.size;
+	while (num) {
+		struct page *page;
+		unsigned int this_num;
+
+		err = -ENOMEM;
+		page = find_or_create_page(mapping, index,
+					   mapping_gfp_mask(mapping));
+		if (!page)
+			goto out_iput;
+
+		this_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);
+		err = fuse_copy_page(cs, &page, offset, this_num, 0);
+		if (!err && offset == 0 && (num != 0 || file_size == end))
+			SetPageUptodate(page);
+		unlock_page(page);
+		page_cache_release(page);
+
+		if (err)
+			goto out_iput;
+
+		num -= this_num;
+		offset = 0;
+		index++;
+	}
+
+	err = 0;
+
+out_iput:
+	iput(inode);
+out_up_killsb:
+	up_read(&fc->killsb);
+out_finish:
+	fuse_copy_finish(cs);
+	return err;
+}
+
+static void fuse_retrieve_end(struct fuse_conn *fc, struct fuse_req *req)
+{
+	release_pages(req->pages, req->num_pages, 0);
+}
+
+static int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,
+			 struct fuse_notify_retrieve_out *outarg)
+{
+	int err;
+	struct address_space *mapping = inode->i_mapping;
+	struct fuse_req *req;
+	pgoff_t index;
+	loff_t file_size;
+	unsigned int num;
+	unsigned int offset;
+	size_t total_len = 0;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	offset = outarg->offset & ~PAGE_CACHE_MASK;
+
+	req->in.h.opcode = FUSE_NOTIFY_REPLY;
+	req->in.h.nodeid = outarg->nodeid;
+	req->in.numargs = 2;
+	req->in.argpages = 1;
+	req->page_offset = offset;
+	req->end = fuse_retrieve_end;
+
+	index = outarg->offset >> PAGE_CACHE_SHIFT;
+	file_size = i_size_read(inode);
+	num = outarg->size;
+	if (outarg->offset > file_size)
+		num = 0;
+	else if (outarg->offset + num > file_size)
+		num = file_size - outarg->offset;
+
+	while (num) {
+		struct page *page;
+		unsigned int this_num;
+
+		page = find_get_page(mapping, index);
+		if (!page)
+			break;
+
+		this_num = min_t(unsigned, num, PAGE_CACHE_SIZE - offset);
+		req->pages[req->num_pages] = page;
+		req->num_pages++;
+
+		num -= this_num;
+		total_len += this_num;
+	}
+	req->misc.retrieve_in.offset = outarg->offset;
+	req->misc.retrieve_in.size = total_len;
+	req->in.args[0].size = sizeof(req->misc.retrieve_in);
+	req->in.args[0].value = &req->misc.retrieve_in;
+	req->in.args[1].size = total_len;
+
+	err = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);
+	if (err)
+		fuse_retrieve_end(fc, req);
+
+	return err;
+}
+
+static int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,
+				struct fuse_copy_state *cs)
+{
+	struct fuse_notify_retrieve_out outarg;
+	struct inode *inode;
+	int err;
+
+	err = -EINVAL;
+	if (size != sizeof(outarg))
+		goto copy_finish;
+
+	err = fuse_copy_one(cs, &outarg, sizeof(outarg));
+	if (err)
+		goto copy_finish;
+
+	fuse_copy_finish(cs);
+
+	down_read(&fc->killsb);
+	err = -ENOENT;
+	if (fc->sb) {
+		u64 nodeid = outarg.nodeid;
+
+		inode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);
+		if (inode) {
+			err = fuse_retrieve(fc, inode, &outarg);
+			iput(inode);
+		}
+	}
+	up_read(&fc->killsb);
+
+	return err;
+
+copy_finish:
+	fuse_copy_finish(cs);
+	return err;
+}
+
+static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,
+		       unsigned int size, struct fuse_copy_state *cs)
+{
+	switch (code) {
+	case FUSE_NOTIFY_POLL:
+		return fuse_notify_poll(fc, size, cs);
+
+	case FUSE_NOTIFY_INVAL_INODE:
+		return fuse_notify_inval_inode(fc, size, cs);
+
+	case FUSE_NOTIFY_INVAL_ENTRY:
+		return fuse_notify_inval_entry(fc, size, cs);
+
+	case FUSE_NOTIFY_STORE:
+		return fuse_notify_store(fc, size, cs);
+
+	case FUSE_NOTIFY_RETRIEVE:
+		return fuse_notify_retrieve(fc, size, cs);
+
+	default:
+		fuse_copy_finish(cs);
+		return -EINVAL;
+	}
+}
+
+/* Look up request on processing list by unique ID */
+static struct fuse_req *request_find(struct fuse_conn *fc, u64 unique)
+{
+	struct list_head *entry;
+
+	list_for_each(entry, &fc->processing) {
+		struct fuse_req *req;
+		req = list_entry(entry, struct fuse_req, list);
+		if (req->in.h.unique == unique || req->intr_unique == unique)
+			return req;
+	}
+	return NULL;
+}
+
+static int copy_out_args(struct fuse_copy_state *cs, struct fuse_out *out,
+			 unsigned nbytes)
+{
+	unsigned reqsize = sizeof(struct fuse_out_header);
+
+	if (out->h.error)
+		return nbytes != reqsize ? -EINVAL : 0;
+
+	reqsize += len_args(out->numargs, out->args);
+
+	if (reqsize < nbytes || (reqsize > nbytes && !out->argvar))
+		return -EINVAL;
+	else if (reqsize > nbytes) {
+		struct fuse_arg *lastarg = &out->args[out->numargs-1];
+		unsigned diffsize = reqsize - nbytes;
+		if (diffsize > lastarg->size)
+			return -EINVAL;
+		lastarg->size -= diffsize;
+	}
+	return fuse_copy_args(cs, out->numargs, out->argpages, out->args,
+			      out->page_zeroing);
+}
+
+/*
+ * Write a single reply to a request.  First the header is copied from
+ * the write buffer.  The request is then searched on the processing
+ * list by the unique ID found in the header.  If found, then remove
+ * it from the list and copy the rest of the buffer to the request.
+ * The request is finished by calling request_end()
+ */
+static ssize_t fuse_dev_do_write(struct fuse_conn *fc,
+				 struct fuse_copy_state *cs, size_t nbytes)
+{
+	int err;
+	struct fuse_req *req;
+	struct fuse_out_header oh;
+
+	if (nbytes < sizeof(struct fuse_out_header))
+		return -EINVAL;
+
+	err = fuse_copy_one(cs, &oh, sizeof(oh));
+	if (err)
+		goto err_finish;
+
+	err = -EINVAL;
+	if (oh.len != nbytes)
+		goto err_finish;
+
+	/*
+	 * Zero oh.unique indicates unsolicited notification message
+	 * and error contains notification code.
+	 */
+	if (!oh.unique) {
+		err = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);
+		return err ? err : nbytes;
+	}
+
+	err = -EINVAL;
+	if (oh.error <= -1000 || oh.error > 0)
+		goto err_finish;
+
+	spin_lock(&fc->lock);
+	err = -ENOENT;
+	if (!fc->connected)
+		goto err_unlock;
+
+	req = request_find(fc, oh.unique);
+	if (!req)
+		goto err_unlock;
+
+	if (req->aborted) {
+		spin_unlock(&fc->lock);
+		fuse_copy_finish(cs);
+		spin_lock(&fc->lock);
+		request_end(fc, req);
+		return -ENOENT;
+	}
+	/* Is it an interrupt reply? */
+	if (req->intr_unique == oh.unique) {
+		err = -EINVAL;
+		if (nbytes != sizeof(struct fuse_out_header))
+			goto err_unlock;
+
+		if (oh.error == -ENOSYS)
+			fc->no_interrupt = 1;
+		else if (oh.error == -EAGAIN)
+			queue_interrupt(fc, req);
+
+		spin_unlock(&fc->lock);
+		fuse_copy_finish(cs);
+		return nbytes;
+	}
+
+	req->state = FUSE_REQ_WRITING;
+	list_move(&req->list, &fc->io);
+	req->out.h = oh;
+	req->locked = 1;
+	cs->req = req;
+	if (!req->out.page_replace)
+		cs->move_pages = 0;
+	spin_unlock(&fc->lock);
+
+	err = copy_out_args(cs, &req->out, nbytes);
+	fuse_copy_finish(cs);
+
+	spin_lock(&fc->lock);
+	req->locked = 0;
+	if (!err) {
+		if (req->aborted)
+			err = -ENOENT;
+	} else if (!req->aborted)
+		req->out.h.error = -EIO;
+	request_end(fc, req);
+
+	return err ? err : nbytes;
+
+ err_unlock:
+	spin_unlock(&fc->lock);
+ err_finish:
+	fuse_copy_finish(cs);
+	return err;
+}
+
+static ssize_t fuse_dev_write(struct kiocb *iocb, const struct iovec *iov,
+			      unsigned long nr_segs, loff_t pos)
+{
+	struct fuse_copy_state cs;
+	struct fuse_conn *fc = fuse_get_conn(iocb->ki_filp);
+	if (!fc)
+		return -EPERM;
+
+	fuse_copy_init(&cs, fc, 0, iov, nr_segs);
+
+	return fuse_dev_do_write(fc, &cs, iov_length(iov, nr_segs));
+}
+
+static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,
+				     struct file *out, loff_t *ppos,
+				     size_t len, unsigned int flags)
+{
+	unsigned nbuf;
+	unsigned idx;
+	struct pipe_buffer *bufs;
+	struct fuse_copy_state cs;
+	struct fuse_conn *fc;
+	size_t rem;
+	ssize_t ret;
+
+	fc = fuse_get_conn(out);
+	if (!fc)
+		return -EPERM;
+
+	bufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);
+	if (!bufs)
+		return -ENOMEM;
+
+	pipe_lock(pipe);
+	nbuf = 0;
+	rem = 0;
+	for (idx = 0; idx < pipe->nrbufs && rem < len; idx++)
+		rem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;
+
+	ret = -EINVAL;
+	if (rem < len) {
+		pipe_unlock(pipe);
+		goto out;
+	}
+
+	rem = len;
+	while (rem) {
+		struct pipe_buffer *ibuf;
+		struct pipe_buffer *obuf;
+
+		BUG_ON(nbuf >= pipe->buffers);
+		BUG_ON(!pipe->nrbufs);
+		ibuf = &pipe->bufs[pipe->curbuf];
+		obuf = &bufs[nbuf];
+
+		if (rem >= ibuf->len) {
+			*obuf = *ibuf;
+			ibuf->ops = NULL;
+			pipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);
+			pipe->nrbufs--;
+		} else {
+			ibuf->ops->get(pipe, ibuf);
+			*obuf = *ibuf;
+			obuf->flags &= ~PIPE_BUF_FLAG_GIFT;
+			obuf->len = rem;
+			ibuf->offset += obuf->len;
+			ibuf->len -= obuf->len;
+		}
+		nbuf++;
+		rem -= obuf->len;
+	}
+	pipe_unlock(pipe);
+
+	fuse_copy_init(&cs, fc, 0, NULL, nbuf);
+	cs.pipebufs = bufs;
+	cs.pipe = pipe;
+
+	if (flags & SPLICE_F_MOVE)
+		cs.move_pages = 1;
+
+	ret = fuse_dev_do_write(fc, &cs, len);
+
+	for (idx = 0; idx < nbuf; idx++) {
+		struct pipe_buffer *buf = &bufs[idx];
+		buf->ops->release(pipe, buf);
+	}
+out:
+	kfree(bufs);
+	return ret;
+}
+
+static unsigned fuse_dev_poll(struct file *file, poll_table *wait)
+{
+	unsigned mask = POLLOUT | POLLWRNORM;
+	struct fuse_conn *fc = fuse_get_conn(file);
+	if (!fc)
+		return POLLERR;
+
+	poll_wait(file, &fc->waitq, wait);
+
+	spin_lock(&fc->lock);
+	if (!fc->connected)
+		mask = POLLERR;
+	else if (request_pending(fc))
+		mask |= POLLIN | POLLRDNORM;
+	spin_unlock(&fc->lock);
+
+	return mask;
+}
+
+/*
+ * Abort all requests on the given list (pending or processing)
+ *
+ * This function releases and reacquires fc->lock
+ */
+static void end_requests(struct fuse_conn *fc, struct list_head *head)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	while (!list_empty(head)) {
+		struct fuse_req *req;
+		req = list_entry(head->next, struct fuse_req, list);
+		req->out.h.error = -ECONNABORTED;
+		request_end(fc, req);
+		spin_lock(&fc->lock);
+	}
+}
+
+/*
+ * Abort requests under I/O
+ *
+ * The requests are set to aborted and finished, and the request
+ * waiter is woken up.  This will make request_wait_answer() wait
+ * until the request is unlocked and then return.
+ *
+ * If the request is asynchronous, then the end function needs to be
+ * called after waiting for the request to be unlocked (if it was
+ * locked).
+ */
+static void end_io_requests(struct fuse_conn *fc)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	while (!list_empty(&fc->io)) {
+		struct fuse_req *req =
+			list_entry(fc->io.next, struct fuse_req, list);
+		void (*end) (struct fuse_conn *, struct fuse_req *) = req->end;
+
+		req->aborted = 1;
+		req->out.h.error = -ECONNABORTED;
+		req->state = FUSE_REQ_FINISHED;
+		list_del_init(&req->list);
+		wake_up(&req->waitq);
+		if (end) {
+			req->end = NULL;
+			__fuse_get_request(req);
+			spin_unlock(&fc->lock);
+			wait_event(req->waitq, !req->locked);
+			end(fc, req);
+			fuse_put_request(fc, req);
+			spin_lock(&fc->lock);
+		}
+	}
+}
+
+static void end_queued_requests(struct fuse_conn *fc)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	fc->max_background = UINT_MAX;
+	flush_bg_queue(fc);
+	end_requests(fc, &fc->pending);
+	end_requests(fc, &fc->processing);
+	while (forget_pending(fc))
+		kfree(dequeue_forget(fc, 1, NULL));
+}
+
+static void end_polls(struct fuse_conn *fc)
+{
+	struct rb_node *p;
+
+	p = rb_first(&fc->polled_files);
+
+	while (p) {
+		struct fuse_file *ff;
+		ff = rb_entry(p, struct fuse_file, polled_node);
+		wake_up_interruptible_all(&ff->poll_wait);
+
+		p = rb_next(p);
+	}
+}
+
+/*
+ * Abort all requests.
+ *
+ * Emergency exit in case of a malicious or accidental deadlock, or
+ * just a hung filesystem.
+ *
+ * The same effect is usually achievable through killing the
+ * filesystem daemon and all users of the filesystem.  The exception
+ * is the combination of an asynchronous request and the tricky
+ * deadlock (see Documentation/filesystems/fuse.txt).
+ *
+ * During the aborting, progression of requests from the pending and
+ * processing lists onto the io list, and progression of new requests
+ * onto the pending list is prevented by req->connected being false.
+ *
+ * Progression of requests under I/O to the processing list is
+ * prevented by the req->aborted flag being true for these requests.
+ * For this reason requests on the io list must be aborted first.
+ */
+void fuse_abort_conn(struct fuse_conn *fc)
+{
+	spin_lock(&fc->lock);
+	if (fc->connected) {
+		fc->connected = 0;
+		fc->blocked = 0;
+		end_io_requests(fc);
+		end_queued_requests(fc);
+		end_polls(fc);
+		wake_up_all(&fc->waitq);
+		wake_up_all(&fc->blocked_waitq);
+		kill_fasync(&fc->fasync, SIGIO, POLL_IN);
+	}
+	spin_unlock(&fc->lock);
+}
+EXPORT_SYMBOL_GPL(fuse_abort_conn);
+
+int fuse_dev_release(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = fuse_get_conn(file);
+	if (fc) {
+		spin_lock(&fc->lock);
+		fc->connected = 0;
+		fc->blocked = 0;
+		end_queued_requests(fc);
+		end_polls(fc);
+		wake_up_all(&fc->blocked_waitq);
+		spin_unlock(&fc->lock);
+		fuse_conn_put(fc);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fuse_dev_release);
+
+static int fuse_dev_fasync(int fd, struct file *file, int on)
+{
+	struct fuse_conn *fc = fuse_get_conn(file);
+	if (!fc)
+		return -EPERM;
+
+	/* No locking - fasync_helper does its own locking */
+	return fasync_helper(fd, file, on, &fc->fasync);
+}
+
+const struct file_operations fuse_dev_operations = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= do_sync_read,
+	.aio_read	= fuse_dev_read,
+	.splice_read	= fuse_dev_splice_read,
+	.write		= do_sync_write,
+	.aio_write	= fuse_dev_write,
+	.splice_write	= fuse_dev_splice_write,
+	.poll		= fuse_dev_poll,
+	.release	= fuse_dev_release,
+	.fasync		= fuse_dev_fasync,
+};
+EXPORT_SYMBOL_GPL(fuse_dev_operations);
+
+static struct miscdevice fuse_miscdevice = {
+	.minor = FUSE_MINOR,
+	.name  = "fuse",
+	.fops = &fuse_dev_operations,
+};
+
+int __init fuse_dev_init(void)
+{
+	int err = -ENOMEM;
+	fuse_req_cachep = kmem_cache_create("fuse_request",
+					    sizeof(struct fuse_req),
+					    0, 0, NULL);
+	if (!fuse_req_cachep)
+		goto out;
+
+	err = misc_register(&fuse_miscdevice);
+	if (err)
+		goto out_cache_clean;
+
+	return 0;
+
+ out_cache_clean:
+	kmem_cache_destroy(fuse_req_cachep);
+ out:
+	return err;
+}
+
+void fuse_dev_cleanup(void)
+{
+	misc_deregister(&fuse_miscdevice);
+	kmem_cache_destroy(fuse_req_cachep);
+}
Index: fuse-2.8.5/kernel/dir.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/dir.c
@@ -0,0 +1,1636 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/file.h>
+#include <linux/sched.h>
+#include <linux/namei.h>
+#include <linux/slab.h>
+
+#if BITS_PER_LONG >= 64
+static inline void fuse_dentry_settime(struct dentry *entry, u64 time)
+{
+	entry->d_time = time;
+}
+
+static inline u64 fuse_dentry_time(struct dentry *entry)
+{
+	return entry->d_time;
+}
+#else
+/*
+ * On 32 bit archs store the high 32 bits of time in d_fsdata
+ */
+static void fuse_dentry_settime(struct dentry *entry, u64 time)
+{
+	entry->d_time = time;
+	entry->d_fsdata = (void *) (unsigned long) (time >> 32);
+}
+
+static u64 fuse_dentry_time(struct dentry *entry)
+{
+	return (u64) entry->d_time +
+		((u64) (unsigned long) entry->d_fsdata << 32);
+}
+#endif
+
+/*
+ * FUSE caches dentries and attributes with separate timeout.  The
+ * time in jiffies until the dentry/attributes are valid is stored in
+ * dentry->d_time and fuse_inode->i_time respectively.
+ */
+
+/*
+ * Calculate the time in jiffies until a dentry/attributes are valid
+ */
+static u64 time_to_jiffies(unsigned long sec, unsigned long nsec)
+{
+	if (sec || nsec) {
+		struct timespec ts = {sec, nsec};
+		return get_jiffies_64() + timespec_to_jiffies(&ts);
+	} else
+		return 0;
+}
+
+/*
+ * Set dentry and possibly attribute timeouts from the lookup/mk*
+ * replies
+ */
+static void fuse_change_entry_timeout(struct dentry *entry,
+				      struct fuse_entry_out *o)
+{
+	fuse_dentry_settime(entry,
+		time_to_jiffies(o->entry_valid, o->entry_valid_nsec));
+}
+
+static u64 attr_timeout(struct fuse_attr_out *o)
+{
+	return time_to_jiffies(o->attr_valid, o->attr_valid_nsec);
+}
+
+static u64 entry_attr_timeout(struct fuse_entry_out *o)
+{
+	return time_to_jiffies(o->attr_valid, o->attr_valid_nsec);
+}
+
+/*
+ * Mark the attributes as stale, so that at the next call to
+ * ->getattr() they will be fetched from userspace
+ */
+void fuse_invalidate_attr(struct inode *inode)
+{
+	get_fuse_inode(inode)->i_time = 0;
+}
+
+/*
+ * Just mark the entry as stale, so that a next attempt to look it up
+ * will result in a new lookup call to userspace
+ *
+ * This is called when a dentry is about to become negative and the
+ * timeout is unknown (unlink, rmdir, rename and in some cases
+ * lookup)
+ */
+void fuse_invalidate_entry_cache(struct dentry *entry)
+{
+	fuse_dentry_settime(entry, 0);
+}
+
+/*
+ * Same as fuse_invalidate_entry_cache(), but also try to remove the
+ * dentry from the hash
+ */
+static void fuse_invalidate_entry(struct dentry *entry)
+{
+	d_invalidate(entry);
+	fuse_invalidate_entry_cache(entry);
+}
+
+static void fuse_lookup_init(struct fuse_conn *fc, struct fuse_req *req,
+			     u64 nodeid, struct qstr *name,
+			     struct fuse_entry_out *outarg)
+{
+	memset(outarg, 0, sizeof(struct fuse_entry_out));
+	req->in.h.opcode = FUSE_LOOKUP;
+	req->in.h.nodeid = nodeid;
+	req->in.numargs = 1;
+	req->in.args[0].size = name->len + 1;
+	req->in.args[0].value = name->name;
+	req->out.numargs = 1;
+	if (fc->minor < 9)
+		req->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;
+	else
+		req->out.args[0].size = sizeof(struct fuse_entry_out);
+	req->out.args[0].value = outarg;
+}
+
+u64 fuse_get_attr_version(struct fuse_conn *fc)
+{
+	u64 curr_version;
+
+	/*
+	 * The spin lock isn't actually needed on 64bit archs, but we
+	 * don't yet care too much about such optimizations.
+	 */
+	spin_lock(&fc->lock);
+	curr_version = fc->attr_version;
+	spin_unlock(&fc->lock);
+
+	return curr_version;
+}
+
+/*
+ * Check whether the dentry is still valid
+ *
+ * If the entry validity timeout has expired and the dentry is
+ * positive, try to redo the lookup.  If the lookup results in a
+ * different inode, then let the VFS invalidate the dentry and redo
+ * the lookup once more.  If the lookup results in the same inode,
+ * then refresh the attributes, timeouts and mark the dentry valid.
+ */
+static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata *nd)
+{
+	struct inode *inode;
+
+	inode = ACCESS_ONCE(entry->d_inode);
+	if (inode && is_bad_inode(inode))
+		return 0;
+	else if (fuse_dentry_time(entry) < get_jiffies_64()) {
+		int err;
+		struct fuse_entry_out outarg;
+		struct fuse_conn *fc;
+		struct fuse_req *req;
+		struct fuse_forget_link *forget;
+		struct dentry *parent;
+		u64 attr_version;
+
+		/* For negative dentries, always do a fresh lookup */
+		if (!inode)
+			return 0;
+
+		if (nd->flags & LOOKUP_RCU)
+			return -ECHILD;
+
+		fc = get_fuse_conn(inode);
+		req = fuse_get_req(fc);
+		if (IS_ERR(req))
+			return 0;
+
+		forget = fuse_alloc_forget();
+		if (!forget) {
+			fuse_put_request(fc, req);
+			return 0;
+		}
+
+		attr_version = fuse_get_attr_version(fc);
+
+		parent = dget_parent(entry);
+		fuse_lookup_init(fc, req, get_node_id(parent->d_inode),
+				 &entry->d_name, &outarg);
+		fuse_request_send(fc, req);
+		dput(parent);
+		err = req->out.h.error;
+		fuse_put_request(fc, req);
+		/* Zero nodeid is same as -ENOENT */
+		if (!err && !outarg.nodeid)
+			err = -ENOENT;
+		if (!err) {
+			struct fuse_inode *fi = get_fuse_inode(inode);
+			if (outarg.nodeid != get_node_id(inode)) {
+				fuse_queue_forget(fc, forget, outarg.nodeid, 1);
+				return 0;
+			}
+			spin_lock(&fc->lock);
+			fi->nlookup++;
+			spin_unlock(&fc->lock);
+		}
+		kfree(forget);
+		if (err || (outarg.attr.mode ^ inode->i_mode) & S_IFMT)
+			return 0;
+
+		fuse_change_attributes(inode, &outarg.attr,
+				       entry_attr_timeout(&outarg),
+				       attr_version);
+		fuse_change_entry_timeout(entry, &outarg);
+	}
+	return 1;
+}
+
+static int invalid_nodeid(u64 nodeid)
+{
+	return !nodeid || nodeid == FUSE_ROOT_ID;
+}
+
+const struct dentry_operations fuse_dentry_operations = {
+	.d_revalidate	= fuse_dentry_revalidate,
+};
+
+int fuse_valid_type(int m)
+{
+	return S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||
+		S_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);
+}
+
+/*
+ * Add a directory inode to a dentry, ensuring that no other dentry
+ * refers to this inode.  Called with fc->inst_mutex.
+ */
+static struct dentry *fuse_d_add_directory(struct dentry *entry,
+					   struct inode *inode)
+{
+	struct dentry *alias = d_find_alias(inode);
+	if (alias && !(alias->d_flags & DCACHE_DISCONNECTED)) {
+		/* This tries to shrink the subtree below alias */
+		fuse_invalidate_entry(alias);
+		dput(alias);
+		if (!list_empty(&inode->i_dentry))
+			return ERR_PTR(-EBUSY);
+	} else {
+		dput(alias);
+	}
+	return d_splice_alias(inode, entry);
+}
+
+int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,
+		     struct fuse_entry_out *outarg, struct inode **inode)
+{
+	struct fuse_conn *fc = get_fuse_conn_super(sb);
+	struct fuse_req *req;
+	struct fuse_forget_link *forget;
+	u64 attr_version;
+	int err;
+
+	*inode = NULL;
+	err = -ENAMETOOLONG;
+	if (name->len > FUSE_NAME_MAX)
+		goto out;
+
+	req = fuse_get_req(fc);
+	err = PTR_ERR(req);
+	if (IS_ERR(req))
+		goto out;
+
+	forget = fuse_alloc_forget();
+	err = -ENOMEM;
+	if (!forget) {
+		fuse_put_request(fc, req);
+		goto out;
+	}
+
+	attr_version = fuse_get_attr_version(fc);
+
+	fuse_lookup_init(fc, req, nodeid, name, outarg);
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	/* Zero nodeid is same as -ENOENT, but with valid timeout */
+	if (err || !outarg->nodeid)
+		goto out_put_forget;
+
+	err = -EIO;
+	if (!outarg->nodeid)
+		goto out_put_forget;
+	if (!fuse_valid_type(outarg->attr.mode))
+		goto out_put_forget;
+
+	*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,
+			   &outarg->attr, entry_attr_timeout(outarg),
+			   attr_version);
+	err = -ENOMEM;
+	if (!*inode) {
+		fuse_queue_forget(fc, forget, outarg->nodeid, 1);
+		goto out;
+	}
+	err = 0;
+
+ out_put_forget:
+	kfree(forget);
+ out:
+	return err;
+}
+
+static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,
+				  struct nameidata *nd)
+{
+	int err;
+	struct fuse_entry_out outarg;
+	struct inode *inode;
+	struct dentry *newent;
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	bool outarg_valid = true;
+
+	err = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,
+			       &outarg, &inode);
+	if (err == -ENOENT) {
+		outarg_valid = false;
+		err = 0;
+	}
+	if (err)
+		goto out_err;
+
+	err = -EIO;
+	if (inode && get_node_id(inode) == FUSE_ROOT_ID)
+		goto out_iput;
+
+	if (inode && S_ISDIR(inode->i_mode)) {
+		mutex_lock(&fc->inst_mutex);
+		newent = fuse_d_add_directory(entry, inode);
+		mutex_unlock(&fc->inst_mutex);
+		err = PTR_ERR(newent);
+		if (IS_ERR(newent))
+			goto out_iput;
+	} else {
+		newent = d_splice_alias(inode, entry);
+	}
+
+	entry = newent ? newent : entry;
+	if (outarg_valid)
+		fuse_change_entry_timeout(entry, &outarg);
+	else
+		fuse_invalidate_entry_cache(entry);
+
+	return newent;
+
+ out_iput:
+	iput(inode);
+ out_err:
+	return ERR_PTR(err);
+}
+
+/*
+ * Atomic create+open operation
+ *
+ * If the filesystem doesn't support this, then fall back to separate
+ * 'mknod' + 'open' requests.
+ */
+static int fuse_create_open(struct inode *dir, struct dentry *entry, int mode,
+			    struct nameidata *nd)
+{
+	int err;
+	struct inode *inode;
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	struct fuse_req *req;
+	struct fuse_forget_link *forget;
+	struct fuse_create_in inarg;
+	struct fuse_open_out outopen;
+	struct fuse_entry_out outentry;
+	struct fuse_file *ff;
+	struct file *file;
+	int flags = nd->intent.open.flags - 1;
+
+	if (fc->no_create)
+		return -ENOSYS;
+
+	if (flags & O_DIRECT)
+		return -EINVAL;
+
+	forget = fuse_alloc_forget();
+	if (!forget)
+		return -ENOMEM;
+
+	req = fuse_get_req(fc);
+	err = PTR_ERR(req);
+	if (IS_ERR(req))
+		goto out_put_forget_req;
+
+	err = -ENOMEM;
+	ff = fuse_file_alloc(fc);
+	if (!ff)
+		goto out_put_request;
+
+	if (!fc->dont_mask)
+		mode &= ~current_umask();
+
+	flags &= ~O_NOCTTY;
+	memset(&inarg, 0, sizeof(inarg));
+	memset(&outentry, 0, sizeof(outentry));
+	inarg.flags = flags;
+	inarg.mode = mode;
+	inarg.umask = current_umask();
+	req->in.h.opcode = FUSE_CREATE;
+	req->in.h.nodeid = get_node_id(dir);
+	req->in.numargs = 2;
+	req->in.args[0].size = fc->minor < 12 ? sizeof(struct fuse_open_in) :
+						sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->in.args[1].size = entry->d_name.len + 1;
+	req->in.args[1].value = entry->d_name.name;
+	req->out.numargs = 2;
+	if (fc->minor < 9)
+		req->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;
+	else
+		req->out.args[0].size = sizeof(outentry);
+	req->out.args[0].value = &outentry;
+	req->out.args[1].size = sizeof(outopen);
+	req->out.args[1].value = &outopen;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	if (err) {
+		if (err == -ENOSYS)
+			fc->no_create = 1;
+		goto out_free_ff;
+	}
+
+	err = -EIO;
+	if (!S_ISREG(outentry.attr.mode) || invalid_nodeid(outentry.nodeid))
+		goto out_free_ff;
+
+	fuse_put_request(fc, req);
+	ff->fh = outopen.fh;
+	ff->nodeid = outentry.nodeid;
+	ff->open_flags = outopen.open_flags;
+	inode = fuse_iget(dir->i_sb, outentry.nodeid, outentry.generation,
+			  &outentry.attr, entry_attr_timeout(&outentry), 0);
+	if (!inode) {
+		flags &= ~(O_CREAT | O_EXCL | O_TRUNC);
+		fuse_sync_release(ff, flags);
+		fuse_queue_forget(fc, forget, outentry.nodeid, 1);
+		return -ENOMEM;
+	}
+	kfree(forget);
+	d_instantiate(entry, inode);
+	fuse_change_entry_timeout(entry, &outentry);
+	fuse_invalidate_attr(dir);
+	file = lookup_instantiate_filp(nd, entry, generic_file_open);
+	if (IS_ERR(file)) {
+		fuse_sync_release(ff, flags);
+		return PTR_ERR(file);
+	}
+	file->private_data = fuse_file_get(ff);
+	fuse_finish_open(inode, file);
+	return 0;
+
+ out_free_ff:
+	fuse_file_free(ff);
+ out_put_request:
+	fuse_put_request(fc, req);
+ out_put_forget_req:
+	kfree(forget);
+	return err;
+}
+
+/*
+ * Code shared between mknod, mkdir, symlink and link
+ */
+static int create_new_entry(struct fuse_conn *fc, struct fuse_req *req,
+			    struct inode *dir, struct dentry *entry,
+			    int mode)
+{
+	struct fuse_entry_out outarg;
+	struct inode *inode;
+	int err;
+	struct fuse_forget_link *forget;
+
+	forget = fuse_alloc_forget();
+	if (!forget) {
+		fuse_put_request(fc, req);
+		return -ENOMEM;
+	}
+
+	memset(&outarg, 0, sizeof(outarg));
+	req->in.h.nodeid = get_node_id(dir);
+	req->out.numargs = 1;
+	if (fc->minor < 9)
+		req->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;
+	else
+		req->out.args[0].size = sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err)
+		goto out_put_forget_req;
+
+	err = -EIO;
+	if (invalid_nodeid(outarg.nodeid))
+		goto out_put_forget_req;
+
+	if ((outarg.attr.mode ^ mode) & S_IFMT)
+		goto out_put_forget_req;
+
+	inode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,
+			  &outarg.attr, entry_attr_timeout(&outarg), 0);
+	if (!inode) {
+		fuse_queue_forget(fc, forget, outarg.nodeid, 1);
+		return -ENOMEM;
+	}
+	kfree(forget);
+
+	if (S_ISDIR(inode->i_mode)) {
+		struct dentry *alias;
+		mutex_lock(&fc->inst_mutex);
+		alias = d_find_alias(inode);
+		if (alias) {
+			/* New directory must have moved since mkdir */
+			mutex_unlock(&fc->inst_mutex);
+			dput(alias);
+			iput(inode);
+			return -EBUSY;
+		}
+		d_instantiate(entry, inode);
+		mutex_unlock(&fc->inst_mutex);
+	} else
+		d_instantiate(entry, inode);
+
+	fuse_change_entry_timeout(entry, &outarg);
+	fuse_invalidate_attr(dir);
+	return 0;
+
+ out_put_forget_req:
+	kfree(forget);
+	return err;
+}
+
+static int fuse_mknod(struct inode *dir, struct dentry *entry, int mode,
+		      dev_t rdev)
+{
+	struct fuse_mknod_in inarg;
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	if (!fc->dont_mask)
+		mode &= ~current_umask();
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.mode = mode;
+	inarg.rdev = new_encode_dev(rdev);
+	inarg.umask = current_umask();
+	req->in.h.opcode = FUSE_MKNOD;
+	req->in.numargs = 2;
+	req->in.args[0].size = fc->minor < 12 ? FUSE_COMPAT_MKNOD_IN_SIZE :
+						sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->in.args[1].size = entry->d_name.len + 1;
+	req->in.args[1].value = entry->d_name.name;
+	return create_new_entry(fc, req, dir, entry, mode);
+}
+
+static int fuse_create(struct inode *dir, struct dentry *entry, int mode,
+		       struct nameidata *nd)
+{
+	if (nd && (nd->flags & LOOKUP_OPEN)) {
+		int err = fuse_create_open(dir, entry, mode, nd);
+		if (err != -ENOSYS)
+			return err;
+		/* Fall back on mknod */
+	}
+	return fuse_mknod(dir, entry, mode, 0);
+}
+
+static int fuse_mkdir(struct inode *dir, struct dentry *entry, int mode)
+{
+	struct fuse_mkdir_in inarg;
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	if (!fc->dont_mask)
+		mode &= ~current_umask();
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.mode = mode;
+	inarg.umask = current_umask();
+	req->in.h.opcode = FUSE_MKDIR;
+	req->in.numargs = 2;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->in.args[1].size = entry->d_name.len + 1;
+	req->in.args[1].value = entry->d_name.name;
+	return create_new_entry(fc, req, dir, entry, S_IFDIR);
+}
+
+static int fuse_symlink(struct inode *dir, struct dentry *entry,
+			const char *link)
+{
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	unsigned len = strlen(link) + 1;
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	req->in.h.opcode = FUSE_SYMLINK;
+	req->in.numargs = 2;
+	req->in.args[0].size = entry->d_name.len + 1;
+	req->in.args[0].value = entry->d_name.name;
+	req->in.args[1].size = len;
+	req->in.args[1].value = link;
+	return create_new_entry(fc, req, dir, entry, S_IFLNK);
+}
+
+static int fuse_unlink(struct inode *dir, struct dentry *entry)
+{
+	int err;
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	req->in.h.opcode = FUSE_UNLINK;
+	req->in.h.nodeid = get_node_id(dir);
+	req->in.numargs = 1;
+	req->in.args[0].size = entry->d_name.len + 1;
+	req->in.args[0].value = entry->d_name.name;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (!err) {
+		struct inode *inode = entry->d_inode;
+
+		/*
+		 * Set nlink to zero so the inode can be cleared, if the inode
+		 * does have more links this will be discovered at the next
+		 * lookup/getattr.
+		 */
+		clear_nlink(inode);
+		fuse_invalidate_attr(inode);
+		fuse_invalidate_attr(dir);
+		fuse_invalidate_entry_cache(entry);
+	} else if (err == -EINTR)
+		fuse_invalidate_entry(entry);
+	return err;
+}
+
+static int fuse_rmdir(struct inode *dir, struct dentry *entry)
+{
+	int err;
+	struct fuse_conn *fc = get_fuse_conn(dir);
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	req->in.h.opcode = FUSE_RMDIR;
+	req->in.h.nodeid = get_node_id(dir);
+	req->in.numargs = 1;
+	req->in.args[0].size = entry->d_name.len + 1;
+	req->in.args[0].value = entry->d_name.name;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (!err) {
+		clear_nlink(entry->d_inode);
+		fuse_invalidate_attr(dir);
+		fuse_invalidate_entry_cache(entry);
+	} else if (err == -EINTR)
+		fuse_invalidate_entry(entry);
+	return err;
+}
+
+static int fuse_rename(struct inode *olddir, struct dentry *oldent,
+		       struct inode *newdir, struct dentry *newent)
+{
+	int err;
+	struct fuse_rename_in inarg;
+	struct fuse_conn *fc = get_fuse_conn(olddir);
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.newdir = get_node_id(newdir);
+	req->in.h.opcode = FUSE_RENAME;
+	req->in.h.nodeid = get_node_id(olddir);
+	req->in.numargs = 3;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->in.args[1].size = oldent->d_name.len + 1;
+	req->in.args[1].value = oldent->d_name.name;
+	req->in.args[2].size = newent->d_name.len + 1;
+	req->in.args[2].value = newent->d_name.name;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (!err) {
+		/* ctime changes */
+		fuse_invalidate_attr(oldent->d_inode);
+
+		fuse_invalidate_attr(olddir);
+		if (olddir != newdir)
+			fuse_invalidate_attr(newdir);
+
+		/* newent will end up negative */
+		if (newent->d_inode) {
+			fuse_invalidate_attr(newent->d_inode);
+			fuse_invalidate_entry_cache(newent);
+		}
+	} else if (err == -EINTR) {
+		/* If request was interrupted, DEITY only knows if the
+		   rename actually took place.  If the invalidation
+		   fails (e.g. some process has CWD under the renamed
+		   directory), then there can be inconsistency between
+		   the dcache and the real filesystem.  Tough luck. */
+		fuse_invalidate_entry(oldent);
+		if (newent->d_inode)
+			fuse_invalidate_entry(newent);
+	}
+
+	return err;
+}
+
+static int fuse_link(struct dentry *entry, struct inode *newdir,
+		     struct dentry *newent)
+{
+	int err;
+	struct fuse_link_in inarg;
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.oldnodeid = get_node_id(inode);
+	req->in.h.opcode = FUSE_LINK;
+	req->in.numargs = 2;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->in.args[1].size = newent->d_name.len + 1;
+	req->in.args[1].value = newent->d_name.name;
+	err = create_new_entry(fc, req, newdir, newent, inode->i_mode);
+	/* Contrary to "normal" filesystems it can happen that link
+	   makes two "logical" inodes point to the same "physical"
+	   inode.  We invalidate the attributes of the old one, so it
+	   will reflect changes in the backing inode (link count,
+	   etc.)
+	*/
+	if (!err || err == -EINTR)
+		fuse_invalidate_attr(inode);
+	return err;
+}
+
+static void fuse_fillattr(struct inode *inode, struct fuse_attr *attr,
+			  struct kstat *stat)
+{
+	stat->dev = inode->i_sb->s_dev;
+	stat->ino = attr->ino;
+	stat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);
+	stat->nlink = attr->nlink;
+	stat->uid = attr->uid;
+	stat->gid = attr->gid;
+	stat->rdev = inode->i_rdev;
+	stat->atime.tv_sec = attr->atime;
+	stat->atime.tv_nsec = attr->atimensec;
+	stat->mtime.tv_sec = attr->mtime;
+	stat->mtime.tv_nsec = attr->mtimensec;
+	stat->ctime.tv_sec = attr->ctime;
+	stat->ctime.tv_nsec = attr->ctimensec;
+	stat->size = attr->size;
+	stat->blocks = attr->blocks;
+	stat->blksize = (1 << inode->i_blkbits);
+}
+
+static int fuse_do_getattr(struct inode *inode, struct kstat *stat,
+			   struct file *file)
+{
+	int err;
+	struct fuse_getattr_in inarg;
+	struct fuse_attr_out outarg;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	u64 attr_version;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	attr_version = fuse_get_attr_version(fc);
+
+	memset(&inarg, 0, sizeof(inarg));
+	memset(&outarg, 0, sizeof(outarg));
+	/* Directories have separate file-handle space */
+	if (file && S_ISREG(inode->i_mode)) {
+		struct fuse_file *ff = file->private_data;
+
+		inarg.getattr_flags |= FUSE_GETATTR_FH;
+		inarg.fh = ff->fh;
+	}
+	req->in.h.opcode = FUSE_GETATTR;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->out.numargs = 1;
+	if (fc->minor < 9)
+		req->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;
+	else
+		req->out.args[0].size = sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (!err) {
+		if ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
+			make_bad_inode(inode);
+			err = -EIO;
+		} else {
+			fuse_change_attributes(inode, &outarg.attr,
+					       attr_timeout(&outarg),
+					       attr_version);
+			if (stat)
+				fuse_fillattr(inode, &outarg.attr, stat);
+		}
+	}
+	return err;
+}
+
+int fuse_update_attributes(struct inode *inode, struct kstat *stat,
+			   struct file *file, bool *refreshed)
+{
+	struct fuse_inode *fi = get_fuse_inode(inode);
+	int err;
+	bool r;
+
+	if (fi->i_time < get_jiffies_64()) {
+		r = true;
+		err = fuse_do_getattr(inode, stat, file);
+	} else {
+		r = false;
+		err = 0;
+		if (stat) {
+			generic_fillattr(inode, stat);
+			stat->mode = fi->orig_i_mode;
+		}
+	}
+
+	if (refreshed != NULL)
+		*refreshed = r;
+
+	return err;
+}
+
+int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
+			     struct qstr *name)
+{
+	int err = -ENOTDIR;
+	struct inode *parent;
+	struct dentry *dir;
+	struct dentry *entry;
+
+	parent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);
+	if (!parent)
+		return -ENOENT;
+
+	mutex_lock(&parent->i_mutex);
+	if (!S_ISDIR(parent->i_mode))
+		goto unlock;
+
+	err = -ENOENT;
+	dir = d_find_alias(parent);
+	if (!dir)
+		goto unlock;
+
+	entry = d_lookup(dir, name);
+	dput(dir);
+	if (!entry)
+		goto unlock;
+
+	fuse_invalidate_attr(parent);
+	fuse_invalidate_entry(entry);
+	dput(entry);
+	err = 0;
+
+ unlock:
+	mutex_unlock(&parent->i_mutex);
+	iput(parent);
+	return err;
+}
+
+/*
+ * Calling into a user-controlled filesystem gives the filesystem
+ * daemon ptrace-like capabilities over the requester process.  This
+ * means, that the filesystem daemon is able to record the exact
+ * filesystem operations performed, and can also control the behavior
+ * of the requester process in otherwise impossible ways.  For example
+ * it can delay the operation for arbitrary length of time allowing
+ * DoS against the requester.
+ *
+ * For this reason only those processes can call into the filesystem,
+ * for which the owner of the mount has ptrace privilege.  This
+ * excludes processes started by other users, suid or sgid processes.
+ */
+int fuse_allow_task(struct fuse_conn *fc, struct task_struct *task)
+{
+	const struct cred *cred;
+	int ret;
+
+	if (fc->flags & FUSE_ALLOW_OTHER)
+		return 1;
+
+	rcu_read_lock();
+	ret = 0;
+	cred = __task_cred(task);
+	if (cred->euid == fc->user_id &&
+	    cred->suid == fc->user_id &&
+	    cred->uid  == fc->user_id &&
+	    cred->egid == fc->group_id &&
+	    cred->sgid == fc->group_id &&
+	    cred->gid  == fc->group_id)
+		ret = 1;
+	rcu_read_unlock();
+
+	return ret;
+}
+
+static int fuse_access(struct inode *inode, int mask)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	struct fuse_access_in inarg;
+	int err;
+
+	if (fc->no_access)
+		return 0;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);
+	req->in.h.opcode = FUSE_ACCESS;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err == -ENOSYS) {
+		fc->no_access = 1;
+		err = 0;
+	}
+	return err;
+}
+
+static int fuse_perm_getattr(struct inode *inode, int flags)
+{
+	if (flags & IPERM_FLAG_RCU)
+		return -ECHILD;
+
+	return fuse_do_getattr(inode, NULL, NULL);
+}
+
+/*
+ * Check permission.  The two basic access models of FUSE are:
+ *
+ * 1) Local access checking ('default_permissions' mount option) based
+ * on file mode.  This is the plain old disk filesystem permission
+ * modell.
+ *
+ * 2) "Remote" access checking, where server is responsible for
+ * checking permission in each inode operation.  An exception to this
+ * is if ->permission() was invoked from sys_access() in which case an
+ * access request is sent.  Execute permission is still checked
+ * locally based on file mode.
+ */
+static int fuse_permission(struct inode *inode, int mask, unsigned int flags)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	bool refreshed = false;
+	int err = 0;
+
+	if (!fuse_allow_task(fc, current))
+		return -EACCES;
+
+	/*
+	 * If attributes are needed, refresh them before proceeding
+	 */
+	if ((fc->flags & FUSE_DEFAULT_PERMISSIONS) ||
+	    ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) {
+		struct fuse_inode *fi = get_fuse_inode(inode);
+
+		if (fi->i_time < get_jiffies_64()) {
+			refreshed = true;
+
+			err = fuse_perm_getattr(inode, flags);
+			if (err)
+				return err;
+		}
+	}
+
+	if (fc->flags & FUSE_DEFAULT_PERMISSIONS) {
+		err = generic_permission(inode, mask, flags, NULL);
+
+		/* If permission is denied, try to refresh file
+		   attributes.  This is also needed, because the root
+		   node will at first have no permissions */
+		if (err == -EACCES && !refreshed) {
+			err = fuse_perm_getattr(inode, flags);
+			if (!err)
+				err = generic_permission(inode, mask,
+							flags, NULL);
+		}
+
+		/* Note: the opposite of the above test does not
+		   exist.  So if permissions are revoked this won't be
+		   noticed immediately, only after the attribute
+		   timeout has expired */
+	} else if (mask & (MAY_ACCESS | MAY_CHDIR)) {
+		if (flags & IPERM_FLAG_RCU)
+			return -ECHILD;
+
+		err = fuse_access(inode, mask);
+	} else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) {
+		if (!(inode->i_mode & S_IXUGO)) {
+			if (refreshed)
+				return -EACCES;
+
+			err = fuse_perm_getattr(inode, flags);
+			if (!err && !(inode->i_mode & S_IXUGO))
+				return -EACCES;
+		}
+	}
+	return err;
+}
+
+static int parse_dirfile(char *buf, size_t nbytes, struct file *file,
+			 void *dstbuf, filldir_t filldir)
+{
+	while (nbytes >= FUSE_NAME_OFFSET) {
+		struct fuse_dirent *dirent = (struct fuse_dirent *) buf;
+		size_t reclen = FUSE_DIRENT_SIZE(dirent);
+		int over;
+		if (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)
+			return -EIO;
+		if (reclen > nbytes)
+			break;
+
+		over = filldir(dstbuf, dirent->name, dirent->namelen,
+			       file->f_pos, dirent->ino, dirent->type);
+		if (over)
+			break;
+
+		buf += reclen;
+		nbytes -= reclen;
+		file->f_pos = dirent->off;
+	}
+
+	return 0;
+}
+
+static int fuse_readdir(struct file *file, void *dstbuf, filldir_t filldir)
+{
+	int err;
+	size_t nbytes;
+	struct page *page;
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	page = alloc_page(GFP_KERNEL);
+	if (!page) {
+		fuse_put_request(fc, req);
+		return -ENOMEM;
+	}
+	req->out.argpages = 1;
+	req->num_pages = 1;
+	req->pages[0] = page;
+	fuse_read_fill(req, file, file->f_pos, PAGE_SIZE, FUSE_READDIR);
+	fuse_request_send(fc, req);
+	nbytes = req->out.args[0].size;
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (!err)
+		err = parse_dirfile(page_address(page), nbytes, file, dstbuf,
+				    filldir);
+
+	__free_page(page);
+	fuse_invalidate_attr(inode); /* atime changed */
+	return err;
+}
+
+static char *read_link(struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req = fuse_get_req(fc);
+	char *link;
+
+	if (IS_ERR(req))
+		return ERR_CAST(req);
+
+	link = (char *) __get_free_page(GFP_KERNEL);
+	if (!link) {
+		link = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	req->in.h.opcode = FUSE_READLINK;
+	req->in.h.nodeid = get_node_id(inode);
+	req->out.argvar = 1;
+	req->out.numargs = 1;
+	req->out.args[0].size = PAGE_SIZE - 1;
+	req->out.args[0].value = link;
+	fuse_request_send(fc, req);
+	if (req->out.h.error) {
+		free_page((unsigned long) link);
+		link = ERR_PTR(req->out.h.error);
+	} else
+		link[req->out.args[0].size] = '\0';
+ out:
+	fuse_put_request(fc, req);
+	fuse_invalidate_attr(inode); /* atime changed */
+	return link;
+}
+
+static void free_link(char *link)
+{
+	if (!IS_ERR(link))
+		free_page((unsigned long) link);
+}
+
+static void *fuse_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	nd_set_link(nd, read_link(dentry));
+	return NULL;
+}
+
+static void fuse_put_link(struct dentry *dentry, struct nameidata *nd, void *c)
+{
+	free_link(nd_get_link(nd));
+}
+
+static int fuse_dir_open(struct inode *inode, struct file *file)
+{
+	return fuse_open_common(inode, file, true);
+}
+
+static int fuse_dir_release(struct inode *inode, struct file *file)
+{
+	fuse_release_common(file, FUSE_RELEASEDIR);
+
+	return 0;
+}
+
+static int fuse_dir_fsync(struct file *file, int datasync)
+{
+	return fuse_fsync_common(file, datasync, 1);
+}
+
+static bool update_mtime(unsigned ivalid)
+{
+	/* Always update if mtime is explicitly set  */
+	if (ivalid & ATTR_MTIME_SET)
+		return true;
+
+	/* If it's an open(O_TRUNC) or an ftruncate(), don't update */
+	if ((ivalid & ATTR_SIZE) && (ivalid & (ATTR_OPEN | ATTR_FILE)))
+		return false;
+
+	/* In all other cases update */
+	return true;
+}
+
+static void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg)
+{
+	unsigned ivalid = iattr->ia_valid;
+
+	if (ivalid & ATTR_MODE)
+		arg->valid |= FATTR_MODE,   arg->mode = iattr->ia_mode;
+	if (ivalid & ATTR_UID)
+		arg->valid |= FATTR_UID,    arg->uid = iattr->ia_uid;
+	if (ivalid & ATTR_GID)
+		arg->valid |= FATTR_GID,    arg->gid = iattr->ia_gid;
+	if (ivalid & ATTR_SIZE)
+		arg->valid |= FATTR_SIZE,   arg->size = iattr->ia_size;
+	if (ivalid & ATTR_ATIME) {
+		arg->valid |= FATTR_ATIME;
+		arg->atime = iattr->ia_atime.tv_sec;
+		arg->atimensec = iattr->ia_atime.tv_nsec;
+		if (!(ivalid & ATTR_ATIME_SET))
+			arg->valid |= FATTR_ATIME_NOW;
+	}
+	if ((ivalid & ATTR_MTIME) && update_mtime(ivalid)) {
+		arg->valid |= FATTR_MTIME;
+		arg->mtime = iattr->ia_mtime.tv_sec;
+		arg->mtimensec = iattr->ia_mtime.tv_nsec;
+		if (!(ivalid & ATTR_MTIME_SET))
+			arg->valid |= FATTR_MTIME_NOW;
+	}
+}
+
+/*
+ * Prevent concurrent writepages on inode
+ *
+ * This is done by adding a negative bias to the inode write counter
+ * and waiting for all pending writes to finish.
+ */
+void fuse_set_nowrite(struct inode *inode)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+
+	BUG_ON(!mutex_is_locked(&inode->i_mutex));
+
+	spin_lock(&fc->lock);
+	BUG_ON(fi->writectr < 0);
+	fi->writectr += FUSE_NOWRITE;
+	spin_unlock(&fc->lock);
+	wait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);
+}
+
+/*
+ * Allow writepages on inode
+ *
+ * Remove the bias from the writecounter and send any queued
+ * writepages.
+ */
+static void __fuse_release_nowrite(struct inode *inode)
+{
+	struct fuse_inode *fi = get_fuse_inode(inode);
+
+	BUG_ON(fi->writectr != FUSE_NOWRITE);
+	fi->writectr = 0;
+	fuse_flush_writepages(inode);
+}
+
+void fuse_release_nowrite(struct inode *inode)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+
+	spin_lock(&fc->lock);
+	__fuse_release_nowrite(inode);
+	spin_unlock(&fc->lock);
+}
+
+/*
+ * Set attributes, and at the same time refresh them.
+ *
+ * Truncation is slightly complicated, because the 'truncate' request
+ * may fail, in which case we don't want to touch the mapping.
+ * vmtruncate() doesn't allow for this case, so do the rlimit checking
+ * and the actual truncation by hand.
+ */
+static int fuse_do_setattr(struct dentry *entry, struct iattr *attr,
+			   struct file *file)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	struct fuse_setattr_in inarg;
+	struct fuse_attr_out outarg;
+	bool is_truncate = false;
+	loff_t oldsize;
+	int err;
+
+	if (!fuse_allow_task(fc, current))
+		return -EACCES;
+
+	if (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))
+		attr->ia_valid |= ATTR_FORCE;
+
+	err = inode_change_ok(inode, attr);
+	if (err)
+		return err;
+
+	if (attr->ia_valid & ATTR_OPEN) {
+		if (fc->atomic_o_trunc)
+			return 0;
+		file = NULL;
+	}
+
+	if (attr->ia_valid & ATTR_SIZE)
+		is_truncate = true;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	if (is_truncate)
+		fuse_set_nowrite(inode);
+
+	memset(&inarg, 0, sizeof(inarg));
+	memset(&outarg, 0, sizeof(outarg));
+	iattr_to_fattr(attr, &inarg);
+	if (file) {
+		struct fuse_file *ff = file->private_data;
+		inarg.valid |= FATTR_FH;
+		inarg.fh = ff->fh;
+	}
+	if (attr->ia_valid & ATTR_SIZE) {
+		/* For mandatory locking in truncate */
+		inarg.valid |= FATTR_LOCKOWNER;
+		inarg.lock_owner = fuse_lock_owner_id(fc, current->files);
+	}
+	req->in.h.opcode = FUSE_SETATTR;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->out.numargs = 1;
+	if (fc->minor < 9)
+		req->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;
+	else
+		req->out.args[0].size = sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err) {
+		if (err == -EINTR)
+			fuse_invalidate_attr(inode);
+		goto error;
+	}
+
+	if ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
+		make_bad_inode(inode);
+		err = -EIO;
+		goto error;
+	}
+
+	spin_lock(&fc->lock);
+	fuse_change_attributes_common(inode, &outarg.attr,
+				      attr_timeout(&outarg));
+	oldsize = inode->i_size;
+	i_size_write(inode, outarg.attr.size);
+
+	if (is_truncate) {
+		/* NOTE: this may release/reacquire fc->lock */
+		__fuse_release_nowrite(inode);
+	}
+	spin_unlock(&fc->lock);
+
+	/*
+	 * Only call invalidate_inode_pages2() after removing
+	 * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.
+	 */
+	if (S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {
+		truncate_pagecache(inode, oldsize, outarg.attr.size);
+		invalidate_inode_pages2(inode->i_mapping);
+	}
+
+	return 0;
+
+error:
+	if (is_truncate)
+		fuse_release_nowrite(inode);
+
+	return err;
+}
+
+static int fuse_setattr(struct dentry *entry, struct iattr *attr)
+{
+	if (attr->ia_valid & ATTR_FILE)
+		return fuse_do_setattr(entry, attr, attr->ia_file);
+	else
+		return fuse_do_setattr(entry, attr, NULL);
+}
+
+static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
+			struct kstat *stat)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+
+	if (!fuse_allow_task(fc, current))
+		return -EACCES;
+
+	return fuse_update_attributes(inode, stat, NULL, NULL);
+}
+
+static int fuse_setxattr(struct dentry *entry, const char *name,
+			 const void *value, size_t size, int flags)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	struct fuse_setxattr_in inarg;
+	int err;
+
+	if (fc->no_setxattr)
+		return -EOPNOTSUPP;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.size = size;
+	inarg.flags = flags;
+	req->in.h.opcode = FUSE_SETXATTR;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 3;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->in.args[1].size = strlen(name) + 1;
+	req->in.args[1].value = name;
+	req->in.args[2].size = size;
+	req->in.args[2].value = value;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err == -ENOSYS) {
+		fc->no_setxattr = 1;
+		err = -EOPNOTSUPP;
+	}
+	return err;
+}
+
+static ssize_t fuse_getxattr(struct dentry *entry, const char *name,
+			     void *value, size_t size)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	struct fuse_getxattr_in inarg;
+	struct fuse_getxattr_out outarg;
+	ssize_t ret;
+
+	if (fc->no_getxattr)
+		return -EOPNOTSUPP;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.size = size;
+	req->in.h.opcode = FUSE_GETXATTR;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 2;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->in.args[1].size = strlen(name) + 1;
+	req->in.args[1].value = name;
+	/* This is really two different operations rolled into one */
+	req->out.numargs = 1;
+	if (size) {
+		req->out.argvar = 1;
+		req->out.args[0].size = size;
+		req->out.args[0].value = value;
+	} else {
+		req->out.args[0].size = sizeof(outarg);
+		req->out.args[0].value = &outarg;
+	}
+	fuse_request_send(fc, req);
+	ret = req->out.h.error;
+	if (!ret)
+		ret = size ? req->out.args[0].size : outarg.size;
+	else {
+		if (ret == -ENOSYS) {
+			fc->no_getxattr = 1;
+			ret = -EOPNOTSUPP;
+		}
+	}
+	fuse_put_request(fc, req);
+	return ret;
+}
+
+static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	struct fuse_getxattr_in inarg;
+	struct fuse_getxattr_out outarg;
+	ssize_t ret;
+
+	if (!fuse_allow_task(fc, current))
+		return -EACCES;
+
+	if (fc->no_listxattr)
+		return -EOPNOTSUPP;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.size = size;
+	req->in.h.opcode = FUSE_LISTXATTR;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	/* This is really two different operations rolled into one */
+	req->out.numargs = 1;
+	if (size) {
+		req->out.argvar = 1;
+		req->out.args[0].size = size;
+		req->out.args[0].value = list;
+	} else {
+		req->out.args[0].size = sizeof(outarg);
+		req->out.args[0].value = &outarg;
+	}
+	fuse_request_send(fc, req);
+	ret = req->out.h.error;
+	if (!ret)
+		ret = size ? req->out.args[0].size : outarg.size;
+	else {
+		if (ret == -ENOSYS) {
+			fc->no_listxattr = 1;
+			ret = -EOPNOTSUPP;
+		}
+	}
+	fuse_put_request(fc, req);
+	return ret;
+}
+
+static int fuse_removexattr(struct dentry *entry, const char *name)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	int err;
+
+	if (fc->no_removexattr)
+		return -EOPNOTSUPP;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	req->in.h.opcode = FUSE_REMOVEXATTR;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = strlen(name) + 1;
+	req->in.args[0].value = name;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err == -ENOSYS) {
+		fc->no_removexattr = 1;
+		err = -EOPNOTSUPP;
+	}
+	return err;
+}
+
+static const struct inode_operations fuse_dir_inode_operations = {
+	.lookup		= fuse_lookup,
+	.mkdir		= fuse_mkdir,
+	.symlink	= fuse_symlink,
+	.unlink		= fuse_unlink,
+	.rmdir		= fuse_rmdir,
+	.rename		= fuse_rename,
+	.link		= fuse_link,
+	.setattr	= fuse_setattr,
+	.create		= fuse_create,
+	.mknod		= fuse_mknod,
+	.permission	= fuse_permission,
+	.getattr	= fuse_getattr,
+	.setxattr	= fuse_setxattr,
+	.getxattr	= fuse_getxattr,
+	.listxattr	= fuse_listxattr,
+	.removexattr	= fuse_removexattr,
+};
+
+static const struct file_operations fuse_dir_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= generic_read_dir,
+	.readdir	= fuse_readdir,
+	.open		= fuse_dir_open,
+	.release	= fuse_dir_release,
+	.fsync		= fuse_dir_fsync,
+};
+
+static const struct inode_operations fuse_common_inode_operations = {
+	.setattr	= fuse_setattr,
+	.permission	= fuse_permission,
+	.getattr	= fuse_getattr,
+	.setxattr	= fuse_setxattr,
+	.getxattr	= fuse_getxattr,
+	.listxattr	= fuse_listxattr,
+	.removexattr	= fuse_removexattr,
+};
+
+static const struct inode_operations fuse_symlink_inode_operations = {
+	.setattr	= fuse_setattr,
+	.follow_link	= fuse_follow_link,
+	.put_link	= fuse_put_link,
+	.readlink	= generic_readlink,
+	.getattr	= fuse_getattr,
+	.setxattr	= fuse_setxattr,
+	.getxattr	= fuse_getxattr,
+	.listxattr	= fuse_listxattr,
+	.removexattr	= fuse_removexattr,
+};
+
+void fuse_init_common(struct inode *inode)
+{
+	inode->i_op = &fuse_common_inode_operations;
+}
+
+void fuse_init_dir(struct inode *inode)
+{
+	inode->i_op = &fuse_dir_inode_operations;
+	inode->i_fop = &fuse_dir_operations;
+}
+
+void fuse_init_symlink(struct inode *inode)
+{
+	inode->i_op = &fuse_symlink_inode_operations;
+}
Index: fuse-2.8.5/kernel/file.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/file.c
@@ -0,0 +1,2186 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/compat.h>
+
+static const struct file_operations fuse_direct_io_file_operations;
+
+static int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
+			  int opcode, struct fuse_open_out *outargp)
+{
+	struct fuse_open_in inarg;
+	struct fuse_req *req;
+	int err;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);
+	if (!fc->atomic_o_trunc)
+		inarg.flags &= ~O_TRUNC;
+	req->in.h.opcode = opcode;
+	req->in.h.nodeid = nodeid;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->out.numargs = 1;
+	req->out.args[0].size = sizeof(*outargp);
+	req->out.args[0].value = outargp;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+
+	return err;
+}
+
+struct fuse_file *fuse_file_alloc(struct fuse_conn *fc)
+{
+	struct fuse_file *ff;
+
+	ff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);
+	if (unlikely(!ff))
+		return NULL;
+
+	ff->fc = fc;
+	ff->reserved_req = fuse_request_alloc();
+	if (unlikely(!ff->reserved_req)) {
+		kfree(ff);
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&ff->write_entry);
+	atomic_set(&ff->count, 0);
+	RB_CLEAR_NODE(&ff->polled_node);
+	init_waitqueue_head(&ff->poll_wait);
+
+	spin_lock(&fc->lock);
+	ff->kh = ++fc->khctr;
+	spin_unlock(&fc->lock);
+
+	return ff;
+}
+
+void fuse_file_free(struct fuse_file *ff)
+{
+	fuse_request_free(ff->reserved_req);
+	kfree(ff);
+}
+
+struct fuse_file *fuse_file_get(struct fuse_file *ff)
+{
+	atomic_inc(&ff->count);
+	return ff;
+}
+
+static void fuse_release_async(struct work_struct *work)
+{
+	struct fuse_req *req;
+	struct fuse_conn *fc;
+	struct path path;
+
+	req = container_of(work, struct fuse_req, misc.release.work);
+	path = req->misc.release.path;
+	fc = get_fuse_conn(path.dentry->d_inode);
+
+	fuse_put_request(fc, req);
+	path_put(&path);
+}
+
+static void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)
+{
+	if (fc->destroy_req) {
+		/*
+		 * If this is a fuseblk mount, then it's possible that
+		 * releasing the path will result in releasing the
+		 * super block and sending the DESTROY request.  If
+		 * the server is single threaded, this would hang.
+		 * For this reason do the path_put() in a separate
+		 * thread.
+		 */
+		atomic_inc(&req->count);
+		INIT_WORK(&req->misc.release.work, fuse_release_async);
+		schedule_work(&req->misc.release.work);
+	} else {
+		path_put(&req->misc.release.path);
+	}
+}
+
+static void fuse_file_put(struct fuse_file *ff, bool sync)
+{
+	if (atomic_dec_and_test(&ff->count)) {
+		struct fuse_req *req = ff->reserved_req;
+
+		if (sync) {
+			fuse_request_send(ff->fc, req);
+			path_put(&req->misc.release.path);
+			fuse_put_request(ff->fc, req);
+		} else {
+			req->end = fuse_release_end;
+			fuse_request_send_background(ff->fc, req);
+		}
+		kfree(ff);
+	}
+}
+
+int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
+		 bool isdir)
+{
+	struct fuse_open_out outarg;
+	struct fuse_file *ff;
+	int err;
+	int opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;
+
+	ff = fuse_file_alloc(fc);
+	if (!ff)
+		return -ENOMEM;
+
+	err = fuse_send_open(fc, nodeid, file, opcode, &outarg);
+	if (err) {
+		fuse_file_free(ff);
+		return err;
+	}
+
+	if (isdir)
+		outarg.open_flags &= ~FOPEN_DIRECT_IO;
+
+	ff->fh = outarg.fh;
+	ff->nodeid = nodeid;
+	ff->open_flags = outarg.open_flags;
+	file->private_data = fuse_file_get(ff);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fuse_do_open);
+
+void fuse_finish_open(struct inode *inode, struct file *file)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+
+	if (ff->open_flags & FOPEN_DIRECT_IO)
+		file->f_op = &fuse_direct_io_file_operations;
+	if (!(ff->open_flags & FOPEN_KEEP_CACHE))
+		invalidate_inode_pages2(inode->i_mapping);
+	if (ff->open_flags & FOPEN_NONSEEKABLE)
+		nonseekable_open(inode, file);
+	if (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {
+		struct fuse_inode *fi = get_fuse_inode(inode);
+
+		spin_lock(&fc->lock);
+		fi->attr_version = ++fc->attr_version;
+		i_size_write(inode, 0);
+		spin_unlock(&fc->lock);
+		fuse_invalidate_attr(inode);
+	}
+}
+
+int fuse_open_common(struct inode *inode, struct file *file, bool isdir)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	int err;
+
+	/* VFS checks this, but only _after_ ->open() */
+	if (file->f_flags & O_DIRECT)
+		return -EINVAL;
+
+	err = generic_file_open(inode, file);
+	if (err)
+		return err;
+
+	err = fuse_do_open(fc, get_node_id(inode), file, isdir);
+	if (err)
+		return err;
+
+	fuse_finish_open(inode, file);
+
+	return 0;
+}
+
+static void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)
+{
+	struct fuse_conn *fc = ff->fc;
+	struct fuse_req *req = ff->reserved_req;
+	struct fuse_release_in *inarg = &req->misc.release.in;
+
+	spin_lock(&fc->lock);
+	list_del(&ff->write_entry);
+	if (!RB_EMPTY_NODE(&ff->polled_node))
+		rb_erase(&ff->polled_node, &fc->polled_files);
+	spin_unlock(&fc->lock);
+
+	wake_up_interruptible_all(&ff->poll_wait);
+
+	inarg->fh = ff->fh;
+	inarg->flags = flags;
+	req->in.h.opcode = opcode;
+	req->in.h.nodeid = ff->nodeid;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(struct fuse_release_in);
+	req->in.args[0].value = inarg;
+}
+
+void fuse_release_common(struct file *file, int opcode)
+{
+	struct fuse_file *ff;
+	struct fuse_req *req;
+
+	ff = file->private_data;
+	if (unlikely(!ff))
+		return;
+
+	req = ff->reserved_req;
+	fuse_prepare_release(ff, file->f_flags, opcode);
+
+	/* Hold vfsmount and dentry until release is finished */
+	path_get(&file->f_path);
+	req->misc.release.path = file->f_path;
+
+	/*
+	 * Normally this will send the RELEASE request, however if
+	 * some asynchronous READ or WRITE requests are outstanding,
+	 * the sending will be delayed.
+	 *
+	 * Make the release synchronous if this is a fuseblk mount,
+	 * synchronous RELEASE is allowed (and desirable) in this case
+	 * because the server can be trusted not to screw up.
+	 */
+	fuse_file_put(ff, ff->fc->destroy_req != NULL);
+}
+
+static int fuse_open(struct inode *inode, struct file *file)
+{
+	return fuse_open_common(inode, file, false);
+}
+
+static int fuse_release(struct inode *inode, struct file *file)
+{
+	fuse_release_common(file, FUSE_RELEASE);
+
+	/* return value is ignored by VFS */
+	return 0;
+}
+
+void fuse_sync_release(struct fuse_file *ff, int flags)
+{
+	WARN_ON(atomic_read(&ff->count) > 1);
+	fuse_prepare_release(ff, flags, FUSE_RELEASE);
+	ff->reserved_req->force = 1;
+	fuse_request_send(ff->fc, ff->reserved_req);
+	fuse_put_request(ff->fc, ff->reserved_req);
+	kfree(ff);
+}
+EXPORT_SYMBOL_GPL(fuse_sync_release);
+
+/*
+ * Scramble the ID space with XTEA, so that the value of the files_struct
+ * pointer is not exposed to userspace.
+ */
+u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)
+{
+	u32 *k = fc->scramble_key;
+	u64 v = (unsigned long) id;
+	u32 v0 = v;
+	u32 v1 = v >> 32;
+	u32 sum = 0;
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		v0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);
+		sum += 0x9E3779B9;
+		v1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);
+	}
+
+	return (u64) v0 + ((u64) v1 << 32);
+}
+
+/*
+ * Check if page is under writeback
+ *
+ * This is currently done by walking the list of writepage requests
+ * for the inode, which can be pretty inefficient.
+ */
+static bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+	struct fuse_req *req;
+	bool found = false;
+
+	spin_lock(&fc->lock);
+	list_for_each_entry(req, &fi->writepages, writepages_entry) {
+		pgoff_t curr_index;
+
+		BUG_ON(req->inode != inode);
+		curr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;
+		if (curr_index == index) {
+			found = true;
+			break;
+		}
+	}
+	spin_unlock(&fc->lock);
+
+	return found;
+}
+
+/*
+ * Wait for page writeback to be completed.
+ *
+ * Since fuse doesn't rely on the VM writeback tracking, this has to
+ * use some other means.
+ */
+static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)
+{
+	struct fuse_inode *fi = get_fuse_inode(inode);
+
+	wait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));
+	return 0;
+}
+
+static int fuse_flush(struct file *file, fl_owner_t id)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_file *ff = file->private_data;
+	struct fuse_req *req;
+	struct fuse_flush_in inarg;
+	int err;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	if (fc->no_flush)
+		return 0;
+
+	req = fuse_get_req_nofail(fc, file);
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.fh = ff->fh;
+	inarg.lock_owner = fuse_lock_owner_id(fc, id);
+	req->in.h.opcode = FUSE_FLUSH;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->force = 1;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err == -ENOSYS) {
+		fc->no_flush = 1;
+		err = 0;
+	}
+	return err;
+}
+
+/*
+ * Wait for all pending writepages on the inode to finish.
+ *
+ * This is currently done by blocking further writes with FUSE_NOWRITE
+ * and waiting for all sent writes to complete.
+ *
+ * This must be called under i_mutex, otherwise the FUSE_NOWRITE usage
+ * could conflict with truncation.
+ */
+static void fuse_sync_writes(struct inode *inode)
+{
+	fuse_set_nowrite(inode);
+	fuse_release_nowrite(inode);
+}
+
+int fuse_fsync_common(struct file *file, int datasync, int isdir)
+{
+	struct inode *inode = file->f_mapping->host;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_file *ff = file->private_data;
+	struct fuse_req *req;
+	struct fuse_fsync_in inarg;
+	int err;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	if ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))
+		return 0;
+
+	/*
+	 * Start writeback against all dirty pages of the inode, then
+	 * wait for all outstanding writes, before sending the FSYNC
+	 * request.
+	 */
+	err = write_inode_now(inode, 0);
+	if (err)
+		return err;
+
+	fuse_sync_writes(inode);
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.fh = ff->fh;
+	inarg.fsync_flags = datasync ? 1 : 0;
+	req->in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err == -ENOSYS) {
+		if (isdir)
+			fc->no_fsyncdir = 1;
+		else
+			fc->no_fsync = 1;
+		err = 0;
+	}
+	return err;
+}
+
+static int fuse_fsync(struct file *file, int datasync)
+{
+	return fuse_fsync_common(file, datasync, 0);
+}
+
+void fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,
+		    size_t count, int opcode)
+{
+	struct fuse_read_in *inarg = &req->misc.read.in;
+	struct fuse_file *ff = file->private_data;
+
+	inarg->fh = ff->fh;
+	inarg->offset = pos;
+	inarg->size = count;
+	inarg->flags = file->f_flags;
+	req->in.h.opcode = opcode;
+	req->in.h.nodeid = ff->nodeid;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(struct fuse_read_in);
+	req->in.args[0].value = inarg;
+	req->out.argvar = 1;
+	req->out.numargs = 1;
+	req->out.args[0].size = count;
+}
+
+static size_t fuse_send_read(struct fuse_req *req, struct file *file,
+			     loff_t pos, size_t count, fl_owner_t owner)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = ff->fc;
+
+	fuse_read_fill(req, file, pos, count, FUSE_READ);
+	if (owner != NULL) {
+		struct fuse_read_in *inarg = &req->misc.read.in;
+
+		inarg->read_flags |= FUSE_READ_LOCKOWNER;
+		inarg->lock_owner = fuse_lock_owner_id(fc, owner);
+	}
+	fuse_request_send(fc, req);
+	return req->out.args[0].size;
+}
+
+static void fuse_read_update_size(struct inode *inode, loff_t size,
+				  u64 attr_ver)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+
+	spin_lock(&fc->lock);
+	if (attr_ver == fi->attr_version && size < inode->i_size) {
+		fi->attr_version = ++fc->attr_version;
+		i_size_write(inode, size);
+	}
+	spin_unlock(&fc->lock);
+}
+
+static int fuse_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	size_t num_read;
+	loff_t pos = page_offset(page);
+	size_t count = PAGE_CACHE_SIZE;
+	u64 attr_ver;
+	int err;
+
+	err = -EIO;
+	if (is_bad_inode(inode))
+		goto out;
+
+	/*
+	 * Page writeback can extend beyond the lifetime of the
+	 * page-cache page, so make sure we read a properly synced
+	 * page.
+	 */
+	fuse_wait_on_page_writeback(inode, page->index);
+
+	req = fuse_get_req(fc);
+	err = PTR_ERR(req);
+	if (IS_ERR(req))
+		goto out;
+
+	attr_ver = fuse_get_attr_version(fc);
+
+	req->out.page_zeroing = 1;
+	req->out.argpages = 1;
+	req->num_pages = 1;
+	req->pages[0] = page;
+	num_read = fuse_send_read(req, file, pos, count, NULL);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+
+	if (!err) {
+		/*
+		 * Short read means EOF.  If file size is larger, truncate it
+		 */
+		if (num_read < count)
+			fuse_read_update_size(inode, pos + num_read, attr_ver);
+
+		SetPageUptodate(page);
+	}
+
+	fuse_invalidate_attr(inode); /* atime changed */
+ out:
+	unlock_page(page);
+	return err;
+}
+
+static void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)
+{
+	int i;
+	size_t count = req->misc.read.in.size;
+	size_t num_read = req->out.args[0].size;
+	struct address_space *mapping = NULL;
+
+	for (i = 0; mapping == NULL && i < req->num_pages; i++)
+		mapping = req->pages[i]->mapping;
+
+	if (mapping) {
+		struct inode *inode = mapping->host;
+
+		/*
+		 * Short read means EOF. If file size is larger, truncate it
+		 */
+		if (!req->out.h.error && num_read < count) {
+			loff_t pos;
+
+			pos = page_offset(req->pages[0]) + num_read;
+			fuse_read_update_size(inode, pos,
+					      req->misc.read.attr_ver);
+		}
+		fuse_invalidate_attr(inode); /* atime changed */
+	}
+
+	for (i = 0; i < req->num_pages; i++) {
+		struct page *page = req->pages[i];
+		if (!req->out.h.error)
+			SetPageUptodate(page);
+		else
+			SetPageError(page);
+		unlock_page(page);
+		page_cache_release(page);
+	}
+	if (req->ff)
+		fuse_file_put(req->ff, false);
+}
+
+static void fuse_send_readpages(struct fuse_req *req, struct file *file)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = ff->fc;
+	loff_t pos = page_offset(req->pages[0]);
+	size_t count = req->num_pages << PAGE_CACHE_SHIFT;
+
+	req->out.argpages = 1;
+	req->out.page_zeroing = 1;
+	req->out.page_replace = 1;
+	fuse_read_fill(req, file, pos, count, FUSE_READ);
+	req->misc.read.attr_ver = fuse_get_attr_version(fc);
+	if (fc->async_read) {
+		req->ff = fuse_file_get(ff);
+		req->end = fuse_readpages_end;
+		fuse_request_send_background(fc, req);
+	} else {
+		fuse_request_send(fc, req);
+		fuse_readpages_end(fc, req);
+		fuse_put_request(fc, req);
+	}
+}
+
+struct fuse_fill_data {
+	struct fuse_req *req;
+	struct file *file;
+	struct inode *inode;
+};
+
+static int fuse_readpages_fill(void *_data, struct page *page)
+{
+	struct fuse_fill_data *data = _data;
+	struct fuse_req *req = data->req;
+	struct inode *inode = data->inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+
+	fuse_wait_on_page_writeback(inode, page->index);
+
+	if (req->num_pages &&
+	    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||
+	     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||
+	     req->pages[req->num_pages - 1]->index + 1 != page->index)) {
+		fuse_send_readpages(req, data->file);
+		data->req = req = fuse_get_req(fc);
+		if (IS_ERR(req)) {
+			unlock_page(page);
+			return PTR_ERR(req);
+		}
+	}
+	page_cache_get(page);
+	req->pages[req->num_pages] = page;
+	req->num_pages++;
+	return 0;
+}
+
+static int fuse_readpages(struct file *file, struct address_space *mapping,
+			  struct list_head *pages, unsigned nr_pages)
+{
+	struct inode *inode = mapping->host;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_fill_data data;
+	int err;
+
+	err = -EIO;
+	if (is_bad_inode(inode))
+		goto out;
+
+	data.file = file;
+	data.inode = inode;
+	data.req = fuse_get_req(fc);
+	err = PTR_ERR(data.req);
+	if (IS_ERR(data.req))
+		goto out;
+
+	err = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);
+	if (!err) {
+		if (data.req->num_pages)
+			fuse_send_readpages(data.req, file);
+		else
+			fuse_put_request(fc, data.req);
+	}
+out:
+	return err;
+}
+
+static ssize_t fuse_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
+				  unsigned long nr_segs, loff_t pos)
+{
+	struct inode *inode = iocb->ki_filp->f_mapping->host;
+
+	if (pos + iov_length(iov, nr_segs) > i_size_read(inode)) {
+		int err;
+		/*
+		 * If trying to read past EOF, make sure the i_size
+		 * attribute is up-to-date.
+		 */
+		err = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);
+		if (err)
+			return err;
+	}
+
+	return generic_file_aio_read(iocb, iov, nr_segs, pos);
+}
+
+static void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,
+			    loff_t pos, size_t count)
+{
+	struct fuse_write_in *inarg = &req->misc.write.in;
+	struct fuse_write_out *outarg = &req->misc.write.out;
+
+	inarg->fh = ff->fh;
+	inarg->offset = pos;
+	inarg->size = count;
+	req->in.h.opcode = FUSE_WRITE;
+	req->in.h.nodeid = ff->nodeid;
+	req->in.numargs = 2;
+	if (ff->fc->minor < 9)
+		req->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;
+	else
+		req->in.args[0].size = sizeof(struct fuse_write_in);
+	req->in.args[0].value = inarg;
+	req->in.args[1].size = count;
+	req->out.numargs = 1;
+	req->out.args[0].size = sizeof(struct fuse_write_out);
+	req->out.args[0].value = outarg;
+}
+
+static size_t fuse_send_write(struct fuse_req *req, struct file *file,
+			      loff_t pos, size_t count, fl_owner_t owner)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = ff->fc;
+	struct fuse_write_in *inarg = &req->misc.write.in;
+
+	fuse_write_fill(req, ff, pos, count);
+	inarg->flags = file->f_flags;
+	if (owner != NULL) {
+		inarg->write_flags |= FUSE_WRITE_LOCKOWNER;
+		inarg->lock_owner = fuse_lock_owner_id(fc, owner);
+	}
+	fuse_request_send(fc, req);
+	return req->misc.write.out.size;
+}
+
+static int fuse_write_begin(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned flags,
+			struct page **pagep, void **fsdata)
+{
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	*pagep = grab_cache_page_write_begin(mapping, index, flags);
+	if (!*pagep)
+		return -ENOMEM;
+	return 0;
+}
+
+void fuse_write_update_size(struct inode *inode, loff_t pos)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+
+	spin_lock(&fc->lock);
+	fi->attr_version = ++fc->attr_version;
+	if (pos > inode->i_size)
+		i_size_write(inode, pos);
+	spin_unlock(&fc->lock);
+}
+
+static int fuse_buffered_write(struct file *file, struct inode *inode,
+			       loff_t pos, unsigned count, struct page *page)
+{
+	int err;
+	size_t nres;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	unsigned offset = pos & (PAGE_CACHE_SIZE - 1);
+	struct fuse_req *req;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	/*
+	 * Make sure writepages on the same page are not mixed up with
+	 * plain writes.
+	 */
+	fuse_wait_on_page_writeback(inode, page->index);
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	req->in.argpages = 1;
+	req->num_pages = 1;
+	req->pages[0] = page;
+	req->page_offset = offset;
+	nres = fuse_send_write(req, file, pos, count, NULL);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (!err && !nres)
+		err = -EIO;
+	if (!err) {
+		pos += nres;
+		fuse_write_update_size(inode, pos);
+		if (count == PAGE_CACHE_SIZE)
+			SetPageUptodate(page);
+	}
+	fuse_invalidate_attr(inode);
+	return err ? err : nres;
+}
+
+static int fuse_write_end(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned copied,
+			struct page *page, void *fsdata)
+{
+	struct inode *inode = mapping->host;
+	int res = 0;
+
+	if (copied)
+		res = fuse_buffered_write(file, inode, pos, copied, page);
+
+	unlock_page(page);
+	page_cache_release(page);
+	return res;
+}
+
+static size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,
+				    struct inode *inode, loff_t pos,
+				    size_t count)
+{
+	size_t res;
+	unsigned offset;
+	unsigned i;
+
+	for (i = 0; i < req->num_pages; i++)
+		fuse_wait_on_page_writeback(inode, req->pages[i]->index);
+
+	res = fuse_send_write(req, file, pos, count, NULL);
+
+	offset = req->page_offset;
+	count = res;
+	for (i = 0; i < req->num_pages; i++) {
+		struct page *page = req->pages[i];
+
+		if (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)
+			SetPageUptodate(page);
+
+		if (count > PAGE_CACHE_SIZE - offset)
+			count -= PAGE_CACHE_SIZE - offset;
+		else
+			count = 0;
+		offset = 0;
+
+		unlock_page(page);
+		page_cache_release(page);
+	}
+
+	return res;
+}
+
+static ssize_t fuse_fill_write_pages(struct fuse_req *req,
+			       struct address_space *mapping,
+			       struct iov_iter *ii, loff_t pos)
+{
+	struct fuse_conn *fc = get_fuse_conn(mapping->host);
+	unsigned offset = pos & (PAGE_CACHE_SIZE - 1);
+	size_t count = 0;
+	int err;
+
+	req->in.argpages = 1;
+	req->page_offset = offset;
+
+	do {
+		size_t tmp;
+		struct page *page;
+		pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+		size_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,
+				     iov_iter_count(ii));
+
+		bytes = min_t(size_t, bytes, fc->max_write - count);
+
+ again:
+		err = -EFAULT;
+		if (iov_iter_fault_in_readable(ii, bytes))
+			break;
+
+		err = -ENOMEM;
+		page = grab_cache_page_write_begin(mapping, index, 0);
+		if (!page)
+			break;
+
+		if (mapping_writably_mapped(mapping))
+			flush_dcache_page(page);
+
+		pagefault_disable();
+		tmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);
+		pagefault_enable();
+		flush_dcache_page(page);
+
+		if (!tmp) {
+			unlock_page(page);
+			page_cache_release(page);
+			bytes = min(bytes, iov_iter_single_seg_count(ii));
+			goto again;
+		}
+
+		err = 0;
+		req->pages[req->num_pages] = page;
+		req->num_pages++;
+
+		iov_iter_advance(ii, tmp);
+		count += tmp;
+		pos += tmp;
+		offset += tmp;
+		if (offset == PAGE_CACHE_SIZE)
+			offset = 0;
+
+		if (!fc->big_writes)
+			break;
+	} while (iov_iter_count(ii) && count < fc->max_write &&
+		 req->num_pages < FUSE_MAX_PAGES_PER_REQ && offset == 0);
+
+	return count > 0 ? count : err;
+}
+
+static ssize_t fuse_perform_write(struct file *file,
+				  struct address_space *mapping,
+				  struct iov_iter *ii, loff_t pos)
+{
+	struct inode *inode = mapping->host;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	int err = 0;
+	ssize_t res = 0;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	do {
+		struct fuse_req *req;
+		ssize_t count;
+
+		req = fuse_get_req(fc);
+		if (IS_ERR(req)) {
+			err = PTR_ERR(req);
+			break;
+		}
+
+		count = fuse_fill_write_pages(req, mapping, ii, pos);
+		if (count <= 0) {
+			err = count;
+		} else {
+			size_t num_written;
+
+			num_written = fuse_send_write_pages(req, file, inode,
+							    pos, count);
+			err = req->out.h.error;
+			if (!err) {
+				res += num_written;
+				pos += num_written;
+
+				/* break out of the loop on short write */
+				if (num_written != count)
+					err = -EIO;
+			}
+		}
+		fuse_put_request(fc, req);
+	} while (!err && iov_iter_count(ii));
+
+	if (res > 0)
+		fuse_write_update_size(inode, pos);
+
+	fuse_invalidate_attr(inode);
+
+	return res > 0 ? res : err;
+}
+
+static ssize_t fuse_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
+				   unsigned long nr_segs, loff_t pos)
+{
+	struct file *file = iocb->ki_filp;
+	struct address_space *mapping = file->f_mapping;
+	size_t count = 0;
+	ssize_t written = 0;
+	struct inode *inode = mapping->host;
+	ssize_t err;
+	struct iov_iter i;
+
+	WARN_ON(iocb->ki_pos != pos);
+
+	err = generic_segment_checks(iov, &nr_segs, &count, VERIFY_READ);
+	if (err)
+		return err;
+
+	mutex_lock(&inode->i_mutex);
+	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
+
+	/* We can write back this queue in page reclaim */
+	current->backing_dev_info = mapping->backing_dev_info;
+
+	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
+	if (err)
+		goto out;
+
+	if (count == 0)
+		goto out;
+
+	err = file_remove_suid(file);
+	if (err)
+		goto out;
+
+	file_update_time(file);
+
+	iov_iter_init(&i, iov, nr_segs, count, 0);
+	written = fuse_perform_write(file, mapping, &i, pos);
+	if (written >= 0)
+		iocb->ki_pos = pos + written;
+
+out:
+	current->backing_dev_info = NULL;
+	mutex_unlock(&inode->i_mutex);
+
+	return written ? written : err;
+}
+
+static void fuse_release_user_pages(struct fuse_req *req, int write)
+{
+	unsigned i;
+
+	for (i = 0; i < req->num_pages; i++) {
+		struct page *page = req->pages[i];
+		if (write)
+			set_page_dirty_lock(page);
+		put_page(page);
+	}
+}
+
+static int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,
+			       size_t *nbytesp, int write)
+{
+	size_t nbytes = *nbytesp;
+	unsigned long user_addr = (unsigned long) buf;
+	unsigned offset = user_addr & ~PAGE_MASK;
+	int npages;
+
+	/* Special case for kernel I/O: can copy directly into the buffer */
+	if (segment_eq(get_fs(), KERNEL_DS)) {
+		if (write)
+			req->in.args[1].value = (void *) user_addr;
+		else
+			req->out.args[0].value = (void *) user_addr;
+
+		return 0;
+	}
+
+	nbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);
+	npages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	npages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);
+	npages = get_user_pages_fast(user_addr, npages, !write, req->pages);
+	if (npages < 0)
+		return npages;
+
+	req->num_pages = npages;
+	req->page_offset = offset;
+
+	if (write)
+		req->in.argpages = 1;
+	else
+		req->out.argpages = 1;
+
+	nbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;
+	*nbytesp = min(*nbytesp, nbytes);
+
+	return 0;
+}
+
+ssize_t fuse_direct_io(struct file *file, const char __user *buf,
+		       size_t count, loff_t *ppos, int write)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = ff->fc;
+	size_t nmax = write ? fc->max_write : fc->max_read;
+	loff_t pos = *ppos;
+	ssize_t res = 0;
+	struct fuse_req *req;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	while (count) {
+		size_t nres;
+		fl_owner_t owner = current->files;
+		size_t nbytes = min(count, nmax);
+		int err = fuse_get_user_pages(req, buf, &nbytes, write);
+		if (err) {
+			res = err;
+			break;
+		}
+
+		if (write)
+			nres = fuse_send_write(req, file, pos, nbytes, owner);
+		else
+			nres = fuse_send_read(req, file, pos, nbytes, owner);
+
+		fuse_release_user_pages(req, !write);
+		if (req->out.h.error) {
+			if (!res)
+				res = req->out.h.error;
+			break;
+		} else if (nres > nbytes) {
+			res = -EIO;
+			break;
+		}
+		count -= nres;
+		res += nres;
+		pos += nres;
+		buf += nres;
+		if (nres != nbytes)
+			break;
+		if (count) {
+			fuse_put_request(fc, req);
+			req = fuse_get_req(fc);
+			if (IS_ERR(req))
+				break;
+		}
+	}
+	if (!IS_ERR(req))
+		fuse_put_request(fc, req);
+	if (res > 0)
+		*ppos = pos;
+
+	return res;
+}
+EXPORT_SYMBOL_GPL(fuse_direct_io);
+
+static ssize_t fuse_direct_read(struct file *file, char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	ssize_t res;
+	struct inode *inode = file->f_path.dentry->d_inode;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	res = fuse_direct_io(file, buf, count, ppos, 0);
+
+	fuse_invalidate_attr(inode);
+
+	return res;
+}
+
+static ssize_t fuse_direct_write(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	ssize_t res;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	/* Don't allow parallel writes to the same file */
+	mutex_lock(&inode->i_mutex);
+	res = generic_write_checks(file, ppos, &count, 0);
+	if (!res) {
+		res = fuse_direct_io(file, buf, count, ppos, 1);
+		if (res > 0)
+			fuse_write_update_size(inode, *ppos);
+	}
+	mutex_unlock(&inode->i_mutex);
+
+	fuse_invalidate_attr(inode);
+
+	return res;
+}
+
+static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)
+{
+	__free_page(req->pages[0]);
+	fuse_file_put(req->ff, false);
+}
+
+static void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)
+{
+	struct inode *inode = req->inode;
+	struct fuse_inode *fi = get_fuse_inode(inode);
+	struct backing_dev_info *bdi = inode->i_mapping->backing_dev_info;
+
+	list_del(&req->writepages_entry);
+	dec_bdi_stat(bdi, BDI_WRITEBACK);
+	dec_zone_page_state(req->pages[0], NR_WRITEBACK_TEMP);
+	bdi_writeout_inc(bdi);
+	wake_up(&fi->page_waitq);
+}
+
+/* Called under fc->lock, may release and reacquire it */
+static void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	struct fuse_inode *fi = get_fuse_inode(req->inode);
+	loff_t size = i_size_read(req->inode);
+	struct fuse_write_in *inarg = &req->misc.write.in;
+
+	if (!fc->connected)
+		goto out_free;
+
+	if (inarg->offset + PAGE_CACHE_SIZE <= size) {
+		inarg->size = PAGE_CACHE_SIZE;
+	} else if (inarg->offset < size) {
+		inarg->size = size & (PAGE_CACHE_SIZE - 1);
+	} else {
+		/* Got truncated off completely */
+		goto out_free;
+	}
+
+	req->in.args[1].size = inarg->size;
+	fi->writectr++;
+	fuse_request_send_background_locked(fc, req);
+	return;
+
+ out_free:
+	fuse_writepage_finish(fc, req);
+	spin_unlock(&fc->lock);
+	fuse_writepage_free(fc, req);
+	fuse_put_request(fc, req);
+	spin_lock(&fc->lock);
+}
+
+/*
+ * If fi->writectr is positive (no truncate or fsync going on) send
+ * all queued writepage requests.
+ *
+ * Called with fc->lock
+ */
+void fuse_flush_writepages(struct inode *inode)
+__releases(fc->lock)
+__acquires(fc->lock)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+	struct fuse_req *req;
+
+	while (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {
+		req = list_entry(fi->queued_writes.next, struct fuse_req, list);
+		list_del_init(&req->list);
+		fuse_send_writepage(fc, req);
+	}
+}
+
+static void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)
+{
+	struct inode *inode = req->inode;
+	struct fuse_inode *fi = get_fuse_inode(inode);
+
+	mapping_set_error(inode->i_mapping, req->out.h.error);
+	spin_lock(&fc->lock);
+	fi->writectr--;
+	fuse_writepage_finish(fc, req);
+	spin_unlock(&fc->lock);
+	fuse_writepage_free(fc, req);
+}
+
+static int fuse_writepage_locked(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+	struct inode *inode = mapping->host;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+	struct fuse_req *req;
+	struct fuse_file *ff;
+	struct page *tmp_page;
+
+	set_page_writeback(page);
+
+	req = fuse_request_alloc_nofs();
+	if (!req)
+		goto err;
+
+	tmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);
+	if (!tmp_page)
+		goto err_free;
+
+	spin_lock(&fc->lock);
+	BUG_ON(list_empty(&fi->write_files));
+	ff = list_entry(fi->write_files.next, struct fuse_file, write_entry);
+	req->ff = fuse_file_get(ff);
+	spin_unlock(&fc->lock);
+
+	fuse_write_fill(req, ff, page_offset(page), 0);
+
+	copy_highpage(tmp_page, page);
+	req->misc.write.in.write_flags |= FUSE_WRITE_CACHE;
+	req->in.argpages = 1;
+	req->num_pages = 1;
+	req->pages[0] = tmp_page;
+	req->page_offset = 0;
+	req->end = fuse_writepage_end;
+	req->inode = inode;
+
+	inc_bdi_stat(mapping->backing_dev_info, BDI_WRITEBACK);
+	inc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);
+	end_page_writeback(page);
+
+	spin_lock(&fc->lock);
+	list_add(&req->writepages_entry, &fi->writepages);
+	list_add_tail(&req->list, &fi->queued_writes);
+	fuse_flush_writepages(inode);
+	spin_unlock(&fc->lock);
+
+	return 0;
+
+err_free:
+	fuse_request_free(req);
+err:
+	end_page_writeback(page);
+	return -ENOMEM;
+}
+
+static int fuse_writepage(struct page *page, struct writeback_control *wbc)
+{
+	int err;
+
+	err = fuse_writepage_locked(page);
+	unlock_page(page);
+
+	return err;
+}
+
+static int fuse_launder_page(struct page *page)
+{
+	int err = 0;
+	if (clear_page_dirty_for_io(page)) {
+		struct inode *inode = page->mapping->host;
+		err = fuse_writepage_locked(page);
+		if (!err)
+			fuse_wait_on_page_writeback(inode, page->index);
+	}
+	return err;
+}
+
+/*
+ * Write back dirty pages now, because there may not be any suitable
+ * open files later
+ */
+static void fuse_vma_close(struct vm_area_struct *vma)
+{
+	filemap_write_and_wait(vma->vm_file->f_mapping);
+}
+
+/*
+ * Wait for writeback against this page to complete before allowing it
+ * to be marked dirty again, and hence written back again, possibly
+ * before the previous writepage completed.
+ *
+ * Block here, instead of in ->writepage(), so that the userspace fs
+ * can only block processes actually operating on the filesystem.
+ *
+ * Otherwise unprivileged userspace fs would be able to block
+ * unrelated:
+ *
+ * - page migration
+ * - sync(2)
+ * - try_to_free_pages() with order > PAGE_ALLOC_COSTLY_ORDER
+ */
+static int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	struct page *page = vmf->page;
+	/*
+	 * Don't use page->mapping as it may become NULL from a
+	 * concurrent truncate.
+	 */
+	struct inode *inode = vma->vm_file->f_mapping->host;
+
+	fuse_wait_on_page_writeback(inode, page->index);
+	return 0;
+}
+
+static const struct vm_operations_struct fuse_file_vm_ops = {
+	.close		= fuse_vma_close,
+	.fault		= filemap_fault,
+	.page_mkwrite	= fuse_page_mkwrite,
+};
+
+static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE)) {
+		struct inode *inode = file->f_dentry->d_inode;
+		struct fuse_conn *fc = get_fuse_conn(inode);
+		struct fuse_inode *fi = get_fuse_inode(inode);
+		struct fuse_file *ff = file->private_data;
+		/*
+		 * file may be written through mmap, so chain it onto the
+		 * inodes's write_file list
+		 */
+		spin_lock(&fc->lock);
+		if (list_empty(&ff->write_entry))
+			list_add(&ff->write_entry, &fi->write_files);
+		spin_unlock(&fc->lock);
+	}
+	file_accessed(file);
+	vma->vm_ops = &fuse_file_vm_ops;
+	return 0;
+}
+
+static int fuse_direct_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	/* Can't provide the coherency needed for MAP_SHARED */
+	if (vma->vm_flags & VM_MAYSHARE)
+		return -ENODEV;
+
+	invalidate_inode_pages2(file->f_mapping);
+
+	return generic_file_mmap(file, vma);
+}
+
+static int convert_fuse_file_lock(const struct fuse_file_lock *ffl,
+				  struct file_lock *fl)
+{
+	switch (ffl->type) {
+	case F_UNLCK:
+		break;
+
+	case F_RDLCK:
+	case F_WRLCK:
+		if (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||
+		    ffl->end < ffl->start)
+			return -EIO;
+
+		fl->fl_start = ffl->start;
+		fl->fl_end = ffl->end;
+		fl->fl_pid = ffl->pid;
+		break;
+
+	default:
+		return -EIO;
+	}
+	fl->fl_type = ffl->type;
+	return 0;
+}
+
+static void fuse_lk_fill(struct fuse_req *req, struct file *file,
+			 const struct file_lock *fl, int opcode, pid_t pid,
+			 int flock)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_file *ff = file->private_data;
+	struct fuse_lk_in *arg = &req->misc.lk_in;
+
+	arg->fh = ff->fh;
+	arg->owner = fuse_lock_owner_id(fc, fl->fl_owner);
+	arg->lk.start = fl->fl_start;
+	arg->lk.end = fl->fl_end;
+	arg->lk.type = fl->fl_type;
+	arg->lk.pid = pid;
+	if (flock)
+		arg->lk_flags |= FUSE_LK_FLOCK;
+	req->in.h.opcode = opcode;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(*arg);
+	req->in.args[0].value = arg;
+}
+
+static int fuse_getlk(struct file *file, struct file_lock *fl)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	struct fuse_lk_out outarg;
+	int err;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	fuse_lk_fill(req, file, fl, FUSE_GETLK, 0, 0);
+	req->out.numargs = 1;
+	req->out.args[0].size = sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (!err)
+		err = convert_fuse_file_lock(&outarg.lk, fl);
+
+	return err;
+}
+
+static int fuse_setlk(struct file *file, struct file_lock *fl, int flock)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	int opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;
+	pid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;
+	int err;
+
+	if (fl->fl_lmops && fl->fl_lmops->fl_grant) {
+		/* NLM needs asynchronous locks, which we don't support yet */
+		return -ENOLCK;
+	}
+
+	/* Unlock on close is handled by the flush method */
+	if (fl->fl_flags & FL_CLOSE)
+		return 0;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	fuse_lk_fill(req, file, fl, opcode, pid, flock);
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	/* locking is restartable */
+	if (err == -EINTR)
+		err = -ERESTARTSYS;
+	fuse_put_request(fc, req);
+	return err;
+}
+
+static int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	int err;
+
+	if (cmd == F_CANCELLK) {
+		err = 0;
+	} else if (cmd == F_GETLK) {
+		if (fc->no_lock) {
+			posix_test_lock(file, fl);
+			err = 0;
+		} else
+			err = fuse_getlk(file, fl);
+	} else {
+		if (fc->no_lock)
+			err = posix_lock_file(file, fl, NULL);
+		else
+			err = fuse_setlk(file, fl, 0);
+	}
+	return err;
+}
+
+static int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	int err;
+
+	if (fc->no_lock) {
+		err = flock_lock_file_wait(file, fl);
+	} else {
+		/* emulate flock with POSIX locks */
+		fl->fl_owner = (fl_owner_t) file;
+		err = fuse_setlk(file, fl, 1);
+	}
+
+	return err;
+}
+
+static sector_t fuse_bmap(struct address_space *mapping, sector_t block)
+{
+	struct inode *inode = mapping->host;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_req *req;
+	struct fuse_bmap_in inarg;
+	struct fuse_bmap_out outarg;
+	int err;
+
+	if (!inode->i_sb->s_bdev || fc->no_bmap)
+		return 0;
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return 0;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.block = block;
+	inarg.blocksize = inode->i_sb->s_blocksize;
+	req->in.h.opcode = FUSE_BMAP;
+	req->in.h.nodeid = get_node_id(inode);
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->out.numargs = 1;
+	req->out.args[0].size = sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+	if (err == -ENOSYS)
+		fc->no_bmap = 1;
+
+	return err ? 0 : outarg.block;
+}
+
+static loff_t fuse_file_llseek(struct file *file, loff_t offset, int origin)
+{
+	loff_t retval;
+	struct inode *inode = file->f_path.dentry->d_inode;
+
+	mutex_lock(&inode->i_mutex);
+	switch (origin) {
+	case SEEK_END:
+		retval = fuse_update_attributes(inode, NULL, file, NULL);
+		if (retval)
+			goto exit;
+		offset += i_size_read(inode);
+		break;
+	case SEEK_CUR:
+		offset += file->f_pos;
+	}
+	retval = -EINVAL;
+	if (offset >= 0 && offset <= inode->i_sb->s_maxbytes) {
+		if (offset != file->f_pos) {
+			file->f_pos = offset;
+			file->f_version = 0;
+		}
+		retval = offset;
+	}
+exit:
+	mutex_unlock(&inode->i_mutex);
+	return retval;
+}
+
+static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,
+			unsigned int nr_segs, size_t bytes, bool to_user)
+{
+	struct iov_iter ii;
+	int page_idx = 0;
+
+	if (!bytes)
+		return 0;
+
+	iov_iter_init(&ii, iov, nr_segs, bytes, 0);
+
+	while (iov_iter_count(&ii)) {
+		struct page *page = pages[page_idx++];
+		size_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));
+		void *kaddr;
+
+		kaddr = kmap(page);
+
+		while (todo) {
+			char __user *uaddr = ii.iov->iov_base + ii.iov_offset;
+			size_t iov_len = ii.iov->iov_len - ii.iov_offset;
+			size_t copy = min(todo, iov_len);
+			size_t left;
+
+			if (!to_user)
+				left = copy_from_user(kaddr, uaddr, copy);
+			else
+				left = copy_to_user(uaddr, kaddr, copy);
+
+			if (unlikely(left))
+				return -EFAULT;
+
+			iov_iter_advance(&ii, copy);
+			todo -= copy;
+			kaddr += copy;
+		}
+
+		kunmap(page);
+	}
+
+	return 0;
+}
+
+/*
+ * CUSE servers compiled on 32bit broke on 64bit kernels because the
+ * ABI was defined to be 'struct iovec' which is different on 32bit
+ * and 64bit.  Fortunately we can determine which structure the server
+ * used from the size of the reply.
+ */
+static int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,
+				     size_t transferred, unsigned count,
+				     bool is_compat)
+{
+#ifdef CONFIG_COMPAT
+	if (count * sizeof(struct compat_iovec) == transferred) {
+		struct compat_iovec *ciov = src;
+		unsigned i;
+
+		/*
+		 * With this interface a 32bit server cannot support
+		 * non-compat (i.e. ones coming from 64bit apps) ioctl
+		 * requests
+		 */
+		if (!is_compat)
+			return -EINVAL;
+
+		for (i = 0; i < count; i++) {
+			dst[i].iov_base = compat_ptr(ciov[i].iov_base);
+			dst[i].iov_len = ciov[i].iov_len;
+		}
+		return 0;
+	}
+#endif
+
+	if (count * sizeof(struct iovec) != transferred)
+		return -EIO;
+
+	memcpy(dst, src, transferred);
+	return 0;
+}
+
+/* Make sure iov_length() won't overflow */
+static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)
+{
+	size_t n;
+	u32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;
+
+	for (n = 0; n < count; n++) {
+		if (iov->iov_len > (size_t) max)
+			return -ENOMEM;
+		max -= iov->iov_len;
+	}
+	return 0;
+}
+
+static int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,
+				 void *src, size_t transferred, unsigned count,
+				 bool is_compat)
+{
+	unsigned i;
+	struct fuse_ioctl_iovec *fiov = src;
+
+	if (fc->minor < 16) {
+		return fuse_copy_ioctl_iovec_old(dst, src, transferred,
+						 count, is_compat);
+	}
+
+	if (count * sizeof(struct fuse_ioctl_iovec) != transferred)
+		return -EIO;
+
+	for (i = 0; i < count; i++) {
+		/* Did the server supply an inappropriate value? */
+		if (fiov[i].base != (unsigned long) fiov[i].base ||
+		    fiov[i].len != (unsigned long) fiov[i].len)
+			return -EIO;
+
+		dst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;
+		dst[i].iov_len = (size_t) fiov[i].len;
+
+#ifdef CONFIG_COMPAT
+		if (is_compat &&
+		    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||
+		     (compat_size_t) dst[i].iov_len != fiov[i].len))
+			return -EIO;
+#endif
+	}
+
+	return 0;
+}
+
+
+/*
+ * For ioctls, there is no generic way to determine how much memory
+ * needs to be read and/or written.  Furthermore, ioctls are allowed
+ * to dereference the passed pointer, so the parameter requires deep
+ * copying but FUSE has no idea whatsoever about what to copy in or
+ * out.
+ *
+ * This is solved by allowing FUSE server to retry ioctl with
+ * necessary in/out iovecs.  Let's assume the ioctl implementation
+ * needs to read in the following structure.
+ *
+ * struct a {
+ *	char	*buf;
+ *	size_t	buflen;
+ * }
+ *
+ * On the first callout to FUSE server, inarg->in_size and
+ * inarg->out_size will be NULL; then, the server completes the ioctl
+ * with FUSE_IOCTL_RETRY set in out->flags, out->in_iovs set to 1 and
+ * the actual iov array to
+ *
+ * { { .iov_base = inarg.arg,	.iov_len = sizeof(struct a) } }
+ *
+ * which tells FUSE to copy in the requested area and retry the ioctl.
+ * On the second round, the server has access to the structure and
+ * from that it can tell what to look for next, so on the invocation,
+ * it sets FUSE_IOCTL_RETRY, out->in_iovs to 2 and iov array to
+ *
+ * { { .iov_base = inarg.arg,	.iov_len = sizeof(struct a)	},
+ *   { .iov_base = a.buf,	.iov_len = a.buflen		} }
+ *
+ * FUSE will copy both struct a and the pointed buffer from the
+ * process doing the ioctl and retry ioctl with both struct a and the
+ * buffer.
+ *
+ * This time, FUSE server has everything it needs and completes ioctl
+ * without FUSE_IOCTL_RETRY which finishes the ioctl call.
+ *
+ * Copying data out works the same way.
+ *
+ * Note that if FUSE_IOCTL_UNRESTRICTED is clear, the kernel
+ * automatically initializes in and out iovs by decoding @cmd with
+ * _IOC_* macros and the server is not allowed to request RETRY.  This
+ * limits ioctl data transfers to well-formed ioctls and is the forced
+ * behavior for all FUSE servers.
+ */
+long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
+		   unsigned int flags)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = ff->fc;
+	struct fuse_ioctl_in inarg = {
+		.fh = ff->fh,
+		.cmd = cmd,
+		.arg = arg,
+		.flags = flags
+	};
+	struct fuse_ioctl_out outarg;
+	struct fuse_req *req = NULL;
+	struct page **pages = NULL;
+	struct iovec *iov_page = NULL;
+	struct iovec *in_iov = NULL, *out_iov = NULL;
+	unsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;
+	size_t in_size, out_size, transferred;
+	int err;
+
+#if BITS_PER_LONG == 32
+	inarg.flags |= FUSE_IOCTL_32BIT;
+#else
+	if (flags & FUSE_IOCTL_COMPAT)
+		inarg.flags |= FUSE_IOCTL_32BIT;
+#endif
+
+	/* assume all the iovs returned by client always fits in a page */
+	BUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);
+
+	err = -ENOMEM;
+	pages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);
+	iov_page = (struct iovec *) __get_free_page(GFP_KERNEL);
+	if (!pages || !iov_page)
+		goto out;
+
+	/*
+	 * If restricted, initialize IO parameters as encoded in @cmd.
+	 * RETRY from server is not allowed.
+	 */
+	if (!(flags & FUSE_IOCTL_UNRESTRICTED)) {
+		struct iovec *iov = iov_page;
+
+		iov->iov_base = (void __user *)arg;
+		iov->iov_len = _IOC_SIZE(cmd);
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			in_iov = iov;
+			in_iovs = 1;
+		}
+
+		if (_IOC_DIR(cmd) & _IOC_READ) {
+			out_iov = iov;
+			out_iovs = 1;
+		}
+	}
+
+ retry:
+	inarg.in_size = in_size = iov_length(in_iov, in_iovs);
+	inarg.out_size = out_size = iov_length(out_iov, out_iovs);
+
+	/*
+	 * Out data can be used either for actual out data or iovs,
+	 * make sure there always is at least one page.
+	 */
+	out_size = max_t(size_t, out_size, PAGE_SIZE);
+	max_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);
+
+	/* make sure there are enough buffer pages and init request with them */
+	err = -ENOMEM;
+	if (max_pages > FUSE_MAX_PAGES_PER_REQ)
+		goto out;
+	while (num_pages < max_pages) {
+		pages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
+		if (!pages[num_pages])
+			goto out;
+		num_pages++;
+	}
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req)) {
+		err = PTR_ERR(req);
+		req = NULL;
+		goto out;
+	}
+	memcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);
+	req->num_pages = num_pages;
+
+	/* okay, let's send it to the client */
+	req->in.h.opcode = FUSE_IOCTL;
+	req->in.h.nodeid = ff->nodeid;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	if (in_size) {
+		req->in.numargs++;
+		req->in.args[1].size = in_size;
+		req->in.argpages = 1;
+
+		err = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,
+					   false);
+		if (err)
+			goto out;
+	}
+
+	req->out.numargs = 2;
+	req->out.args[0].size = sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	req->out.args[1].size = out_size;
+	req->out.argpages = 1;
+	req->out.argvar = 1;
+
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	transferred = req->out.args[1].size;
+	fuse_put_request(fc, req);
+	req = NULL;
+	if (err)
+		goto out;
+
+	/* did it ask for retry? */
+	if (outarg.flags & FUSE_IOCTL_RETRY) {
+		void *vaddr;
+
+		/* no retry if in restricted mode */
+		err = -EIO;
+		if (!(flags & FUSE_IOCTL_UNRESTRICTED))
+			goto out;
+
+		in_iovs = outarg.in_iovs;
+		out_iovs = outarg.out_iovs;
+
+		/*
+		 * Make sure things are in boundary, separate checks
+		 * are to protect against overflow.
+		 */
+		err = -ENOMEM;
+		if (in_iovs > FUSE_IOCTL_MAX_IOV ||
+		    out_iovs > FUSE_IOCTL_MAX_IOV ||
+		    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)
+			goto out;
+
+		vaddr = kmap_atomic(pages[0], KM_USER0);
+		err = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,
+					    transferred, in_iovs + out_iovs,
+					    (flags & FUSE_IOCTL_COMPAT) != 0);
+		kunmap_atomic(vaddr, KM_USER0);
+		if (err)
+			goto out;
+
+		in_iov = iov_page;
+		out_iov = in_iov + in_iovs;
+
+		err = fuse_verify_ioctl_iov(in_iov, in_iovs);
+		if (err)
+			goto out;
+
+		err = fuse_verify_ioctl_iov(out_iov, out_iovs);
+		if (err)
+			goto out;
+
+		goto retry;
+	}
+
+	err = -EIO;
+	if (transferred > inarg.out_size)
+		goto out;
+
+	err = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);
+ out:
+	if (req)
+		fuse_put_request(fc, req);
+	free_page((unsigned long) iov_page);
+	while (num_pages)
+		__free_page(pages[--num_pages]);
+	kfree(pages);
+
+	return err ? err : outarg.result;
+}
+EXPORT_SYMBOL_GPL(fuse_do_ioctl);
+
+static long fuse_file_ioctl_common(struct file *file, unsigned int cmd,
+				   unsigned long arg, unsigned int flags)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(inode);
+
+	if (!fuse_allow_task(fc, current))
+		return -EACCES;
+
+	if (is_bad_inode(inode))
+		return -EIO;
+
+	return fuse_do_ioctl(file, cmd, arg, flags);
+}
+
+static long fuse_file_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	return fuse_file_ioctl_common(file, cmd, arg, 0);
+}
+
+static long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,
+				   unsigned long arg)
+{
+	return fuse_file_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);
+}
+
+/*
+ * All files which have been polled are linked to RB tree
+ * fuse_conn->polled_files which is indexed by kh.  Walk the tree and
+ * find the matching one.
+ */
+static struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,
+					      struct rb_node **parent_out)
+{
+	struct rb_node **link = &fc->polled_files.rb_node;
+	struct rb_node *last = NULL;
+
+	while (*link) {
+		struct fuse_file *ff;
+
+		last = *link;
+		ff = rb_entry(last, struct fuse_file, polled_node);
+
+		if (kh < ff->kh)
+			link = &last->rb_left;
+		else if (kh > ff->kh)
+			link = &last->rb_right;
+		else
+			return link;
+	}
+
+	if (parent_out)
+		*parent_out = last;
+	return link;
+}
+
+/*
+ * The file is about to be polled.  Make sure it's on the polled_files
+ * RB tree.  Note that files once added to the polled_files tree are
+ * not removed before the file is released.  This is because a file
+ * polled once is likely to be polled again.
+ */
+static void fuse_register_polled_file(struct fuse_conn *fc,
+				      struct fuse_file *ff)
+{
+	spin_lock(&fc->lock);
+	if (RB_EMPTY_NODE(&ff->polled_node)) {
+		struct rb_node **link, *parent;
+
+		link = fuse_find_polled_node(fc, ff->kh, &parent);
+		BUG_ON(*link);
+		rb_link_node(&ff->polled_node, parent, link);
+		rb_insert_color(&ff->polled_node, &fc->polled_files);
+	}
+	spin_unlock(&fc->lock);
+}
+
+unsigned fuse_file_poll(struct file *file, poll_table *wait)
+{
+	struct fuse_file *ff = file->private_data;
+	struct fuse_conn *fc = ff->fc;
+	struct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };
+	struct fuse_poll_out outarg;
+	struct fuse_req *req;
+	int err;
+
+	if (fc->no_poll)
+		return DEFAULT_POLLMASK;
+
+	poll_wait(file, &ff->poll_wait, wait);
+
+	/*
+	 * Ask for notification iff there's someone waiting for it.
+	 * The client may ignore the flag and always notify.
+	 */
+	if (waitqueue_active(&ff->poll_wait)) {
+		inarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;
+		fuse_register_polled_file(fc, ff);
+	}
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return POLLERR;
+
+	req->in.h.opcode = FUSE_POLL;
+	req->in.h.nodeid = ff->nodeid;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].value = &inarg;
+	req->out.numargs = 1;
+	req->out.args[0].size = sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	fuse_put_request(fc, req);
+
+	if (!err)
+		return outarg.revents;
+	if (err == -ENOSYS) {
+		fc->no_poll = 1;
+		return DEFAULT_POLLMASK;
+	}
+	return POLLERR;
+}
+EXPORT_SYMBOL_GPL(fuse_file_poll);
+
+/*
+ * This is called from fuse_handle_notify() on FUSE_NOTIFY_POLL and
+ * wakes up the poll waiters.
+ */
+int fuse_notify_poll_wakeup(struct fuse_conn *fc,
+			    struct fuse_notify_poll_wakeup_out *outarg)
+{
+	u64 kh = outarg->kh;
+	struct rb_node **link;
+
+	spin_lock(&fc->lock);
+
+	link = fuse_find_polled_node(fc, kh, NULL);
+	if (*link) {
+		struct fuse_file *ff;
+
+		ff = rb_entry(*link, struct fuse_file, polled_node);
+		wake_up_interruptible_sync(&ff->poll_wait);
+	}
+
+	spin_unlock(&fc->lock);
+	return 0;
+}
+
+static const struct file_operations fuse_file_operations = {
+	.llseek		= fuse_file_llseek,
+	.read		= do_sync_read,
+	.aio_read	= fuse_file_aio_read,
+	.write		= do_sync_write,
+	.aio_write	= fuse_file_aio_write,
+	.mmap		= fuse_file_mmap,
+	.open		= fuse_open,
+	.flush		= fuse_flush,
+	.release	= fuse_release,
+	.fsync		= fuse_fsync,
+	.lock		= fuse_file_lock,
+	.flock		= fuse_file_flock,
+	.splice_read	= generic_file_splice_read,
+	.unlocked_ioctl	= fuse_file_ioctl,
+	.compat_ioctl	= fuse_file_compat_ioctl,
+	.poll		= fuse_file_poll,
+};
+
+static const struct file_operations fuse_direct_io_file_operations = {
+	.llseek		= fuse_file_llseek,
+	.read		= fuse_direct_read,
+	.write		= fuse_direct_write,
+	.mmap		= fuse_direct_mmap,
+	.open		= fuse_open,
+	.flush		= fuse_flush,
+	.release	= fuse_release,
+	.fsync		= fuse_fsync,
+	.lock		= fuse_file_lock,
+	.flock		= fuse_file_flock,
+	.unlocked_ioctl	= fuse_file_ioctl,
+	.compat_ioctl	= fuse_file_compat_ioctl,
+	.poll		= fuse_file_poll,
+	/* no splice_read */
+};
+
+static const struct address_space_operations fuse_file_aops  = {
+	.readpage	= fuse_readpage,
+	.writepage	= fuse_writepage,
+	.launder_page	= fuse_launder_page,
+	.write_begin	= fuse_write_begin,
+	.write_end	= fuse_write_end,
+	.readpages	= fuse_readpages,
+	.set_page_dirty	= __set_page_dirty_nobuffers,
+	.bmap		= fuse_bmap,
+};
+
+void fuse_init_file_inode(struct inode *inode)
+{
+	inode->i_fop = &fuse_file_operations;
+	inode->i_data.a_ops = &fuse_file_aops;
+}
Index: fuse-2.8.5/kernel/fuse_i.h
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/fuse_i.h
@@ -0,0 +1,766 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+*/
+
+#ifndef _FS_FUSE_I_H
+#define _FS_FUSE_I_H
+
+#include <linux/fuse.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/backing-dev.h>
+#include <linux/mutex.h>
+#include <linux/rwsem.h>
+#include <linux/rbtree.h>
+#include <linux/poll.h>
+#include <linux/workqueue.h>
+
+/** Max number of pages that can be used in a single read request */
+#define FUSE_MAX_PAGES_PER_REQ 32
+
+/** Bias for fi->writectr, meaning new writepages must not be sent */
+#define FUSE_NOWRITE INT_MIN
+
+/** It could be as large as PATH_MAX, but would that have any uses? */
+#define FUSE_NAME_MAX 1024
+
+/** Number of dentries for each connection in the control filesystem */
+#define FUSE_CTL_NUM_DENTRIES 5
+
+/** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
+    module will check permissions based on the file mode.  Otherwise no
+    permission checking is done in the kernel */
+#define FUSE_DEFAULT_PERMISSIONS (1 << 0)
+
+/** If the FUSE_ALLOW_OTHER flag is given, then not only the user
+    doing the mount will be allowed to access the filesystem */
+#define FUSE_ALLOW_OTHER         (1 << 1)
+
+/** List of active connections */
+extern struct list_head fuse_conn_list;
+
+/** Global mutex protecting fuse_conn_list and the control filesystem */
+extern struct mutex fuse_mutex;
+
+/** Module parameters */
+extern unsigned max_user_bgreq;
+extern unsigned max_user_congthresh;
+
+/* One forget request */
+struct fuse_forget_link {
+	struct fuse_forget_one forget_one;
+	struct fuse_forget_link *next;
+};
+
+/** FUSE inode */
+struct fuse_inode {
+	/** Inode data */
+	struct inode inode;
+
+	/** Unique ID, which identifies the inode between userspace
+	 * and kernel */
+	u64 nodeid;
+
+	/** Number of lookups on this inode */
+	u64 nlookup;
+
+	/** The request used for sending the FORGET message */
+	struct fuse_forget_link *forget;
+
+	/** Time in jiffies until the file attributes are valid */
+	u64 i_time;
+
+	/** The sticky bit in inode->i_mode may have been removed, so
+	    preserve the original mode */
+	mode_t orig_i_mode;
+
+	/** Version of last attribute change */
+	u64 attr_version;
+
+	/** Files usable in writepage.  Protected by fc->lock */
+	struct list_head write_files;
+
+	/** Writepages pending on truncate or fsync */
+	struct list_head queued_writes;
+
+	/** Number of sent writes, a negative bias (FUSE_NOWRITE)
+	 * means more writes are blocked */
+	int writectr;
+
+	/** Waitq for writepage completion */
+	wait_queue_head_t page_waitq;
+
+	/** List of writepage requestst (pending or sent) */
+	struct list_head writepages;
+};
+
+struct fuse_conn;
+
+/** FUSE specific file data */
+struct fuse_file {
+	/** Fuse connection for this file */
+	struct fuse_conn *fc;
+
+	/** Request reserved for flush and release */
+	struct fuse_req *reserved_req;
+
+	/** Kernel file handle guaranteed to be unique */
+	u64 kh;
+
+	/** File handle used by userspace */
+	u64 fh;
+
+	/** Node id of this file */
+	u64 nodeid;
+
+	/** Refcount */
+	atomic_t count;
+
+	/** FOPEN_* flags returned by open */
+	u32 open_flags;
+
+	/** Entry on inode's write_files list */
+	struct list_head write_entry;
+
+	/** RB node to be linked on fuse_conn->polled_files */
+	struct rb_node polled_node;
+
+	/** Wait queue head for poll */
+	wait_queue_head_t poll_wait;
+};
+
+/** One input argument of a request */
+struct fuse_in_arg {
+	unsigned size;
+	const void *value;
+};
+
+/** The request input */
+struct fuse_in {
+	/** The request header */
+	struct fuse_in_header h;
+
+	/** True if the data for the last argument is in req->pages */
+	unsigned argpages:1;
+
+	/** Number of arguments */
+	unsigned numargs;
+
+	/** Array of arguments */
+	struct fuse_in_arg args[3];
+};
+
+/** One output argument of a request */
+struct fuse_arg {
+	unsigned size;
+	void *value;
+};
+
+/** The request output */
+struct fuse_out {
+	/** Header returned from userspace */
+	struct fuse_out_header h;
+
+	/*
+	 * The following bitfields are not changed during the request
+	 * processing
+	 */
+
+	/** Last argument is variable length (can be shorter than
+	    arg->size) */
+	unsigned argvar:1;
+
+	/** Last argument is a list of pages to copy data to */
+	unsigned argpages:1;
+
+	/** Zero partially or not copied pages */
+	unsigned page_zeroing:1;
+
+	/** Pages may be replaced with new ones */
+	unsigned page_replace:1;
+
+	/** Number or arguments */
+	unsigned numargs;
+
+	/** Array of arguments */
+	struct fuse_arg args[3];
+};
+
+/** The request state */
+enum fuse_req_state {
+	FUSE_REQ_INIT = 0,
+	FUSE_REQ_PENDING,
+	FUSE_REQ_READING,
+	FUSE_REQ_SENT,
+	FUSE_REQ_WRITING,
+	FUSE_REQ_FINISHED
+};
+
+/**
+ * A request to the client
+ */
+struct fuse_req {
+	/** This can be on either pending processing or io lists in
+	    fuse_conn */
+	struct list_head list;
+
+	/** Entry on the interrupts list  */
+	struct list_head intr_entry;
+
+	/** refcount */
+	atomic_t count;
+
+	/** Unique ID for the interrupt request */
+	u64 intr_unique;
+
+	/*
+	 * The following bitfields are either set once before the
+	 * request is queued or setting/clearing them is protected by
+	 * fuse_conn->lock
+	 */
+
+	/** True if the request has reply */
+	unsigned isreply:1;
+
+	/** Force sending of the request even if interrupted */
+	unsigned force:1;
+
+	/** The request was aborted */
+	unsigned aborted:1;
+
+	/** Request is sent in the background */
+	unsigned background:1;
+
+	/** The request has been interrupted */
+	unsigned interrupted:1;
+
+	/** Data is being copied to/from the request */
+	unsigned locked:1;
+
+	/** Request is counted as "waiting" */
+	unsigned waiting:1;
+
+	/** State of the request */
+	enum fuse_req_state state;
+
+	/** The request input */
+	struct fuse_in in;
+
+	/** The request output */
+	struct fuse_out out;
+
+	/** Used to wake up the task waiting for completion of request*/
+	wait_queue_head_t waitq;
+
+	/** Data for asynchronous requests */
+	union {
+		struct {
+			union {
+				struct fuse_release_in in;
+				struct work_struct work;
+			};
+			struct path path;
+		} release;
+		struct fuse_init_in init_in;
+		struct fuse_init_out init_out;
+		struct cuse_init_in cuse_init_in;
+		struct {
+			struct fuse_read_in in;
+			u64 attr_ver;
+		} read;
+		struct {
+			struct fuse_write_in in;
+			struct fuse_write_out out;
+		} write;
+		struct fuse_notify_retrieve_in retrieve_in;
+		struct fuse_lk_in lk_in;
+	} misc;
+
+	/** page vector */
+	struct page *pages[FUSE_MAX_PAGES_PER_REQ];
+
+	/** number of pages in vector */
+	unsigned num_pages;
+
+	/** offset of data on first page */
+	unsigned page_offset;
+
+	/** File used in the request (or NULL) */
+	struct fuse_file *ff;
+
+	/** Inode used in the request or NULL */
+	struct inode *inode;
+
+	/** Link on fi->writepages */
+	struct list_head writepages_entry;
+
+	/** Request completion callback */
+	void (*end)(struct fuse_conn *, struct fuse_req *);
+
+	/** Request is stolen from fuse_file->reserved_req */
+	struct file *stolen_file;
+};
+
+/**
+ * A Fuse connection.
+ *
+ * This structure is created, when the filesystem is mounted, and is
+ * destroyed, when the client device is closed and the filesystem is
+ * unmounted.
+ */
+struct fuse_conn {
+	/** Lock protecting accessess to  members of this structure */
+	spinlock_t lock;
+
+	/** Mutex protecting against directory alias creation */
+	struct mutex inst_mutex;
+
+	/** Refcount */
+	atomic_t count;
+
+	/** The user id for this mount */
+	uid_t user_id;
+
+	/** The group id for this mount */
+	gid_t group_id;
+
+	/** The fuse mount flags for this mount */
+	unsigned flags;
+
+	/** Maximum read size */
+	unsigned max_read;
+
+	/** Maximum write size */
+	unsigned max_write;
+
+	/** Readers of the connection are waiting on this */
+	wait_queue_head_t waitq;
+
+	/** The list of pending requests */
+	struct list_head pending;
+
+	/** The list of requests being processed */
+	struct list_head processing;
+
+	/** The list of requests under I/O */
+	struct list_head io;
+
+	/** The next unique kernel file handle */
+	u64 khctr;
+
+	/** rbtree of fuse_files waiting for poll events indexed by ph */
+	struct rb_root polled_files;
+
+	/** Maximum number of outstanding background requests */
+	unsigned max_background;
+
+	/** Number of background requests at which congestion starts */
+	unsigned congestion_threshold;
+
+	/** Number of requests currently in the background */
+	unsigned num_background;
+
+	/** Number of background requests currently queued for userspace */
+	unsigned active_background;
+
+	/** The list of background requests set aside for later queuing */
+	struct list_head bg_queue;
+
+	/** Pending interrupts */
+	struct list_head interrupts;
+
+	/** Queue of pending forgets */
+	struct fuse_forget_link forget_list_head;
+	struct fuse_forget_link *forget_list_tail;
+
+	/** Batching of FORGET requests (positive indicates FORGET batch) */
+	int forget_batch;
+
+	/** Flag indicating if connection is blocked.  This will be
+	    the case before the INIT reply is received, and if there
+	    are too many outstading backgrounds requests */
+	int blocked;
+
+	/** waitq for blocked connection */
+	wait_queue_head_t blocked_waitq;
+
+	/** waitq for reserved requests */
+	wait_queue_head_t reserved_req_waitq;
+
+	/** The next unique request id */
+	u64 reqctr;
+
+	/** Connection established, cleared on umount, connection
+	    abort and device release */
+	unsigned connected;
+
+	/** Connection failed (version mismatch).  Cannot race with
+	    setting other bitfields since it is only set once in INIT
+	    reply, before any other request, and never cleared */
+	unsigned conn_error:1;
+
+	/** Connection successful.  Only set in INIT */
+	unsigned conn_init:1;
+
+	/** Do readpages asynchronously?  Only set in INIT */
+	unsigned async_read:1;
+
+	/** Do not send separate SETATTR request before open(O_TRUNC)  */
+	unsigned atomic_o_trunc:1;
+
+	/** Filesystem supports NFS exporting.  Only set in INIT */
+	unsigned export_support:1;
+
+	/** Set if bdi is valid */
+	unsigned bdi_initialized:1;
+
+	/*
+	 * The following bitfields are only for optimization purposes
+	 * and hence races in setting them will not cause malfunction
+	 */
+
+	/** Is fsync not implemented by fs? */
+	unsigned no_fsync:1;
+
+	/** Is fsyncdir not implemented by fs? */
+	unsigned no_fsyncdir:1;
+
+	/** Is flush not implemented by fs? */
+	unsigned no_flush:1;
+
+	/** Is setxattr not implemented by fs? */
+	unsigned no_setxattr:1;
+
+	/** Is getxattr not implemented by fs? */
+	unsigned no_getxattr:1;
+
+	/** Is listxattr not implemented by fs? */
+	unsigned no_listxattr:1;
+
+	/** Is removexattr not implemented by fs? */
+	unsigned no_removexattr:1;
+
+	/** Are file locking primitives not implemented by fs? */
+	unsigned no_lock:1;
+
+	/** Is access not implemented by fs? */
+	unsigned no_access:1;
+
+	/** Is create not implemented by fs? */
+	unsigned no_create:1;
+
+	/** Is interrupt not implemented by fs? */
+	unsigned no_interrupt:1;
+
+	/** Is bmap not implemented by fs? */
+	unsigned no_bmap:1;
+
+	/** Is poll not implemented by fs? */
+	unsigned no_poll:1;
+
+	/** Do multi-page cached writes */
+	unsigned big_writes:1;
+
+	/** Don't apply umask to creation modes */
+	unsigned dont_mask:1;
+
+	/** The number of requests waiting for completion */
+	atomic_t num_waiting;
+
+	/** Negotiated minor version */
+	unsigned minor;
+
+	/** Backing dev info */
+	struct backing_dev_info bdi;
+
+	/** Entry on the fuse_conn_list */
+	struct list_head entry;
+
+	/** Device ID from super block */
+	dev_t dev;
+
+	/** Dentries in the control filesystem */
+	struct dentry *ctl_dentry[FUSE_CTL_NUM_DENTRIES];
+
+	/** number of dentries used in the above array */
+	int ctl_ndents;
+
+	/** O_ASYNC requests */
+	struct fasync_struct *fasync;
+
+	/** Key for lock owner ID scrambling */
+	u32 scramble_key[4];
+
+	/** Reserved request for the DESTROY message */
+	struct fuse_req *destroy_req;
+
+	/** Version counter for attribute changes */
+	u64 attr_version;
+
+	/** Called on final put */
+	void (*release)(struct fuse_conn *);
+
+	/** Super block for this connection. */
+	struct super_block *sb;
+
+	/** Read/write semaphore to hold when accessing sb. */
+	struct rw_semaphore killsb;
+};
+
+static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+static inline struct fuse_conn *get_fuse_conn(struct inode *inode)
+{
+	return get_fuse_conn_super(inode->i_sb);
+}
+
+static inline struct fuse_inode *get_fuse_inode(struct inode *inode)
+{
+	return container_of(inode, struct fuse_inode, inode);
+}
+
+static inline u64 get_node_id(struct inode *inode)
+{
+	return get_fuse_inode(inode)->nodeid;
+}
+
+/** Device operations */
+extern const struct file_operations fuse_dev_operations;
+
+extern const struct dentry_operations fuse_dentry_operations;
+
+/**
+ * Inode to nodeid comparison.
+ */
+int fuse_inode_eq(struct inode *inode, void *_nodeidp);
+
+/**
+ * Get a filled in inode
+ */
+struct inode *fuse_iget(struct super_block *sb, u64 nodeid,
+			int generation, struct fuse_attr *attr,
+			u64 attr_valid, u64 attr_version);
+
+int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,
+		     struct fuse_entry_out *outarg, struct inode **inode);
+
+/**
+ * Send FORGET command
+ */
+void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,
+		       u64 nodeid, u64 nlookup);
+
+struct fuse_forget_link *fuse_alloc_forget(void);
+
+/**
+ * Initialize READ or READDIR request
+ */
+void fuse_read_fill(struct fuse_req *req, struct file *file,
+		    loff_t pos, size_t count, int opcode);
+
+/**
+ * Send OPEN or OPENDIR request
+ */
+int fuse_open_common(struct inode *inode, struct file *file, bool isdir);
+
+struct fuse_file *fuse_file_alloc(struct fuse_conn *fc);
+struct fuse_file *fuse_file_get(struct fuse_file *ff);
+void fuse_file_free(struct fuse_file *ff);
+void fuse_finish_open(struct inode *inode, struct file *file);
+
+void fuse_sync_release(struct fuse_file *ff, int flags);
+
+/**
+ * Send RELEASE or RELEASEDIR request
+ */
+void fuse_release_common(struct file *file, int opcode);
+
+/**
+ * Send FSYNC or FSYNCDIR request
+ */
+int fuse_fsync_common(struct file *file, int datasync, int isdir);
+
+/**
+ * Notify poll wakeup
+ */
+int fuse_notify_poll_wakeup(struct fuse_conn *fc,
+			    struct fuse_notify_poll_wakeup_out *outarg);
+
+/**
+ * Initialize file operations on a regular file
+ */
+void fuse_init_file_inode(struct inode *inode);
+
+/**
+ * Initialize inode operations on regular files and special files
+ */
+void fuse_init_common(struct inode *inode);
+
+/**
+ * Initialize inode and file operations on a directory
+ */
+void fuse_init_dir(struct inode *inode);
+
+/**
+ * Initialize inode operations on a symlink
+ */
+void fuse_init_symlink(struct inode *inode);
+
+/**
+ * Change attributes of an inode
+ */
+void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,
+			    u64 attr_valid, u64 attr_version);
+
+void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,
+				   u64 attr_valid);
+
+/**
+ * Initialize the client device
+ */
+int fuse_dev_init(void);
+
+/**
+ * Cleanup the client device
+ */
+void fuse_dev_cleanup(void);
+
+int fuse_ctl_init(void);
+void fuse_ctl_cleanup(void);
+
+/**
+ * Allocate a request
+ */
+struct fuse_req *fuse_request_alloc(void);
+
+struct fuse_req *fuse_request_alloc_nofs(void);
+
+/**
+ * Free a request
+ */
+void fuse_request_free(struct fuse_req *req);
+
+/**
+ * Get a request, may fail with -ENOMEM
+ */
+struct fuse_req *fuse_get_req(struct fuse_conn *fc);
+
+/**
+ * Gets a requests for a file operation, always succeeds
+ */
+struct fuse_req *fuse_get_req_nofail(struct fuse_conn *fc, struct file *file);
+
+/**
+ * Decrement reference count of a request.  If count goes to zero free
+ * the request.
+ */
+void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
+
+/**
+ * Send a request (synchronous)
+ */
+void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
+
+/**
+ * Send a request in the background
+ */
+void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
+
+void fuse_request_send_background_locked(struct fuse_conn *fc,
+					 struct fuse_req *req);
+
+/* Abort all requests */
+void fuse_abort_conn(struct fuse_conn *fc);
+
+/**
+ * Invalidate inode attributes
+ */
+void fuse_invalidate_attr(struct inode *inode);
+
+void fuse_invalidate_entry_cache(struct dentry *entry);
+
+/**
+ * Acquire reference to fuse_conn
+ */
+struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
+
+void fuse_conn_kill(struct fuse_conn *fc);
+
+/**
+ * Initialize fuse_conn
+ */
+void fuse_conn_init(struct fuse_conn *fc);
+
+/**
+ * Release reference to fuse_conn
+ */
+void fuse_conn_put(struct fuse_conn *fc);
+
+/**
+ * Add connection to control filesystem
+ */
+int fuse_ctl_add_conn(struct fuse_conn *fc);
+
+/**
+ * Remove connection from control filesystem
+ */
+void fuse_ctl_remove_conn(struct fuse_conn *fc);
+
+/**
+ * Is file type valid?
+ */
+int fuse_valid_type(int m);
+
+/**
+ * Is task allowed to perform filesystem operation?
+ */
+int fuse_allow_task(struct fuse_conn *fc, struct task_struct *task);
+
+u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);
+
+int fuse_update_attributes(struct inode *inode, struct kstat *stat,
+			   struct file *file, bool *refreshed);
+
+void fuse_flush_writepages(struct inode *inode);
+
+void fuse_set_nowrite(struct inode *inode);
+void fuse_release_nowrite(struct inode *inode);
+
+u64 fuse_get_attr_version(struct fuse_conn *fc);
+
+/**
+ * File-system tells the kernel to invalidate cache for the given node id.
+ */
+int fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,
+			     loff_t offset, loff_t len);
+
+/**
+ * File-system tells the kernel to invalidate parent attributes and
+ * the dentry matching parent/name.
+ */
+int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
+			     struct qstr *name);
+
+int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
+		 bool isdir);
+ssize_t fuse_direct_io(struct file *file, const char __user *buf,
+		       size_t count, loff_t *ppos, int write);
+long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
+		   unsigned int flags);
+unsigned fuse_file_poll(struct file *file, poll_table *wait);
+int fuse_dev_release(struct inode *inode, struct file *file);
+
+void fuse_write_update_size(struct inode *inode, loff_t pos);
+
+#endif /* _FS_FUSE_I_H */
Index: fuse-2.8.5/kernel/inode.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/inode.c
@@ -0,0 +1,1246 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/file.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/parser.h>
+#include <linux/statfs.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <linux/exportfs.h>
+
+MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
+MODULE_DESCRIPTION("Filesystem in Userspace");
+MODULE_LICENSE("GPL");
+
+static struct kmem_cache *fuse_inode_cachep;
+struct list_head fuse_conn_list;
+DEFINE_MUTEX(fuse_mutex);
+
+static int set_global_limit(const char *val, struct kernel_param *kp);
+
+unsigned max_user_bgreq;
+module_param_call(max_user_bgreq, set_global_limit, param_get_uint,
+		  &max_user_bgreq, 0644);
+__MODULE_PARM_TYPE(max_user_bgreq, "uint");
+MODULE_PARM_DESC(max_user_bgreq,
+ "Global limit for the maximum number of backgrounded requests an "
+ "unprivileged user can set");
+
+unsigned max_user_congthresh;
+module_param_call(max_user_congthresh, set_global_limit, param_get_uint,
+		  &max_user_congthresh, 0644);
+__MODULE_PARM_TYPE(max_user_congthresh, "uint");
+MODULE_PARM_DESC(max_user_congthresh,
+ "Global limit for the maximum congestion threshold an "
+ "unprivileged user can set");
+
+#define FUSE_SUPER_MAGIC 0x65735546
+
+#define FUSE_DEFAULT_BLKSIZE 512
+
+/** Maximum number of outstanding background requests */
+#define FUSE_DEFAULT_MAX_BACKGROUND 12
+
+/** Congestion starts at 75% of maximum */
+#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)
+
+struct fuse_mount_data {
+	int fd;
+	unsigned rootmode;
+	unsigned user_id;
+	unsigned group_id;
+	unsigned fd_present:1;
+	unsigned rootmode_present:1;
+	unsigned user_id_present:1;
+	unsigned group_id_present:1;
+	unsigned flags;
+	unsigned max_read;
+	unsigned blksize;
+};
+
+struct fuse_forget_link *fuse_alloc_forget()
+{
+	return kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);
+}
+
+static struct inode *fuse_alloc_inode(struct super_block *sb)
+{
+	struct inode *inode;
+	struct fuse_inode *fi;
+
+	inode = kmem_cache_alloc(fuse_inode_cachep, GFP_KERNEL);
+	if (!inode)
+		return NULL;
+
+	fi = get_fuse_inode(inode);
+	fi->i_time = 0;
+	fi->nodeid = 0;
+	fi->nlookup = 0;
+	fi->attr_version = 0;
+	fi->writectr = 0;
+	INIT_LIST_HEAD(&fi->write_files);
+	INIT_LIST_HEAD(&fi->queued_writes);
+	INIT_LIST_HEAD(&fi->writepages);
+	init_waitqueue_head(&fi->page_waitq);
+	fi->forget = fuse_alloc_forget();
+	if (!fi->forget) {
+		kmem_cache_free(fuse_inode_cachep, inode);
+		return NULL;
+	}
+
+	return inode;
+}
+
+static void fuse_i_callback(struct rcu_head *head)
+{
+	struct inode *inode = container_of(head, struct inode, i_rcu);
+	INIT_LIST_HEAD(&inode->i_dentry);
+	kmem_cache_free(fuse_inode_cachep, inode);
+}
+
+static void fuse_destroy_inode(struct inode *inode)
+{
+	struct fuse_inode *fi = get_fuse_inode(inode);
+	BUG_ON(!list_empty(&fi->write_files));
+	BUG_ON(!list_empty(&fi->queued_writes));
+	kfree(fi->forget);
+	call_rcu(&inode->i_rcu, fuse_i_callback);
+}
+
+static void fuse_evict_inode(struct inode *inode)
+{
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
+	if (inode->i_sb->s_flags & MS_ACTIVE) {
+		struct fuse_conn *fc = get_fuse_conn(inode);
+		struct fuse_inode *fi = get_fuse_inode(inode);
+		fuse_queue_forget(fc, fi->forget, fi->nodeid, fi->nlookup);
+		fi->forget = NULL;
+	}
+}
+
+static int fuse_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	if (*flags & MS_MANDLOCK)
+		return -EINVAL;
+
+	return 0;
+}
+
+void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,
+				   u64 attr_valid)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+
+	fi->attr_version = ++fc->attr_version;
+	fi->i_time = attr_valid;
+
+	inode->i_ino     = attr->ino;
+	inode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);
+	inode->i_nlink   = attr->nlink;
+	inode->i_uid     = attr->uid;
+	inode->i_gid     = attr->gid;
+	inode->i_blocks  = attr->blocks;
+	inode->i_atime.tv_sec   = attr->atime;
+	inode->i_atime.tv_nsec  = attr->atimensec;
+	inode->i_mtime.tv_sec   = attr->mtime;
+	inode->i_mtime.tv_nsec  = attr->mtimensec;
+	inode->i_ctime.tv_sec   = attr->ctime;
+	inode->i_ctime.tv_nsec  = attr->ctimensec;
+
+	if (attr->blksize != 0)
+		inode->i_blkbits = ilog2(attr->blksize);
+	else
+		inode->i_blkbits = inode->i_sb->s_blocksize_bits;
+
+	/*
+	 * Don't set the sticky bit in i_mode, unless we want the VFS
+	 * to check permissions.  This prevents failures due to the
+	 * check in may_delete().
+	 */
+	fi->orig_i_mode = inode->i_mode;
+	if (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))
+		inode->i_mode &= ~S_ISVTX;
+}
+
+void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,
+			    u64 attr_valid, u64 attr_version)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	struct fuse_inode *fi = get_fuse_inode(inode);
+	loff_t oldsize;
+
+	spin_lock(&fc->lock);
+	if (attr_version != 0 && fi->attr_version > attr_version) {
+		spin_unlock(&fc->lock);
+		return;
+	}
+
+	fuse_change_attributes_common(inode, attr, attr_valid);
+
+	oldsize = inode->i_size;
+	i_size_write(inode, attr->size);
+	spin_unlock(&fc->lock);
+
+	if (S_ISREG(inode->i_mode) && oldsize != attr->size) {
+		truncate_pagecache(inode, oldsize, attr->size);
+		invalidate_inode_pages2(inode->i_mapping);
+	}
+}
+
+static void fuse_init_inode(struct inode *inode, struct fuse_attr *attr)
+{
+	inode->i_mode = attr->mode & S_IFMT;
+	inode->i_size = attr->size;
+	if (S_ISREG(inode->i_mode)) {
+		fuse_init_common(inode);
+		fuse_init_file_inode(inode);
+	} else if (S_ISDIR(inode->i_mode))
+		fuse_init_dir(inode);
+	else if (S_ISLNK(inode->i_mode))
+		fuse_init_symlink(inode);
+	else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||
+		 S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {
+		fuse_init_common(inode);
+		init_special_inode(inode, inode->i_mode,
+				   new_decode_dev(attr->rdev));
+	} else
+		BUG();
+}
+
+int fuse_inode_eq(struct inode *inode, void *_nodeidp)
+{
+	u64 nodeid = *(u64 *) _nodeidp;
+	if (get_node_id(inode) == nodeid)
+		return 1;
+	else
+		return 0;
+}
+
+static int fuse_inode_set(struct inode *inode, void *_nodeidp)
+{
+	u64 nodeid = *(u64 *) _nodeidp;
+	get_fuse_inode(inode)->nodeid = nodeid;
+	return 0;
+}
+
+struct inode *fuse_iget(struct super_block *sb, u64 nodeid,
+			int generation, struct fuse_attr *attr,
+			u64 attr_valid, u64 attr_version)
+{
+	struct inode *inode;
+	struct fuse_inode *fi;
+	struct fuse_conn *fc = get_fuse_conn_super(sb);
+
+ retry:
+	inode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);
+	if (!inode)
+		return NULL;
+
+	if ((inode->i_state & I_NEW)) {
+		inode->i_flags |= S_NOATIME|S_NOCMTIME;
+		inode->i_generation = generation;
+		inode->i_data.backing_dev_info = &fc->bdi;
+		fuse_init_inode(inode, attr);
+		unlock_new_inode(inode);
+	} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {
+		/* Inode has changed type, any I/O on the old should fail */
+		make_bad_inode(inode);
+		iput(inode);
+		goto retry;
+	}
+
+	fi = get_fuse_inode(inode);
+	spin_lock(&fc->lock);
+	fi->nlookup++;
+	spin_unlock(&fc->lock);
+	fuse_change_attributes(inode, attr, attr_valid, attr_version);
+
+	return inode;
+}
+
+int fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,
+			     loff_t offset, loff_t len)
+{
+	struct inode *inode;
+	pgoff_t pg_start;
+	pgoff_t pg_end;
+
+	inode = ilookup5(sb, nodeid, fuse_inode_eq, &nodeid);
+	if (!inode)
+		return -ENOENT;
+
+	fuse_invalidate_attr(inode);
+	if (offset >= 0) {
+		pg_start = offset >> PAGE_CACHE_SHIFT;
+		if (len <= 0)
+			pg_end = -1;
+		else
+			pg_end = (offset + len - 1) >> PAGE_CACHE_SHIFT;
+		invalidate_inode_pages2_range(inode->i_mapping,
+					      pg_start, pg_end);
+	}
+	iput(inode);
+	return 0;
+}
+
+static void fuse_umount_begin(struct super_block *sb)
+{
+	fuse_abort_conn(get_fuse_conn_super(sb));
+}
+
+static void fuse_send_destroy(struct fuse_conn *fc)
+{
+	struct fuse_req *req = fc->destroy_req;
+	if (req && fc->conn_init) {
+		fc->destroy_req = NULL;
+		req->in.h.opcode = FUSE_DESTROY;
+		req->force = 1;
+		fuse_request_send(fc, req);
+		fuse_put_request(fc, req);
+	}
+}
+
+static void fuse_bdi_destroy(struct fuse_conn *fc)
+{
+	if (fc->bdi_initialized)
+		bdi_destroy(&fc->bdi);
+}
+
+void fuse_conn_kill(struct fuse_conn *fc)
+{
+	spin_lock(&fc->lock);
+	fc->connected = 0;
+	fc->blocked = 0;
+	spin_unlock(&fc->lock);
+	/* Flush all readers on this fs */
+	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
+	wake_up_all(&fc->waitq);
+	wake_up_all(&fc->blocked_waitq);
+	wake_up_all(&fc->reserved_req_waitq);
+	mutex_lock(&fuse_mutex);
+	list_del(&fc->entry);
+	fuse_ctl_remove_conn(fc);
+	mutex_unlock(&fuse_mutex);
+	fuse_bdi_destroy(fc);
+}
+EXPORT_SYMBOL_GPL(fuse_conn_kill);
+
+static void fuse_put_super(struct super_block *sb)
+{
+	struct fuse_conn *fc = get_fuse_conn_super(sb);
+
+	fuse_send_destroy(fc);
+	fuse_conn_kill(fc);
+	fuse_conn_put(fc);
+}
+
+static void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)
+{
+	stbuf->f_type    = FUSE_SUPER_MAGIC;
+	stbuf->f_bsize   = attr->bsize;
+	stbuf->f_frsize  = attr->frsize;
+	stbuf->f_blocks  = attr->blocks;
+	stbuf->f_bfree   = attr->bfree;
+	stbuf->f_bavail  = attr->bavail;
+	stbuf->f_files   = attr->files;
+	stbuf->f_ffree   = attr->ffree;
+	stbuf->f_namelen = attr->namelen;
+	/* fsid is left zero */
+}
+
+static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct super_block *sb = dentry->d_sb;
+	struct fuse_conn *fc = get_fuse_conn_super(sb);
+	struct fuse_req *req;
+	struct fuse_statfs_out outarg;
+	int err;
+
+	if (!fuse_allow_task(fc, current)) {
+		buf->f_type = FUSE_SUPER_MAGIC;
+		return 0;
+	}
+
+	req = fuse_get_req(fc);
+	if (IS_ERR(req))
+		return PTR_ERR(req);
+
+	memset(&outarg, 0, sizeof(outarg));
+	req->in.numargs = 0;
+	req->in.h.opcode = FUSE_STATFS;
+	req->in.h.nodeid = get_node_id(dentry->d_inode);
+	req->out.numargs = 1;
+	req->out.args[0].size =
+		fc->minor < 4 ? FUSE_COMPAT_STATFS_SIZE : sizeof(outarg);
+	req->out.args[0].value = &outarg;
+	fuse_request_send(fc, req);
+	err = req->out.h.error;
+	if (!err)
+		convert_fuse_statfs(buf, &outarg.st);
+	fuse_put_request(fc, req);
+	return err;
+}
+
+enum {
+	OPT_FD,
+	OPT_ROOTMODE,
+	OPT_USER_ID,
+	OPT_GROUP_ID,
+	OPT_DEFAULT_PERMISSIONS,
+	OPT_ALLOW_OTHER,
+	OPT_MAX_READ,
+	OPT_BLKSIZE,
+	OPT_ERR
+};
+
+static const match_table_t tokens = {
+	{OPT_FD,			"fd=%u"},
+	{OPT_ROOTMODE,			"rootmode=%o"},
+	{OPT_USER_ID,			"user_id=%u"},
+	{OPT_GROUP_ID,			"group_id=%u"},
+	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
+	{OPT_ALLOW_OTHER,		"allow_other"},
+	{OPT_MAX_READ,			"max_read=%u"},
+	{OPT_BLKSIZE,			"blksize=%u"},
+	{OPT_ERR,			NULL}
+};
+
+static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)
+{
+	char *p;
+	memset(d, 0, sizeof(struct fuse_mount_data));
+	d->max_read = ~0;
+	d->blksize = FUSE_DEFAULT_BLKSIZE;
+
+	while ((p = strsep(&opt, ",")) != NULL) {
+		int token;
+		int value;
+		substring_t args[MAX_OPT_ARGS];
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case OPT_FD:
+			if (match_int(&args[0], &value))
+				return 0;
+			d->fd = value;
+			d->fd_present = 1;
+			break;
+
+		case OPT_ROOTMODE:
+			if (match_octal(&args[0], &value))
+				return 0;
+			if (!fuse_valid_type(value))
+				return 0;
+			d->rootmode = value;
+			d->rootmode_present = 1;
+			break;
+
+		case OPT_USER_ID:
+			if (match_int(&args[0], &value))
+				return 0;
+			d->user_id = value;
+			d->user_id_present = 1;
+			break;
+
+		case OPT_GROUP_ID:
+			if (match_int(&args[0], &value))
+				return 0;
+			d->group_id = value;
+			d->group_id_present = 1;
+			break;
+
+		case OPT_DEFAULT_PERMISSIONS:
+			d->flags |= FUSE_DEFAULT_PERMISSIONS;
+			break;
+
+		case OPT_ALLOW_OTHER:
+			d->flags |= FUSE_ALLOW_OTHER;
+			break;
+
+		case OPT_MAX_READ:
+			if (match_int(&args[0], &value))
+				return 0;
+			d->max_read = value;
+			break;
+
+		case OPT_BLKSIZE:
+			if (!is_bdev || match_int(&args[0], &value))
+				return 0;
+			d->blksize = value;
+			break;
+
+		default:
+			return 0;
+		}
+	}
+
+	if (!d->fd_present || !d->rootmode_present ||
+	    !d->user_id_present || !d->group_id_present)
+		return 0;
+
+	return 1;
+}
+
+static int fuse_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct fuse_conn *fc = get_fuse_conn_super(mnt->mnt_sb);
+
+	seq_printf(m, ",user_id=%u", fc->user_id);
+	seq_printf(m, ",group_id=%u", fc->group_id);
+	if (fc->flags & FUSE_DEFAULT_PERMISSIONS)
+		seq_puts(m, ",default_permissions");
+	if (fc->flags & FUSE_ALLOW_OTHER)
+		seq_puts(m, ",allow_other");
+	if (fc->max_read != ~0)
+		seq_printf(m, ",max_read=%u", fc->max_read);
+	if (mnt->mnt_sb->s_bdev &&
+	    mnt->mnt_sb->s_blocksize != FUSE_DEFAULT_BLKSIZE)
+		seq_printf(m, ",blksize=%lu", mnt->mnt_sb->s_blocksize);
+	return 0;
+}
+
+void fuse_conn_init(struct fuse_conn *fc)
+{
+	memset(fc, 0, sizeof(*fc));
+	spin_lock_init(&fc->lock);
+	mutex_init(&fc->inst_mutex);
+	init_rwsem(&fc->killsb);
+	atomic_set(&fc->count, 1);
+	init_waitqueue_head(&fc->waitq);
+	init_waitqueue_head(&fc->blocked_waitq);
+	init_waitqueue_head(&fc->reserved_req_waitq);
+	INIT_LIST_HEAD(&fc->pending);
+	INIT_LIST_HEAD(&fc->processing);
+	INIT_LIST_HEAD(&fc->io);
+	INIT_LIST_HEAD(&fc->interrupts);
+	INIT_LIST_HEAD(&fc->bg_queue);
+	INIT_LIST_HEAD(&fc->entry);
+	fc->forget_list_tail = &fc->forget_list_head;
+	atomic_set(&fc->num_waiting, 0);
+	fc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;
+	fc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;
+	fc->khctr = 0;
+	fc->polled_files = RB_ROOT;
+	fc->reqctr = 0;
+	fc->blocked = 1;
+	fc->attr_version = 1;
+	get_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));
+}
+EXPORT_SYMBOL_GPL(fuse_conn_init);
+
+void fuse_conn_put(struct fuse_conn *fc)
+{
+	if (atomic_dec_and_test(&fc->count)) {
+		if (fc->destroy_req)
+			fuse_request_free(fc->destroy_req);
+		mutex_destroy(&fc->inst_mutex);
+		fc->release(fc);
+	}
+}
+EXPORT_SYMBOL_GPL(fuse_conn_put);
+
+struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
+{
+	atomic_inc(&fc->count);
+	return fc;
+}
+EXPORT_SYMBOL_GPL(fuse_conn_get);
+
+static struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)
+{
+	struct fuse_attr attr;
+	memset(&attr, 0, sizeof(attr));
+
+	attr.mode = mode;
+	attr.ino = FUSE_ROOT_ID;
+	attr.nlink = 1;
+	return fuse_iget(sb, 1, 0, &attr, 0, 0);
+}
+
+struct fuse_inode_handle {
+	u64 nodeid;
+	u32 generation;
+};
+
+static struct dentry *fuse_get_dentry(struct super_block *sb,
+				      struct fuse_inode_handle *handle)
+{
+	struct fuse_conn *fc = get_fuse_conn_super(sb);
+	struct inode *inode;
+	struct dentry *entry;
+	int err = -ESTALE;
+
+	if (handle->nodeid == 0)
+		goto out_err;
+
+	inode = ilookup5(sb, handle->nodeid, fuse_inode_eq, &handle->nodeid);
+	if (!inode) {
+		struct fuse_entry_out outarg;
+		struct qstr name;
+
+		if (!fc->export_support)
+			goto out_err;
+
+		name.len = 1;
+		name.name = ".";
+		err = fuse_lookup_name(sb, handle->nodeid, &name, &outarg,
+				       &inode);
+		if (err && err != -ENOENT)
+			goto out_err;
+		if (err || !inode) {
+			err = -ESTALE;
+			goto out_err;
+		}
+		err = -EIO;
+		if (get_node_id(inode) != handle->nodeid)
+			goto out_iput;
+	}
+	err = -ESTALE;
+	if (inode->i_generation != handle->generation)
+		goto out_iput;
+
+	entry = d_obtain_alias(inode);
+	if (!IS_ERR(entry) && get_node_id(inode) != FUSE_ROOT_ID)
+		fuse_invalidate_entry_cache(entry);
+
+	return entry;
+
+ out_iput:
+	iput(inode);
+ out_err:
+	return ERR_PTR(err);
+}
+
+static int fuse_encode_fh(struct dentry *dentry, u32 *fh, int *max_len,
+			   int connectable)
+{
+	struct inode *inode = dentry->d_inode;
+	bool encode_parent = connectable && !S_ISDIR(inode->i_mode);
+	int len = encode_parent ? 6 : 3;
+	u64 nodeid;
+	u32 generation;
+
+	if (*max_len < len) {
+		*max_len = len;
+		return  255;
+	}
+
+	nodeid = get_fuse_inode(inode)->nodeid;
+	generation = inode->i_generation;
+
+	fh[0] = (u32)(nodeid >> 32);
+	fh[1] = (u32)(nodeid & 0xffffffff);
+	fh[2] = generation;
+
+	if (encode_parent) {
+		struct inode *parent;
+
+		spin_lock(&dentry->d_lock);
+		parent = dentry->d_parent->d_inode;
+		nodeid = get_fuse_inode(parent)->nodeid;
+		generation = parent->i_generation;
+		spin_unlock(&dentry->d_lock);
+
+		fh[3] = (u32)(nodeid >> 32);
+		fh[4] = (u32)(nodeid & 0xffffffff);
+		fh[5] = generation;
+	}
+
+	*max_len = len;
+	return encode_parent ? 0x82 : 0x81;
+}
+
+static struct dentry *fuse_fh_to_dentry(struct super_block *sb,
+		struct fid *fid, int fh_len, int fh_type)
+{
+	struct fuse_inode_handle handle;
+
+	if ((fh_type != 0x81 && fh_type != 0x82) || fh_len < 3)
+		return NULL;
+
+	handle.nodeid = (u64) fid->raw[0] << 32;
+	handle.nodeid |= (u64) fid->raw[1];
+	handle.generation = fid->raw[2];
+	return fuse_get_dentry(sb, &handle);
+}
+
+static struct dentry *fuse_fh_to_parent(struct super_block *sb,
+		struct fid *fid, int fh_len, int fh_type)
+{
+	struct fuse_inode_handle parent;
+
+	if (fh_type != 0x82 || fh_len < 6)
+		return NULL;
+
+	parent.nodeid = (u64) fid->raw[3] << 32;
+	parent.nodeid |= (u64) fid->raw[4];
+	parent.generation = fid->raw[5];
+	return fuse_get_dentry(sb, &parent);
+}
+
+static struct dentry *fuse_get_parent(struct dentry *child)
+{
+	struct inode *child_inode = child->d_inode;
+	struct fuse_conn *fc = get_fuse_conn(child_inode);
+	struct inode *inode;
+	struct dentry *parent;
+	struct fuse_entry_out outarg;
+	struct qstr name;
+	int err;
+
+	if (!fc->export_support)
+		return ERR_PTR(-ESTALE);
+
+	name.len = 2;
+	name.name = "..";
+	err = fuse_lookup_name(child_inode->i_sb, get_node_id(child_inode),
+			       &name, &outarg, &inode);
+	if (err) {
+		if (err == -ENOENT)
+			return ERR_PTR(-ESTALE);
+		return ERR_PTR(err);
+	}
+
+	parent = d_obtain_alias(inode);
+	if (!IS_ERR(parent) && get_node_id(inode) != FUSE_ROOT_ID)
+		fuse_invalidate_entry_cache(parent);
+
+	return parent;
+}
+
+static const struct export_operations fuse_export_operations = {
+	.fh_to_dentry	= fuse_fh_to_dentry,
+	.fh_to_parent	= fuse_fh_to_parent,
+	.encode_fh	= fuse_encode_fh,
+	.get_parent	= fuse_get_parent,
+};
+
+static const struct super_operations fuse_super_operations = {
+	.alloc_inode    = fuse_alloc_inode,
+	.destroy_inode  = fuse_destroy_inode,
+	.evict_inode	= fuse_evict_inode,
+	.drop_inode	= generic_delete_inode,
+	.remount_fs	= fuse_remount_fs,
+	.put_super	= fuse_put_super,
+	.umount_begin	= fuse_umount_begin,
+	.statfs		= fuse_statfs,
+	.show_options	= fuse_show_options,
+};
+
+static void sanitize_global_limit(unsigned *limit)
+{
+	if (*limit == 0)
+		*limit = ((num_physpages << PAGE_SHIFT) >> 13) /
+			 sizeof(struct fuse_req);
+
+	if (*limit >= 1 << 16)
+		*limit = (1 << 16) - 1;
+}
+
+static int set_global_limit(const char *val, struct kernel_param *kp)
+{
+	int rv;
+
+	rv = param_set_uint(val, kp);
+	if (rv)
+		return rv;
+
+	sanitize_global_limit((unsigned *)kp->arg);
+
+	return 0;
+}
+
+static void process_init_limits(struct fuse_conn *fc, struct fuse_init_out *arg)
+{
+	int cap_sys_admin = capable(CAP_SYS_ADMIN);
+
+	if (arg->minor < 13)
+		return;
+
+	sanitize_global_limit(&max_user_bgreq);
+	sanitize_global_limit(&max_user_congthresh);
+
+	if (arg->max_background) {
+		fc->max_background = arg->max_background;
+
+		if (!cap_sys_admin && fc->max_background > max_user_bgreq)
+			fc->max_background = max_user_bgreq;
+	}
+	if (arg->congestion_threshold) {
+		fc->congestion_threshold = arg->congestion_threshold;
+
+		if (!cap_sys_admin &&
+		    fc->congestion_threshold > max_user_congthresh)
+			fc->congestion_threshold = max_user_congthresh;
+	}
+}
+
+static void process_init_reply(struct fuse_conn *fc, struct fuse_req *req)
+{
+	struct fuse_init_out *arg = &req->misc.init_out;
+
+	if (req->out.h.error || arg->major != FUSE_KERNEL_VERSION)
+		fc->conn_error = 1;
+	else {
+		unsigned long ra_pages;
+
+		process_init_limits(fc, arg);
+
+		if (arg->minor >= 6) {
+			ra_pages = arg->max_readahead / PAGE_CACHE_SIZE;
+			if (arg->flags & FUSE_ASYNC_READ)
+				fc->async_read = 1;
+			if (!(arg->flags & FUSE_POSIX_LOCKS))
+				fc->no_lock = 1;
+			if (arg->flags & FUSE_ATOMIC_O_TRUNC)
+				fc->atomic_o_trunc = 1;
+			if (arg->minor >= 9) {
+				/* LOOKUP has dependency on proto version */
+				if (arg->flags & FUSE_EXPORT_SUPPORT)
+					fc->export_support = 1;
+			}
+			if (arg->flags & FUSE_BIG_WRITES)
+				fc->big_writes = 1;
+			if (arg->flags & FUSE_DONT_MASK)
+				fc->dont_mask = 1;
+		} else {
+			ra_pages = fc->max_read / PAGE_CACHE_SIZE;
+			fc->no_lock = 1;
+		}
+
+		fc->bdi.ra_pages = min(fc->bdi.ra_pages, ra_pages);
+		fc->minor = arg->minor;
+		fc->max_write = arg->minor < 5 ? 4096 : arg->max_write;
+		fc->max_write = max_t(unsigned, 4096, fc->max_write);
+		fc->conn_init = 1;
+	}
+	fc->blocked = 0;
+	wake_up_all(&fc->blocked_waitq);
+}
+
+static void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)
+{
+	struct fuse_init_in *arg = &req->misc.init_in;
+
+	arg->major = FUSE_KERNEL_VERSION;
+	arg->minor = FUSE_KERNEL_MINOR_VERSION;
+	arg->max_readahead = fc->bdi.ra_pages * PAGE_CACHE_SIZE;
+	arg->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |
+		FUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK;
+	req->in.h.opcode = FUSE_INIT;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(*arg);
+	req->in.args[0].value = arg;
+	req->out.numargs = 1;
+	/* Variable length argument used for backward compatibility
+	   with interface version < 7.5.  Rest of init_out is zeroed
+	   by do_get_request(), so a short reply is not a problem */
+	req->out.argvar = 1;
+	req->out.args[0].size = sizeof(struct fuse_init_out);
+	req->out.args[0].value = &req->misc.init_out;
+	req->end = process_init_reply;
+	fuse_request_send_background(fc, req);
+}
+
+static void fuse_free_conn(struct fuse_conn *fc)
+{
+	kfree(fc);
+}
+
+static int fuse_bdi_init(struct fuse_conn *fc, struct super_block *sb)
+{
+	int err;
+
+	fc->bdi.name = "fuse";
+	fc->bdi.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;
+	/* fuse does it's own writeback accounting */
+	fc->bdi.capabilities = BDI_CAP_NO_ACCT_WB;
+
+	err = bdi_init(&fc->bdi);
+	if (err)
+		return err;
+
+	fc->bdi_initialized = 1;
+
+	if (sb->s_bdev) {
+		err =  bdi_register(&fc->bdi, NULL, "%u:%u-fuseblk",
+				    MAJOR(fc->dev), MINOR(fc->dev));
+	} else {
+		err = bdi_register_dev(&fc->bdi, fc->dev);
+	}
+
+	if (err)
+		return err;
+
+	/*
+	 * For a single fuse filesystem use max 1% of dirty +
+	 * writeback threshold.
+	 *
+	 * This gives about 1M of write buffer for memory maps on a
+	 * machine with 1G and 10% dirty_ratio, which should be more
+	 * than enough.
+	 *
+	 * Privileged users can raise it by writing to
+	 *
+	 *    /sys/class/bdi/<bdi>/max_ratio
+	 */
+	bdi_set_max_ratio(&fc->bdi, 1);
+
+	return 0;
+}
+
+static int fuse_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct fuse_conn *fc;
+	struct inode *root;
+	struct fuse_mount_data d;
+	struct file *file;
+	struct dentry *root_dentry;
+	struct fuse_req *init_req;
+	int err;
+	int is_bdev = sb->s_bdev != NULL;
+
+	err = -EINVAL;
+	if (sb->s_flags & MS_MANDLOCK)
+		goto err;
+
+	if (!parse_fuse_opt((char *) data, &d, is_bdev))
+		goto err;
+
+	if (is_bdev) {
+#ifdef CONFIG_BLOCK
+		err = -EINVAL;
+		if (!sb_set_blocksize(sb, d.blksize))
+			goto err;
+#endif
+	} else {
+		sb->s_blocksize = PAGE_CACHE_SIZE;
+		sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	}
+	sb->s_magic = FUSE_SUPER_MAGIC;
+	sb->s_op = &fuse_super_operations;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+	sb->s_export_op = &fuse_export_operations;
+
+	file = fget(d.fd);
+	err = -EINVAL;
+	if (!file)
+		goto err;
+
+	if (file->f_op != &fuse_dev_operations)
+		goto err_fput;
+
+	fc = kmalloc(sizeof(*fc), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!fc)
+		goto err_fput;
+
+	fuse_conn_init(fc);
+
+	fc->dev = sb->s_dev;
+	fc->sb = sb;
+	err = fuse_bdi_init(fc, sb);
+	if (err)
+		goto err_put_conn;
+
+	sb->s_bdi = &fc->bdi;
+
+	/* Handle umasking inside the fuse code */
+	if (sb->s_flags & MS_POSIXACL)
+		fc->dont_mask = 1;
+	sb->s_flags |= MS_POSIXACL;
+
+	fc->release = fuse_free_conn;
+	fc->flags = d.flags;
+	fc->user_id = d.user_id;
+	fc->group_id = d.group_id;
+	fc->max_read = max_t(unsigned, 4096, d.max_read);
+
+	/* Used by get_root_inode() */
+	sb->s_fs_info = fc;
+
+	err = -ENOMEM;
+	root = fuse_get_root_inode(sb, d.rootmode);
+	if (!root)
+		goto err_put_conn;
+
+	root_dentry = d_alloc_root(root);
+	if (!root_dentry) {
+		iput(root);
+		goto err_put_conn;
+	}
+	/* only now - we want root dentry with NULL ->d_op */
+	sb->s_d_op = &fuse_dentry_operations;
+
+	init_req = fuse_request_alloc();
+	if (!init_req)
+		goto err_put_root;
+
+	if (is_bdev) {
+		fc->destroy_req = fuse_request_alloc();
+		if (!fc->destroy_req)
+			goto err_free_init_req;
+	}
+
+	mutex_lock(&fuse_mutex);
+	err = -EINVAL;
+	if (file->private_data)
+		goto err_unlock;
+
+	err = fuse_ctl_add_conn(fc);
+	if (err)
+		goto err_unlock;
+
+	list_add_tail(&fc->entry, &fuse_conn_list);
+	sb->s_root = root_dentry;
+	fc->connected = 1;
+	file->private_data = fuse_conn_get(fc);
+	mutex_unlock(&fuse_mutex);
+	/*
+	 * atomic_dec_and_test() in fput() provides the necessary
+	 * memory barrier for file->private_data to be visible on all
+	 * CPUs after this
+	 */
+	fput(file);
+
+	fuse_send_init(fc, init_req);
+
+	return 0;
+
+ err_unlock:
+	mutex_unlock(&fuse_mutex);
+ err_free_init_req:
+	fuse_request_free(init_req);
+ err_put_root:
+	dput(root_dentry);
+ err_put_conn:
+	fuse_bdi_destroy(fc);
+	fuse_conn_put(fc);
+ err_fput:
+	fput(file);
+ err:
+	return err;
+}
+
+static struct dentry *fuse_mount(struct file_system_type *fs_type,
+		       int flags, const char *dev_name,
+		       void *raw_data)
+{
+	return mount_nodev(fs_type, flags, raw_data, fuse_fill_super);
+}
+
+static void fuse_kill_sb_anon(struct super_block *sb)
+{
+	struct fuse_conn *fc = get_fuse_conn_super(sb);
+
+	if (fc) {
+		down_write(&fc->killsb);
+		fc->sb = NULL;
+		up_write(&fc->killsb);
+	}
+
+	kill_anon_super(sb);
+}
+
+static struct file_system_type fuse_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "fuse",
+	.fs_flags	= FS_HAS_SUBTYPE,
+	.mount		= fuse_mount,
+	.kill_sb	= fuse_kill_sb_anon,
+};
+
+#ifdef CONFIG_BLOCK
+static struct dentry *fuse_mount_blk(struct file_system_type *fs_type,
+			   int flags, const char *dev_name,
+			   void *raw_data)
+{
+	return mount_bdev(fs_type, flags, dev_name, raw_data, fuse_fill_super);
+}
+
+static void fuse_kill_sb_blk(struct super_block *sb)
+{
+	struct fuse_conn *fc = get_fuse_conn_super(sb);
+
+	if (fc) {
+		down_write(&fc->killsb);
+		fc->sb = NULL;
+		up_write(&fc->killsb);
+	}
+
+	kill_block_super(sb);
+}
+
+static struct file_system_type fuseblk_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "fuseblk",
+	.mount		= fuse_mount_blk,
+	.kill_sb	= fuse_kill_sb_blk,
+	.fs_flags	= FS_REQUIRES_DEV | FS_HAS_SUBTYPE,
+};
+
+static inline int register_fuseblk(void)
+{
+	return register_filesystem(&fuseblk_fs_type);
+}
+
+static inline void unregister_fuseblk(void)
+{
+	unregister_filesystem(&fuseblk_fs_type);
+}
+#else
+static inline int register_fuseblk(void)
+{
+	return 0;
+}
+
+static inline void unregister_fuseblk(void)
+{
+}
+#endif
+
+static void fuse_inode_init_once(void *foo)
+{
+	struct inode *inode = foo;
+
+	inode_init_once(inode);
+}
+
+static int __init fuse_fs_init(void)
+{
+	int err;
+
+	err = register_filesystem(&fuse_fs_type);
+	if (err)
+		goto out;
+
+	err = register_fuseblk();
+	if (err)
+		goto out_unreg;
+
+	fuse_inode_cachep = kmem_cache_create("fuse_inode",
+					      sizeof(struct fuse_inode),
+					      0, SLAB_HWCACHE_ALIGN,
+					      fuse_inode_init_once);
+	err = -ENOMEM;
+	if (!fuse_inode_cachep)
+		goto out_unreg2;
+
+	return 0;
+
+ out_unreg2:
+	unregister_fuseblk();
+ out_unreg:
+	unregister_filesystem(&fuse_fs_type);
+ out:
+	return err;
+}
+
+static void fuse_fs_cleanup(void)
+{
+	unregister_filesystem(&fuse_fs_type);
+	unregister_fuseblk();
+	kmem_cache_destroy(fuse_inode_cachep);
+}
+
+static struct kobject *fuse_kobj;
+static struct kobject *connections_kobj;
+
+static int fuse_sysfs_init(void)
+{
+	int err;
+
+	fuse_kobj = kobject_create_and_add("fuse", fs_kobj);
+	if (!fuse_kobj) {
+		err = -ENOMEM;
+		goto out_err;
+	}
+
+	connections_kobj = kobject_create_and_add("connections", fuse_kobj);
+	if (!connections_kobj) {
+		err = -ENOMEM;
+		goto out_fuse_unregister;
+	}
+
+	return 0;
+
+ out_fuse_unregister:
+	kobject_put(fuse_kobj);
+ out_err:
+	return err;
+}
+
+static void fuse_sysfs_cleanup(void)
+{
+	kobject_put(connections_kobj);
+	kobject_put(fuse_kobj);
+}
+
+static int __init fuse_init(void)
+{
+	int res;
+
+	printk(KERN_INFO "fuse init (API version %i.%i)\n",
+	       FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);
+
+	INIT_LIST_HEAD(&fuse_conn_list);
+	res = fuse_fs_init();
+	if (res)
+		goto err;
+
+	res = fuse_dev_init();
+	if (res)
+		goto err_fs_cleanup;
+
+	res = fuse_sysfs_init();
+	if (res)
+		goto err_dev_cleanup;
+
+	res = fuse_ctl_init();
+	if (res)
+		goto err_sysfs_cleanup;
+
+	sanitize_global_limit(&max_user_bgreq);
+	sanitize_global_limit(&max_user_congthresh);
+
+	return 0;
+
+ err_sysfs_cleanup:
+	fuse_sysfs_cleanup();
+ err_dev_cleanup:
+	fuse_dev_cleanup();
+ err_fs_cleanup:
+	fuse_fs_cleanup();
+ err:
+	return res;
+}
+
+static void __exit fuse_exit(void)
+{
+	printk(KERN_DEBUG "fuse exit\n");
+
+	fuse_ctl_cleanup();
+	fuse_sysfs_cleanup();
+	fuse_fs_cleanup();
+	fuse_dev_cleanup();
+}
+
+module_init(fuse_init);
+module_exit(fuse_exit);
Index: fuse-2.8.5/kernel/Kconfig
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/Kconfig
@@ -0,0 +1,15 @@
+config FUSE_FS
+	tristate "FUSE (Filesystem in Userspace) support"
+	help
+	  With FUSE it is possible to implement a fully functional filesystem
+	  in a userspace program.
+
+	  There's also companion library: libfuse.  This library along with
+	  utilities is available from the FUSE homepage:
+	  <http://fuse.sourceforge.net/>
+
+	  See <file:Documentation/filesystems/fuse.txt> for more information.
+	  See <file:Documentation/Changes> for needed library/utility version.
+
+	  If you want to develop a userspace FS, or if you want to use
+	  a filesystem based on FUSE, answer Y or M.
Index: fuse-2.8.5/kernel/Makefile
===================================================================
--- /dev/null
+++ fuse-2.8.5/kernel/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the FUSE filesystem.
+#
+
+obj-$(CONFIG_FUSE_FS) += fuse.o
+obj-$(CONFIG_CUSE) += cuse.o
+
+fuse-objs := dev.o dir.o file.o inode.o control.o
Index: fuse-2.8.5/lib/cuse_lowlevel.c
===================================================================
--- fuse-2.8.5.orig/lib/cuse_lowlevel.c
+++ fuse-2.8.5/lib/cuse_lowlevel.c
@@ -1,29 +1,31 @@
 /*
   CUSE: Character device in Userspace
   Copyright (C) 2008       SUSE Linux Products GmbH
   Copyright (C) 2008       Tejun Heo <teheo@suse.de>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB.
 */
 
+#ifndef __CYGWIN__
+
 #include "cuse_lowlevel.h"
 #include "fuse_kernel.h"
 #include "fuse_i.h"
 #include "fuse_opt.h"
 #include "fuse_misc.h"
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <errno.h>
 #include <unistd.h>
 
 struct cuse_data {
 	struct cuse_lowlevel_ops	clop;
 	unsigned			max_read;
 	unsigned			dev_major;
 	unsigned			dev_minor;
 	unsigned			flags;
 	unsigned			dev_info_len;
@@ -352,20 +354,22 @@ int cuse_lowlevel_main(int argc, char *a
 	struct fuse_session *se;
 	int multithreaded;
 	int res;
 
 	se = cuse_lowlevel_setup(argc, argv, ci, clop, &multithreaded,
 				 userdata);
 	if (se == NULL)
 		return 1;
 
 	if (multithreaded)
 		res = fuse_session_loop_mt(se);
 	else
 		res = fuse_session_loop(se);
 
 	cuse_lowlevel_teardown(se);
 	if (res == -1)
 		return 1;
 
 	return 0;
 }
+
+#endif
Index: fuse-2.8.5/lib/fuse.c
===================================================================
--- fuse-2.8.5.orig/lib/fuse.c
+++ fuse-2.8.5/lib/fuse.c
@@ -16,40 +16,41 @@
 #include "fuse_misc.h"
 #include "fuse_common_compat.h"
 #include "fuse_compat.h"
 #include "fuse_kernel.h"
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <unistd.h>
 #include <time.h>
 #include <fcntl.h>
 #include <limits.h>
 #include <errno.h>
 #include <signal.h>
 #include <dlfcn.h>
 #include <assert.h>
 #include <sys/param.h>
 #include <sys/uio.h>
 #include <sys/time.h>
+#include <Windows.h>
 
 #define FUSE_DEFAULT_INTR_SIGNAL SIGUSR1
 
 #define FUSE_UNKNOWN_INO 0xffffffff
 #define OFFSET_MAX 0x7fffffffffffffffLL
 
 struct fuse_config {
 	unsigned int uid;
 	unsigned int gid;
 	unsigned int  umask;
 	double entry_timeout;
 	double negative_timeout;
 	double attr_timeout;
 	double ac_attr_timeout;
 	int ac_attr_timeout_set;
 	int noforget;
 	int debug;
 	int hard_remove;
 	int use_ino;
 	int readdir_ino;
@@ -3855,66 +3856,68 @@ void fuse_destroy(struct fuse *f)
 		}
 	}
 	for (i = 0; i < f->id_table_size; i++) {
 		struct node *node;
 		struct node *next;
 
 		for (node = f->id_table[i]; node != NULL; node = next) {
 			next = node->id_next;
 			free_node(node);
 		}
 	}
 	free(f->id_table);
 	free(f->name_table);
 	pthread_mutex_destroy(&f->lock);
 	fuse_session_destroy(f->se);
 	free(f->conf.modules);
 	free(f);
 	fuse_delete_context_key();
 }
 
+#ifndef __CYGWIN__
 static struct fuse *fuse_new_common_compat25(int fd, struct fuse_args *args,
 					     const struct fuse_operations *op,
 					     size_t op_size, int compat)
 {
 	struct fuse *f = NULL;
 	struct fuse_chan *ch = fuse_kern_chan_new(fd);
 
 	if (ch)
 		f = fuse_new_common(ch, args, op, op_size, NULL, compat);
 
 	return f;
 }
+#endif
 
 /* called with fuse_context_lock held or during initialization (before
    main() has been called) */
 void fuse_register_module(struct fuse_module *mod)
 {
 	mod->ctr = 0;
 	mod->so = fuse_current_so;
 	if (mod->so)
 		mod->so->ctr++;
 	mod->next = fuse_modules;
 	fuse_modules = mod;
 }
 
-#ifndef __FreeBSD__
+#if !defined __FreeBSD__ && !defined __CYGWIN__
 
 static struct fuse *fuse_new_common_compat(int fd, const char *opts,
 					   const struct fuse_operations *op,
 					   size_t op_size, int compat)
 {
 	struct fuse *f;
 	struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
 
 	if (fuse_opt_add_arg(&args, "") == -1)
 		return NULL;
 	if (opts &&
 	    (fuse_opt_add_arg(&args, "-o") == -1 ||
 	     fuse_opt_add_arg(&args, opts) == -1)) {
 		fuse_opt_free_args(&args);
 		return NULL;
 	}
 	f = fuse_new_common_compat25(fd, &args, op, op_size, compat);
 	fuse_opt_free_args(&args);
 
 	return f;
@@ -3937,31 +3940,35 @@ struct fuse *fuse_new_compat2(int fd, co
 }
 
 struct fuse *fuse_new_compat1(int fd, int flags,
 			      const struct fuse_operations_compat1 *op)
 {
 	const char *opts = NULL;
 	if (flags & FUSE_DEBUG_COMPAT1)
 		opts = "debug";
 	return fuse_new_common_compat(fd, opts, (struct fuse_operations *) op,
 				      sizeof(struct fuse_operations_compat1),
 				      11);
 }
 
 FUSE_SYMVER(".symver fuse_exited,__fuse_exited@");
 FUSE_SYMVER(".symver fuse_process_cmd,__fuse_process_cmd@");
 FUSE_SYMVER(".symver fuse_read_cmd,__fuse_read_cmd@");
 FUSE_SYMVER(".symver fuse_set_getcontext_func,__fuse_set_getcontext_func@");
 FUSE_SYMVER(".symver fuse_new_compat2,fuse_new@");
 FUSE_SYMVER(".symver fuse_new_compat22,fuse_new@FUSE_2.2");
 
-#endif /* __FreeBSD__ */
+#endif /* __FreeBSD__ || __CYGWIN__ */
+
+#ifndef __CYGWIN__
 
 struct fuse *fuse_new_compat25(int fd, struct fuse_args *args,
 			       const struct fuse_operations_compat25 *op,
 			       size_t op_size)
 {
 	return fuse_new_common_compat25(fd, args, (struct fuse_operations *) op,
 					op_size, 25);
 }
 
 FUSE_SYMVER(".symver fuse_new_compat25,fuse_new@FUSE_2.5");
+
+#endif /* !__CYGWIN__ */
Index: fuse-2.8.5/lib/fuse_fs_defines.h
===================================================================
--- /dev/null
+++ fuse-2.8.5/lib/fuse_fs_defines.h
@@ -0,0 +1,14 @@
+#define MS_RDONLY        1      /* Mount read-only */
+#define MS_NOSUID        2      /* Ignore suid and sgid bits */
+#define MS_NODEV         4      /* Disallow access to device special files */
+#define MS_NOEXEC        8      /* Disallow program execution */
+#define MS_SYNCHRONOUS  16      /* Writes are synced at once */
+#define MS_REMOUNT      32      /* Alter flags of a mounted FS */
+#define MS_MANDLOCK     64      /* Allow mandatory locks on an FS */
+#define MS_DIRSYNC      128     /* Directory modifications are synchronous */
+#define MS_NOATIME      1024    /* Do not update access times. */
+#define MS_NODIRATIME   2048    /* Do not update directory access times */
+#define MS_BIND         4096
+#define MS_MOVE         8192
+#define MS_REC          16384
+#define MS_VERBOSE      32768
Index: fuse-2.8.5/lib/fuse_i.h
===================================================================
--- fuse-2.8.5.orig/lib/fuse_i.h
+++ fuse-2.8.5/lib/fuse_i.h
@@ -1,100 +1,128 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB
 */
 
 #include "fuse.h"
 #include "fuse_lowlevel.h"
 
+#ifdef __CYGWIN__
+# include <windows.h>
+#endif
+
 struct fuse_chan;
 struct fuse_ll;
 
 struct fuse_session {
 	struct fuse_session_ops op;
 
 	void *data;
 
 	volatile int exited;
 
 	struct fuse_chan *ch;
 };
 
 struct fuse_req {
 	struct fuse_ll *f;
 	uint64_t unique;
 	int ctr;
 	pthread_mutex_t lock;
 	struct fuse_ctx ctx;
 	struct fuse_chan *ch;
 	int interrupted;
 	union {
 		struct {
 			uint64_t unique;
 		} i;
 		struct {
 			fuse_interrupt_func_t func;
 			void *data;
 		} ni;
 	} u;
 	struct fuse_req *next;
 	struct fuse_req *prev;
+
+#ifdef __CYGWIN__
+	// If this is non-NULL, reply functions should store the
+	// outgoing header at this pointer instead of replying.
+	struct fuse_out_header *response_hijack;
+
+	// If this is non-NULL, and pesponse_hijack is non-NULL,
+	// dump the response here.
+	char *response_hijack_buf;
+	size_t response_hijack_buflen;
+#endif
 };
 
 struct fuse_ll {
 	int debug;
 	int allow_root;
 	int atomic_o_trunc;
 	int no_remote_lock;
 	int big_writes;
 	struct fuse_lowlevel_ops op;
 	int got_init;
 	struct cuse_data *cuse_data;
 	void *userdata;
 	uid_t owner;
 	struct fuse_conn_info conn;
 	struct fuse_req list;
 	struct fuse_req interrupts;
 	pthread_mutex_t lock;
 	int got_destroy;
 };
 
 struct fuse_cmd {
 	char *buf;
 	size_t buflen;
 	struct fuse_chan *ch;
 };
 
 struct fuse *fuse_new_common(struct fuse_chan *ch, struct fuse_args *args,
 			     const struct fuse_operations *op,
 			     size_t op_size, void *user_data, int compat);
 
 int fuse_sync_compat_args(struct fuse_args *args);
 
+#if defined __CYGWIN__
+struct fuse_chan *fuse_kern_chan_new(HANDLE fd);
+#else
 struct fuse_chan *fuse_kern_chan_new(int fd);
+#endif
 
 struct fuse_session *fuse_lowlevel_new_common(struct fuse_args *args,
 					const struct fuse_lowlevel_ops *op,
 					size_t op_size, void *userdata);
 
 void fuse_kern_unmount_compat22(const char *mountpoint);
+#if defined __CYGWIN__
+void fuse_kern_unmount(const char *mountpoint, HANDLE fd);
+int fusent_kern_mount(const char *mountpoint, struct fuse_args *args, HANDLE *fd);
+#else
 void fuse_kern_unmount(const char *mountpoint, int fd);
 int fuse_kern_mount(const char *mountpoint, struct fuse_args *args);
+#endif
 
 int fuse_send_reply_iov_nofree(fuse_req_t req, int error, struct iovec *iov,
 			       int count);
 void fuse_free_req(fuse_req_t req);
 
 
 struct fuse *fuse_setup_common(int argc, char *argv[],
 			       const struct fuse_operations *op,
 			       size_t op_size,
 			       char **mountpoint,
 			       int *multithreaded,
+#if defined __CYGWIN__
+			       HANDLE *fd,
+#else
 			       int *fd,
+#endif
 			       void *user_data,
 			       int compat);
 
 void cuse_lowlevel_init(fuse_req_t req, fuse_ino_t nodeide, const void *inarg);
Index: fuse-2.8.5/lib/fuse_kern_chan.c
===================================================================
--- fuse-2.8.5.orig/lib/fuse_kern_chan.c
+++ fuse-2.8.5/lib/fuse_kern_chan.c
@@ -1,95 +1,213 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB
 */
 
 #include "fuse_lowlevel.h"
 #include "fuse_kernel.h"
 #include "fuse_i.h"
 
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
 #include <assert.h>
 
+#ifdef __CYGWIN__
+# include "fusent_proto.h"
+#endif
+
 static int fuse_kern_chan_receive(struct fuse_chan **chp, char *buf,
 				  size_t size)
 {
 	struct fuse_chan *ch = *chp;
-	int err;
 	ssize_t res;
 	struct fuse_session *se = fuse_chan_session(ch);
 	assert(se != NULL);
 
+#if defined __CYGWIN__
+	IO_STATUS_BLOCK iosb;
+	HANDLE ioevent = CreateEvent(NULL, FALSE, FALSE, NULL);
+	NTSTATUS stat = NtFsControlFile(fuse_chan_fd(ch), ioevent, NULL, NULL, &iosb, IRP_FUSE_MODULE_REQUEST, NULL, 0, buf, size);
+
+	if (fuse_session_exited(se))
+		return 0;
+
+	if (stat != STATUS_PENDING) {
+		CloseHandle(ioevent);
+	}
+	else {
+		DWORD waitres;
+		do {
+			// Wait for a second:
+			waitres = WaitForSingleObject(ioevent, 1000);
+			if (fuse_session_exited(se))
+				return 0;
+		} while (waitres == WAIT_TIMEOUT);
+		CloseHandle(ioevent);
+
+		if (waitres != WAIT_OBJECT_0) {
+			fprintf(stderr, "fuse: waiting for receive() asyncio failed: (%08lx)\n", waitres);
+			return -EFAULT;
+		}
+		stat = STATUS_SUCCESS;
+	}
+
+	if (stat != STATUS_SUCCESS) {
+		fprintf(stderr, "fuse: reading device: got (%08lx), expected STATUS_SUCCESS\n", stat);
+		return -EFAULT;
+	}
+
+	res = iosb.Information;
+#else
+	int err;
+
 restart:
 	res = read(fuse_chan_fd(ch), buf, size);
 	err = errno;
 
 	if (fuse_session_exited(se))
 		return 0;
 	if (res == -1) {
 		/* ENOENT means the operation was interrupted, it's safe
 		   to restart */
 		if (err == ENOENT)
 			goto restart;
 
 		if (err == ENODEV) {
 			fuse_session_exit(se);
 			return 0;
 		}
 		/* Errors occuring during normal operation: EINTR (read
 		   interrupted), EAGAIN (nonblocking I/O), ENODEV (filesystem
 		   umounted) */
 		if (err != EINTR && err != EAGAIN)
 			perror("fuse: reading device");
 		return -err;
 	}
-	if ((size_t) res < sizeof(struct fuse_in_header)) {
+#endif
+
+#if defined __CYGWIN__
+	if ((size_t) res < sizeof(FUSENT_REQ))
+#else
+	if ((size_t) res < sizeof(struct fuse_in_header))
+#endif
+	{
 		fprintf(stderr, "short read on fuse device\n");
 		return -EIO;
 	}
+
 	return res;
 }
 
 static int fuse_kern_chan_send(struct fuse_chan *ch, const struct iovec iov[],
 			       size_t count)
 {
-	if (iov) {
+	if (!iov) return 0;
+
+#if defined __CYGWIN__
+	IO_STATUS_BLOCK iosb;
+	int io;
+	size_t total = 0, idx = 0;
+	char *buf;
+
+	// If only one iovec, skip the copy (should be the case for all of FUSE-NT)
+	if (count == 1) {
+		buf = iov[0].iov_base;
+		total = iov[0].iov_len;
+	}
+
+	// Otherwise, merge each buf into a single long buf
+	else {
+		for (io = 0; io < count; io ++)
+			total += iov[io].iov_len;
+
+		buf = malloc(total);
+		for (io = 0; io < count; io ++) {
+			size_t iolen = iov[io].iov_len;
+			if (!iolen) continue;
+			memcpy(buf + idx, iov[io].iov_base, iolen);
+			idx += iolen;
+		}
+	}
+
+	HANDLE ioevent = CreateEvent(NULL, FALSE, FALSE, NULL);
+	NTSTATUS stat = NtFsControlFile(fuse_chan_fd(ch), ioevent, NULL, NULL, &iosb,
+			IRP_FUSE_MODULE_RESPONSE, buf, total, NULL, 0);
+
+	if (stat != STATUS_PENDING) {
+		CloseHandle(ioevent);
+	}
+	else {
+		DWORD waitres = WaitForSingleObject(ioevent, INFINITE);
+		CloseHandle(ioevent);
+
+		if (waitres != WAIT_OBJECT_0) {
+			fprintf(stderr, "fuse: waiting for send() asyncio failed: (%08x)\n", waitres);
+			if (count != 1)
+				free(buf);
+			return -EFAULT;
+		}
+		stat = STATUS_SUCCESS;
+	}
+
+	if (count != 1)
+		free(buf);
+
+	if (stat != STATUS_SUCCESS) {
+		struct fuse_session *se = fuse_chan_session(ch);
+
+		assert(se != NULL);
+
+		if (fuse_session_exited(se)) return 0;
+
+		fprintf(stderr, "fuse: writing device: got (%08x), expected STATUS_SUCCESS\n", stat);
+
+		return -EFAULT;
+	}
+#else
 		ssize_t res = writev(fuse_chan_fd(ch), iov, count);
 		int err = errno;
 
 		if (res == -1) {
 			struct fuse_session *se = fuse_chan_session(ch);
 
 			assert(se != NULL);
 
 			/* ENOENT means the operation was interrupted */
 			if (!fuse_session_exited(se) && err != ENOENT)
 				perror("fuse: writing device");
 			return -err;
 		}
-	}
+#endif
 	return 0;
 }
 
 static void fuse_kern_chan_destroy(struct fuse_chan *ch)
 {
+#if defined __CYGWIN__
+	CloseHandle(fuse_chan_fd(ch));
+#else
 	close(fuse_chan_fd(ch));
+#endif
 }
 
 #define MIN_BUFSIZE 0x21000
 
+#if defined __CYGWIN__
+struct fuse_chan *fuse_kern_chan_new(HANDLE fd)
+#else
 struct fuse_chan *fuse_kern_chan_new(int fd)
+#endif
 {
 	struct fuse_chan_ops op = {
 		.receive = fuse_kern_chan_receive,
 		.send = fuse_kern_chan_send,
 		.destroy = fuse_kern_chan_destroy,
 	};
 	size_t bufsize = getpagesize() + 0x1000;
 	bufsize = bufsize < MIN_BUFSIZE ? MIN_BUFSIZE : bufsize;
 	return fuse_chan_new(&op, fd, bufsize, NULL);
 }
Index: fuse-2.8.5/lib/fuse_lowlevel.c
===================================================================
--- fuse-2.8.5.orig/lib/fuse_lowlevel.c
+++ fuse-2.8.5/lib/fuse_lowlevel.c
@@ -1,84 +1,286 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB
 */
 
 #include "fuse_i.h"
 #include "fuse_kernel.h"
 #include "fuse_opt.h"
 #include "fuse_misc.h"
 #include "fuse_common_compat.h"
 #include "fuse_lowlevel_compat.h"
 
+#ifdef __CYGWIN__
+# include "fusent_proto.h"
+# include "fusent_routines.h"
+# include "st.h"
+
+# include <ddk/ntifs.h>
+
+# include <iconv.h>
+
+# include <sys/types.h>
+# include <sys/stat.h>
+# include <fcntl.h>
+# include <ctype.h>
+
+# define FUSENT_MAX_PATH 256
+#endif /* __CYGWIN__ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <string.h>
 #include <unistd.h>
 #include <limits.h>
 #include <errno.h>
 
 #define PARAM(inarg) (((char *)(inarg)) + sizeof(*(inarg)))
 #define OFFSET_MAX 0x7fffffffffffffffLL
 
+#ifdef __CYGWIN__
+// Sets up any data structures the fusent translate layer will need to persist
+// across calls.
+
+// Conversion descriptor for iconv; used to convert between UTF-16LE Windows filenames
+// and UTF-8 FUSE-hosted filesystem names.
+static iconv_t cd_utf16le_to_utf8;
+
+// Maps between open FileObject pointers (fops) and fuse_file_info pointers / inode numbers:
+static st_table *fusent_fop_fi_map;
+static st_table *fusent_fop_ino_map;
+// Map to basenames:
+static st_table *fusent_fop_basename_map;
+// Map to open file offsets:
+static st_table *fusent_fop_pos_map;
+// Map to open file sync flag:
+static st_table *fusent_fop_sync_map;
+// Map to open directory listings; ghetto, but, whatever:
+typedef struct {
+	int64_t off;
+	uint32_t len, singlefile;
+	char *listing;
+} FUSENT_DIRLISTING;
+static st_table *fusent_fop_dirlisting_map;
+
+void fusent_translate_setup()
+{
+	cd_utf16le_to_utf8 = iconv_open("UTF-8//IGNORE", "UTF-16LE");
+	fusent_fop_fi_map = st_init_numtable();
+	fusent_fop_ino_map = st_init_numtable();
+	fusent_fop_basename_map = st_init_numtable();
+	fusent_fop_pos_map = st_init_numtable();
+	fusent_fop_sync_map = st_init_numtable();
+	fusent_fop_dirlisting_map = st_init_numtable();
+}
+
+// Destroys any persistant data structures at shut down.
+void fusent_translate_teardown()
+{
+	st_free_table(fusent_fop_dirlisting_map);
+	st_free_table(fusent_fop_sync_map);
+	st_free_table(fusent_fop_pos_map);
+	st_free_table(fusent_fop_basename_map);
+	st_free_table(fusent_fop_ino_map);
+	st_free_table(fusent_fop_fi_map);
+	iconv_close(cd_utf16le_to_utf8);
+}
+
+static inline size_t max_sz(size_t a, size_t b)
+{
+	if (a < b) return b;
+	return a;
+}
+
+// Returns 1 if sync, 0 if async, -1 on lookup fail:
+static inline int fusent_is_sync(FILE_OBJECT *fop)
+{
+	st_data_t issync;
+	if (!st_lookup(fusent_fop_sync_map, (st_data_t)fop, &issync))
+		return -1;
+
+	return (int)issync;
+}
+
+// Given a LARGE_INTEGER offset from an IO_STACK_LOCATION and the current file position,
+// figure out where a read or write should be performed:
+//
+// Hack:
+#ifndef FILE_USE_FILE_POINTER_POSITION
+# define FILE_USE_FILE_POINTER_POSITION (-2)
+#endif
+static inline uint64_t fusent_readwrite_offset(FILE_OBJECT *fop, uint64_t curoff, LARGE_INTEGER off)
+{
+	int issync = fusent_is_sync(fop);
+
+	if (issync < 0)
+		fprintf(stderr, "Err: couldn't find sync flag for fop: %p\n", fop);
+
+	// This is how I interpret http://msdn.microsoft.com/en-us/library/ff549327.aspx --cemeyer:
+	if ((issync == 1) && (
+				(off.LowPart == FILE_USE_FILE_POINTER_POSITION && off.HighPart == -1) ||
+				!off.QuadPart))
+		return curoff;
+
+	if (off.QuadPart < 0)
+		fprintf(stderr, "Err: Got negative offset? %lld\n", off.QuadPart);
+
+	return (uint64_t)off.QuadPart; // w32 uses an i64, fuse wants u64
+}
+
+// Add the fh <-> fop mapping to our maps:
+static inline void fusent_add_fop_mapping(PFILE_OBJECT fop, struct fuse_file_info *fi, fuse_ino_t ino, char *basename, int issync)
+{
+	st_insert(fusent_fop_fi_map, (st_data_t)fop, (st_data_t)fi);
+	st_insert(fusent_fop_ino_map, (st_data_t)fop, (st_data_t)ino);
+	uint64_t *fpos = calloc(1, sizeof(uint64_t));
+	*fpos = 0;
+	st_insert(fusent_fop_pos_map, (st_data_t)fop, (st_data_t)fpos);
+	uintptr_t sync = issync;
+	st_insert(fusent_fop_sync_map, (st_data_t)fop, (st_data_t)sync);
+
+	// Transcode the basename into native Windows WCHARs:
+	size_t bnlen = strlen(basename);
+	WCHAR *wcbasename = malloc(sizeof(WCHAR) * (bnlen + 1));
+	fusent_transcode(basename, bnlen, wcbasename, sizeof(WCHAR) * bnlen, "UTF-8", "UTF-16LE");
+	wcbasename[bnlen] = L'\0';
+
+	st_insert(fusent_fop_basename_map, (st_data_t)fop, (st_data_t)wcbasename);
+
+	fprintf(stderr, "Added fop mapping: %p -> %p, %lu, `%s'\n", fop, fi, ino, basename);
+}
+
+// Lookup the corresponding file_info pointer for an open file handle (fop).
+// Negative on error, zero on success.
+static inline int fusent_fi_inode_basename_from_fop(PFILE_OBJECT fop, struct fuse_file_info **fi_out, fuse_ino_t *ino_out, WCHAR **bn_out)
+{
+	int res;
+	st_data_t rfi, rino, rbn;
+
+	res = st_lookup(fusent_fop_fi_map, (st_data_t)fop, &rfi) - 1;
+	if (!res) *fi_out = (struct fuse_file_info *)rfi;
+	else return res;
+
+	res = st_lookup(fusent_fop_ino_map, (st_data_t)fop, &rino) - 1;
+	if (!res) *ino_out = (fuse_ino_t)rino;
+	else return res;
+
+	res = st_lookup(fusent_fop_basename_map, (st_data_t)fop, &rbn) - 1;
+	if (!res) *bn_out = (WCHAR *)rbn;
+	return res;
+}
+
+// Removes a fop mapping
+static inline void fusent_remove_fop_mapping(PFILE_OBJECT fop)
+{
+	struct fuse_file_info *rfi;
+	fuse_ino_t ino;
+	WCHAR *bn;
+	if (fusent_fi_inode_basename_from_fop(fop, &rfi, &ino, &bn) < 0) return;
+
+	free(rfi);
+	free(bn);
+
+	st_data_t irfop = (st_data_t)fop;
+	st_delete(fusent_fop_fi_map, &irfop, NULL);
+
+	irfop = (st_data_t)fop;
+	st_delete(fusent_fop_ino_map, &irfop, NULL);
+
+	irfop = (st_data_t)fop;
+	st_delete(fusent_fop_basename_map, &irfop, NULL);
+
+	irfop = (st_data_t)fop;
+	st_data_t pos;
+	if (st_delete(fusent_fop_pos_map, &irfop, &pos)) {
+		if (pos) free((uint64_t *)pos);
+	}
+
+	irfop = (st_data_t)fop;
+	st_delete(fusent_fop_sync_map, &irfop, NULL);
+}
+
+// Translates a unix mode_t to windows' FileAttributes ULONG
+static void fusent_unixmode_to_winattr(mode_t m, ULONG *winattr)
+{
+	ULONG val = 0;
+	//if (S_ISBLK(m) || S_ISCHR(m))
+	//	val |= FILE_ATTRIBUTE_DEVICE;
+	//if (!(m & S_IWUSR || m & S_IWGRP || m & S_IWOTH))
+	//	val |= FILE_ATTRIBUTE_READONLY;
+	// I'm not sure we should claim a link is a reparse point:
+	//if (S_ISLNK(m))
+	//	val |= FILE_ATTRIBUTE_REPARSE_POINT;
+	if (S_ISDIR(m))
+		val |= FILE_ATTRIBUTE_DIRECTORY;
+	else
+	//if (S_ISREG(m))
+		val |= FILE_ATTRIBUTE_NORMAL;
+	//else
+	//	val |= FILE_ATTRIBUTE_SYSTEM;
+
+	*winattr = val;
+}
+#endif /* __CYGWIN__ */
+
 struct fuse_pollhandle {
 	uint64_t kh;
 	struct fuse_chan *ch;
 	struct fuse_ll *f;
 };
 
 static void convert_stat(const struct stat *stbuf, struct fuse_attr *attr)
 {
 	attr->ino	= stbuf->st_ino;
 	attr->mode	= stbuf->st_mode;
 	attr->nlink	= stbuf->st_nlink;
 	attr->uid	= stbuf->st_uid;
 	attr->gid	= stbuf->st_gid;
 	attr->rdev	= stbuf->st_rdev;
 	attr->size	= stbuf->st_size;
 	attr->blksize	= stbuf->st_blksize;
 	attr->blocks	= stbuf->st_blocks;
 	attr->atime	= stbuf->st_atime;
 	attr->mtime	= stbuf->st_mtime;
 	attr->ctime	= stbuf->st_ctime;
 	attr->atimensec = ST_ATIM_NSEC(stbuf);
 	attr->mtimensec = ST_MTIM_NSEC(stbuf);
 	attr->ctimensec = ST_CTIM_NSEC(stbuf);
 }
 
 static void convert_attr(const struct fuse_setattr_in *attr, struct stat *stbuf)
 {
 	stbuf->st_mode	       = attr->mode;
 	stbuf->st_uid	       = attr->uid;
 	stbuf->st_gid	       = attr->gid;
 	stbuf->st_size	       = attr->size;
 	stbuf->st_atime	       = attr->atime;
 	stbuf->st_mtime	       = attr->mtime;
 	ST_ATIM_NSEC_SET(stbuf, attr->atimensec);
 	ST_MTIM_NSEC_SET(stbuf, attr->mtimensec);
 }
 
-static	size_t iov_length(const struct iovec *iov, size_t count)
+static inline size_t iov_length(const struct iovec *iov, size_t count)
 {
 	size_t seg;
 	size_t ret = 0;
 
 	for (seg = 0; seg < count; seg++)
 		ret += iov[seg].iov_len;
 	return ret;
 }
 
 static void list_init_req(struct fuse_req *req)
 {
 	req->next = req;
 	req->prev = req;
 }
 
 static void list_del_req(struct fuse_req *req)
 {
 	struct fuse_req *prev = req->prev;
 	struct fuse_req *next = req->next;
 	prev->next = next;
@@ -110,106 +312,133 @@ void fuse_free_req(fuse_req_t req)
 	req->u.ni.data = NULL;
 	list_del_req(req);
 	ctr = --req->ctr;
 	pthread_mutex_unlock(&f->lock);
 	if (!ctr)
 		destroy_req(req);
 }
 
 int fuse_send_reply_iov_nofree(fuse_req_t req, int error, struct iovec *iov,
 			       int count)
 {
 	struct fuse_out_header out;
 
 	if (error <= -1000 || error > 0) {
 		fprintf(stderr, "fuse: bad error value: %i\n",	error);
 		error = -ERANGE;
 	}
 
 	out.unique = req->unique;
 	out.error = error;
+
 	iov[0].iov_base = &out;
 	iov[0].iov_len = sizeof(struct fuse_out_header);
 	out.len = iov_length(iov, count);
 
 	if (req->f->debug) {
 		if (out.error) {
 			fprintf(stderr,
 				"   unique: %llu, error: %i (%s), outsize: %i\n",
 				(unsigned long long) out.unique, out.error,
 				strerror(-out.error), out.len);
 		} else {
 			fprintf(stderr,
 				"   unique: %llu, success, outsize: %i\n",
 				(unsigned long long) out.unique, out.len);
 		}
 	}
 
+#ifdef __CYGWIN__
+	if (req->response_hijack) {
+		*req->response_hijack = out;
+		if (req->response_hijack_buf && count > 1) {
+			size_t len = iov[1].iov_len;
+			printf("reply_iov_nofree copying 0x%.8x bytes from %p to %p\n", len, iov[1].iov_base, req->response_hijack_buf);
+			// Ensure that buf is large enough to hold iov (copy as much as we can):
+			if (len > req->response_hijack_buflen) len = req->response_hijack_buflen;
+			
+			memcpy(req->response_hijack_buf, iov[1].iov_base, len);
+
+			// Report a possible short write:
+			req->response_hijack_buflen = iov[1].iov_len;
+		}
+		return 0;
+	}
+#endif
+
 	return fuse_chan_send(req->ch, iov, count);
 }
 
 static int send_reply_iov(fuse_req_t req, int error, struct iovec *iov,
 			  int count)
 {
 	int res;
 
 	res = fuse_send_reply_iov_nofree(req, error, iov, count);
-	fuse_free_req(req);
+	// fuse_free_req(req);
 	return res;
 }
 
 static int send_reply(fuse_req_t req, int error, const void *arg,
 		      size_t argsize)
 {
 	struct iovec iov[2];
 	int count = 1;
 	if (argsize) {
 		iov[1].iov_base = (void *) arg;
 		iov[1].iov_len = argsize;
 		count++;
 	}
 	return send_reply_iov(req, error, iov, count);
 }
 
 int fuse_reply_iov(fuse_req_t req, const struct iovec *iov, int count)
 {
 	int res;
 	struct iovec *padded_iov;
 
 	padded_iov = malloc((count + 1) * sizeof(struct iovec));
 	if (padded_iov == NULL)
 		return fuse_reply_err(req, -ENOMEM);
 
 	memcpy(padded_iov + 1, iov, count * sizeof(struct iovec));
 	count++;
 
 	res = send_reply_iov(req, 0, padded_iov, count);
 	free(padded_iov);
 
 	return res;
 }
 
 size_t fuse_dirent_size(size_t namelen)
 {
 	return FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + namelen);
 }
 
+static size_t fusent_fdient_size(size_t namelenbytes)
+{
+	// Turns out FUSE_DIRENT_ALIGN aligns along 8-byte boundaries too; this
+	// is all Windows requires for packed FILE_DIRECTORY_INFORMATION structs.
+	return FUSE_DIRENT_ALIGN(sizeof(FILE_DIRECTORY_INFORMATION) +
+			namelenbytes - sizeof(WCHAR));
+}
+
 char *fuse_add_dirent(char *buf, const char *name, const struct stat *stbuf,
 		      off_t off)
 {
 	unsigned namelen = strlen(name);
 	unsigned entlen = FUSE_NAME_OFFSET + namelen;
 	unsigned entsize = fuse_dirent_size(namelen);
 	unsigned padlen = entsize - entlen;
 	struct fuse_dirent *dirent = (struct fuse_dirent *) buf;
 
 	dirent->ino = stbuf->st_ino;
 	dirent->off = off;
 	dirent->namelen = namelen;
 	dirent->type = (stbuf->st_mode & 0170000) >> 12;
 	strncpy(dirent->name, name, namelen);
 	if (padlen)
 		memset(buf + entlen, 0, padlen);
 
 	return buf + entsize;
 }
 
@@ -233,40 +462,46 @@ static void convert_statfs(const struct
 	kstatfs->blocks	 = stbuf->f_blocks;
 	kstatfs->bfree	 = stbuf->f_bfree;
 	kstatfs->bavail	 = stbuf->f_bavail;
 	kstatfs->files	 = stbuf->f_files;
 	kstatfs->ffree	 = stbuf->f_ffree;
 	kstatfs->namelen = stbuf->f_namemax;
 }
 
 static int send_reply_ok(fuse_req_t req, const void *arg, size_t argsize)
 {
 	return send_reply(req, 0, arg, argsize);
 }
 
 int fuse_reply_err(fuse_req_t req, int err)
 {
 	return send_reply(req, -err, NULL, 0);
 }
 
 void fuse_reply_none(fuse_req_t req)
 {
+
+#ifdef __CYGWIN__
+	if (req->response_hijack)
+		memset(req->response_hijack, 0, sizeof(struct fuse_out_header));
+	else
+#endif
 	fuse_chan_send(req->ch, NULL, 0);
 	fuse_free_req(req);
 }
 
 static unsigned long calc_timeout_sec(double t)
 {
 	if (t > (double) ULONG_MAX)
 		return ULONG_MAX;
 	else if (t < 0.0)
 		return 0;
 	else
 		return (unsigned long) t;
 }
 
 static unsigned int calc_timeout_nsec(double t)
 {
 	double f = t - (double) calc_timeout_sec(t);
 	if (f < 0.0)
 		return 0;
 	else if (f >= 0.999999999)
@@ -742,40 +977,44 @@ static void do_read(fuse_req_t req, fuse
 
 static void do_write(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
 {
 	struct fuse_write_in *arg = (struct fuse_write_in *) inarg;
 	struct fuse_file_info fi;
 	char *param;
 
 	memset(&fi, 0, sizeof(fi));
 	fi.fh = arg->fh;
 	fi.fh_old = fi.fh;
 	fi.writepage = arg->write_flags & 1;
 
 	if (req->f->conn.proto_minor < 9) {
 		param = ((char *) arg) + FUSE_COMPAT_WRITE_IN_SIZE;
 	} else {
 		fi.lock_owner = arg->lock_owner;
 		fi.flags = arg->flags;
 		param = PARAM(arg);
 	}
 
+#ifdef __CYGWIN__
+	param = req->response_hijack_buf; // abusing the crap out of this, oops
+#endif
+
 	if (req->f->op.write)
 		req->f->op.write(req, nodeid, param, arg->size,
 				 arg->offset, &fi);
 	else
 		fuse_reply_err(req, ENOSYS);
 }
 
 static void do_flush(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
 {
 	struct fuse_flush_in *arg = (struct fuse_flush_in *) inarg;
 	struct fuse_file_info fi;
 
 	memset(&fi, 0, sizeof(fi));
 	fi.fh = arg->fh;
 	fi.fh_old = fi.fh;
 	fi.flush = 1;
 	if (req->f->conn.proto_minor >= 7)
 		fi.lock_owner = arg->lock_owner;
 
 	if (req->f->op.flush)
@@ -1039,61 +1278,64 @@ static int find_interrupted(struct fuse_
 static void do_interrupt(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
 {
 	struct fuse_interrupt_in *arg = (struct fuse_interrupt_in *) inarg;
 	struct fuse_ll *f = req->f;
 
 	(void) nodeid;
 	if (f->debug)
 		fprintf(stderr, "INTERRUPT: %llu\n",
 			(unsigned long long) arg->unique);
 
 	req->u.i.unique = arg->unique;
 
 	pthread_mutex_lock(&f->lock);
 	if (find_interrupted(f, req))
 		destroy_req(req);
 	else
 		list_add_req(req, &f->interrupts);
 	pthread_mutex_unlock(&f->lock);
 }
 
+// This is only used by a Unix-only portion of fuse_ll_process:
+#ifndef __CYGWIN__
 static struct fuse_req *check_interrupt(struct fuse_ll *f, struct fuse_req *req)
 {
 	struct fuse_req *curr;
 
 	for (curr = f->interrupts.next; curr != &f->interrupts;
 	     curr = curr->next) {
 		if (curr->u.i.unique == req->unique) {
 			req->interrupted = 1;
 			list_del_req(curr);
 			free(curr);
 			return NULL;
 		}
 	}
 	curr = f->interrupts.next;
 	if (curr != &f->interrupts) {
 		list_del_req(curr);
 		list_init_req(curr);
 		return curr;
 	} else
 		return NULL;
 }
+#endif /* __CYGWIN__ */
 
 static void do_bmap(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
 {
 	struct fuse_bmap_in *arg = (struct fuse_bmap_in *) inarg;
 
 	if (req->f->op.bmap)
 		req->f->op.bmap(req, nodeid, arg->blocksize, arg->block);
 	else
 		fuse_reply_err(req, ENOSYS);
 }
 
 static void do_ioctl(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
 {
 	struct fuse_ioctl_in *arg = (struct fuse_ioctl_in *) inarg;
 	unsigned int flags = arg->flags;
 	void *in_buf = arg->in_size ? PARAM(arg) : NULL;
 	struct fuse_file_info fi;
 
 	memset(&fi, 0, sizeof(fi));
 	fi.fh = arg->fh;
@@ -1419,62 +1661,1269 @@ static struct {
 	[FUSE_SETXATTR]	   = { do_setxattr,    "SETXATTR"    },
 	[FUSE_GETXATTR]	   = { do_getxattr,    "GETXATTR"    },
 	[FUSE_LISTXATTR]   = { do_listxattr,   "LISTXATTR"   },
 	[FUSE_REMOVEXATTR] = { do_removexattr, "REMOVEXATTR" },
 	[FUSE_FLUSH]	   = { do_flush,       "FLUSH"	     },
 	[FUSE_INIT]	   = { do_init,	       "INIT"	     },
 	[FUSE_OPENDIR]	   = { do_opendir,     "OPENDIR"     },
 	[FUSE_READDIR]	   = { do_readdir,     "READDIR"     },
 	[FUSE_RELEASEDIR]  = { do_releasedir,  "RELEASEDIR"  },
 	[FUSE_FSYNCDIR]	   = { do_fsyncdir,    "FSYNCDIR"    },
 	[FUSE_GETLK]	   = { do_getlk,       "GETLK"	     },
 	[FUSE_SETLK]	   = { do_setlk,       "SETLK"	     },
 	[FUSE_SETLKW]	   = { do_setlkw,      "SETLKW"	     },
 	[FUSE_ACCESS]	   = { do_access,      "ACCESS"	     },
 	[FUSE_CREATE]	   = { do_create,      "CREATE"	     },
 	[FUSE_INTERRUPT]   = { do_interrupt,   "INTERRUPT"   },
 	[FUSE_BMAP]	   = { do_bmap,	       "BMAP"	     },
 	[FUSE_IOCTL]	   = { do_ioctl,       "IOCTL"	     },
 	[FUSE_POLL]	   = { do_poll,        "POLL"	     },
 	[FUSE_DESTROY]	   = { do_destroy,     "DESTROY"     },
+#if defined __CYGWIN__
+	[CUSE_INIT]	   = { NULL,           "CUSE_INIT"   },
+#else
 	[CUSE_INIT]	   = { cuse_lowlevel_init, "CUSE_INIT"   },
+#endif
 };
 
 #define FUSE_MAXOP (sizeof(fuse_ll_ops) / sizeof(fuse_ll_ops[0]))
 
+// This is only used by a Unix-only part of fuse_ll_process:
+#ifndef __CYGWIN__
 static const char *opname(enum fuse_opcode opcode)
 {
 	if (opcode >= FUSE_MAXOP || !fuse_ll_ops[opcode].name)
 		return "???";
 	else
 		return fuse_ll_ops[opcode].name;
 }
+#endif
+
+#ifdef __CYGWIN__
+// Does an in-place conversion of a Windows-formatted buffer to
+// Unix-formatted. Probably buggy.
+static void fusent_convert_win_path(char *buf, size_t *len) {
+	size_t i;
+	// For now:
+	//   1) Replace backslashes with slashes
+	for (i = 0; i < *len; i++) {
+		if (buf[i] == '\\') buf[i] = '/';
+	}
+
+	//   2) Strip any beginning drive
+	if (*len > 2 && isalpha((int)buf[0]) && buf[1] == ':') {
+		*len = *len - 2;
+		memmove(buf, &buf[2], *len);
+	}
+}
+
+// Get the current read/write offset for the given file object
+static uint64_t fusent_get_file_offset(PFILE_OBJECT fop)
+{
+	st_data_t poffset;
+
+	if (st_lookup(fusent_fop_pos_map, (st_data_t)fop, &poffset))
+		return *((uint64_t *) poffset);
+	else
+		return 0;
+}
+
+// Sets the current file offset to the given offset
+static int fusent_set_file_offset(PFILE_OBJECT fop, uint64_t offset) {
+	int res;
+	st_data_t data_offset;
+
+	res = st_lookup(fusent_fop_pos_map, (st_data_t)fop, &data_offset) - 1;
+	if (!res)
+		*((uint64_t *) data_offset) = offset;
+
+	return res;
+}
+
+// Given a path in `fn' (assume unix format), find the inode of the parent.
+//   e.g. /sbin/route -> inode of /sbin
+// Additionally, locate the offset of the basename in the buffer and
+// return a pointer to it.
+//
+// Returns negative if the parent can't be found or the path is invalid:
+//      stdint.h -> err
+static int fusent_get_parent_inode(fuse_req_t req, char *fn, char **bn, fuse_ino_t *in) {
+	if (*fn != '/') return -1;
+	if (!req->f->op.lookup) return -1;
+	fn ++;
+
+	const size_t buflen = sizeof(struct fuse_entry_out);
+
+	fuse_ino_t curino = FUSE_ROOT_ID;
+	char *hijackbuf = malloc(buflen);
+
+	for (;;) {
+		// This is totally fine in UTF-8, by the way:
+		char *nextsl = strchr(fn, '/');
+
+		// If there are no more slashes, we've located the basename and
+		// parent inode number already:
+		if (!nextsl) {
+			*bn = fn;
+			*in = curino;
+			free(hijackbuf);
+			return 0;
+		}
+
+		// Otherwise, lookup the next component of the path:
+		*nextsl = '\0';
+		struct fuse_out_header out;
+		req->response_hijack = &out;
+		req->response_hijack_buf = hijackbuf;
+		req->response_hijack_buflen = buflen;
+
+		fuse_ll_ops[FUSE_LOOKUP].func(req, curino, fn);
+
+		req->response_hijack = NULL;
+		req->response_hijack_buf = NULL;
+		*nextsl = '/';
+
+		if (out.error) {
+			free(hijackbuf);
+			return out.error;
+		}
+
+		struct fuse_entry_out *lookuparg = (struct fuse_entry_out *)hijackbuf;
+
+		curino = lookuparg->nodeid;
+		fn = nextsl + 1;
+	}
+}
+
+// Given a path in `fn', locate the inode for `fn'.
+// Returns negative if `fn' can't be found.
+static int fusent_get_inode(fuse_req_t req, char *fn, fuse_ino_t *in, char **bn)
+{
+	char path[FUSENT_MAX_PATH + 3];
+	size_t sl = strlen(fn);
+	memcpy(path, fn, sl);
+
+	// As a giant hack, fusenet_get_parent_inode doesn't care if the last
+	// "parent" component is a directory, so let's just abuse that to
+	// get the inode for now:
+	path[sl]   = '/';
+	path[sl+1] = 'a';
+	path[sl+2] = '\0';
+
+	char *bn_t;
+	int res = fusent_get_parent_inode(req, path, &bn_t, in);
+	if (bn && res >= 0) {
+		*bn = fn + (bn_t - path);
+	}
+	return res;
+}
+
+static inline NTSTATUS fusent_translate_errno(int err)
+{
+	if (err >= 0) return STATUS_SUCCESS;
+
+	switch (err) {
+		case EACCES: return STATUS_ACCESS_DENIED;
+		case EBADF: return STATUS_INVALID_HANDLE;
+		case ENOENT: return STATUS_NO_SUCH_FILE;
+		case EEXIST: return STATUS_CANNOT_MAKE;
+		case ENOSPC: break;
+		case ENOSYS: return STATUS_NOT_IMPLEMENTED;
+		case EAGAIN: return STATUS_RETRY;
+	}
+
+	return STATUS_UNSUCCESSFUL;
+}
+
+static inline void fusent_fill_resp(FUSENT_RESP *resp, IRP *pirp, FILE_OBJECT *fop, int error)
+{
+	memset(resp, 0, sizeof(FUSENT_RESP));
+	resp->pirp = pirp;
+	resp->fop = fop;
+	resp->error = error;
+	resp->status = fusent_translate_errno(error);
+}
+
+// Sends a response to the kernel. len is not always == sizeof(FUSENT_RESP),
+// so we need to take a parameter.
+static inline void fusent_sendmsg(fuse_req_t req, FUSENT_RESP *resp, size_t len)
+{
+	struct iovec iov;
+	iov.iov_base = resp;
+	iov.iov_len = len;
+
+	fuse_chan_send(req->ch, &iov, 1);
+}
+
+// Send an error reply back to the kernel:
+static void fusent_reply_error(fuse_req_t req, PIRP pirp, PFILE_OBJECT fop, int error)
+{
+	FUSENT_RESP resp;
+	fusent_fill_resp(&resp, pirp, fop, -error);
+	fusent_sendmsg(req, &resp, sizeof(FUSENT_RESP));
+}
+
+// Send a successful response to an IRP_MJ_CREATE irp down to the kernel:
+static void fusent_reply_create(fuse_req_t req, PIRP pirp, PFILE_OBJECT fop)
+{
+	fusent_reply_error(req, pirp, fop, 0);
+}
+
+// Send a successful response to an IRP_MJ_WRITE irp down to the kernel:
+static void fusent_reply_write(fuse_req_t req, PIRP pirp, PFILE_OBJECT fop, uint32_t written)
+{
+	FUSENT_RESP resp;
+	fusent_fill_resp(&resp, pirp, fop, 0);
+	resp.params.write.written = written;
+	fusent_sendmsg(req, &resp, sizeof(FUSENT_RESP));
+}
+
+// Send a successful response to an IRP_MJ_READ irp down to the kernel:
+// buf should have space for a FUSENT_RESP at the beginning.
+// buflen includes this.
+static void fusent_reply_read(fuse_req_t req, PIRP pirp, PFILE_OBJECT fop, uint32_t buflen, char *buf)
+{
+	FUSENT_RESP *resp = (FUSENT_RESP *)buf;
+	fusent_fill_resp(resp, pirp, fop, 0);
+
+	uint32_t readlen = buflen - sizeof(FUSENT_RESP);
+	resp->params.read.buflen = readlen;
+
+	if (!readlen)
+		resp->status = STATUS_END_OF_FILE;
+
+	fusent_sendmsg(req, resp, buflen);
+}
+
+// Send a successful response to an IRP_MJ_DIRECTORY_CONTROL irp down to the kernel:
+// buf should have space for a FUSENT_RESP at the beginning.
+// buflen includes this.
+static void fusent_reply_dirctrl(fuse_req_t req, PIRP pirp, PFILE_OBJECT fop, uint32_t buflen, char *buf)
+{
+	FUSENT_RESP *resp = (FUSENT_RESP *)buf;
+	fusent_fill_resp(resp, pirp, fop, 0);
+
+	uint32_t readlen = buflen - sizeof(FUSENT_RESP);
+	resp->params.dirctrl.buflen = readlen;
+
+	fusent_sendmsg(req, resp, buflen);
+}
+
+static void fusent_reply_query_information(fuse_req_t req, PIRP pirp, PFILE_OBJECT fop, struct fuse_attr *st, WCHAR *basename)
+{
+	size_t buflen = sizeof(FUSENT_RESP) + sizeof(FUSENT_FILE_INFORMATION);
+	FUSENT_FILE_INFORMATION *fileinfo;
+	FUSENT_RESP *resp = malloc(buflen);
+
+	fileinfo = (FUSENT_FILE_INFORMATION*) (resp + 1);
+
+	// Fill in the standard header bits:
+	fusent_fill_resp(resp, pirp, fop, 0);
+
+	resp->params.query.buflen = sizeof(FUSENT_FILE_INFORMATION);
+
+	// Fill in the rest:
+	fusent_unixtime_to_wintime(st->atime, &fileinfo->LastAccessTime);
+	fusent_unixtime_to_wintime(st->mtime, &fileinfo->LastWriteTime);
+
+	// Take the most recent of {mtime,ctime} for windows' "changetime"
+	time_t ctime = (st->mtime > st->ctime)? st->mtime : st->ctime;
+	fusent_unixtime_to_wintime(ctime, &fileinfo->ChangeTime);
+
+	fusent_unixmode_to_winattr(st->mode, &fileinfo->FileAttributes);
+
+	fileinfo->AllocationSize.QuadPart = ((int64_t)st->blocks) * 512;
+	fileinfo->EndOfFile.QuadPart = (int64_t)st->size;
+	fileinfo->NumberOfLinks = st->nlink;
+	fileinfo->Directory = S_ISDIR(st->mode);
+
+	fileinfo->DeletePending = FALSE;
+	fusent_unixtime_to_wintime(0, &fileinfo->CreationTime);
+
+	fusent_sendmsg(req, resp, buflen);
+	free(resp);
+}
+
+// Handle an IRP_MJ_CREATE call
+static void fusent_do_create(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	// Some of the behavior here probably doesn't match
+	// one-to-one with NT. Does anyone actually use
+	// FILE_SUPERSEDE? We ignore a lot of CreateOptions flags.
+	// -- cemeyer
+
+	// Decode NT operation flags from IRP:
+	uint32_t CreateOptions = iosp->Parameters.Create.Options;
+	uint16_t ShareAccess = iosp->Parameters.Create.ShareAccess;
+	uint8_t CreateDisp = CreateOptions >> 24;
+
+	int issync = 0;
+	if ((CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) ||
+			(CreateOptions & FILE_SYNCHRONOUS_IO_NONALERT) ||
+			(ntreq->irp.Flags & IRP_SYNCHRONOUS_API))
+		issync = 1;
+
+	int fuse_flags = 0, mode = S_IRWXU | S_IRWXG | S_IRWXO;
+	if (CreateDisp != FILE_OPEN && CreateDisp != FILE_OVERWRITE)
+		fuse_flags |= O_CREAT;
+	if (CreateDisp == FILE_CREATE) fuse_flags |= O_EXCL;
+	if (CreateDisp == FILE_OVERWRITE || CreateDisp == FILE_OVERWRITE_IF ||
+			CreateDisp == FILE_SUPERSEDE)
+		fuse_flags |= O_TRUNC;
+	if (CreateOptions & FILE_DIRECTORY_FILE) fuse_flags |= O_DIRECTORY;
+
+	// Extract the file path from the NT request:
+	uint32_t fnamelen;
+	uint16_t *fnamep;
+	fusent_decode_request_create((FUSENT_CREATE_REQ *)ntreq,
+			&fnamelen, &fnamep);
+
+	// Translate it to UTF8:
+	char *inbuf = (char *)fnamep;
+	size_t inbytes = fnamelen, outbytes = FUSENT_MAX_PATH-1;
+
+	char *llargs;
+	fuse_ino_t llinode;
+	int llop, err;
+
+	fuse_ino_t fino = 0;;
+	struct fuse_file_info *fi = NULL;
+
+	char *basename;
+	char *stbuf = malloc(FUSENT_MAX_PATH + max_sz(sizeof(struct fuse_create_in),
+				sizeof(struct fuse_open_in)));
+	char *outbuf, *outbuf2;
+
+	if (fuse_flags & O_CREAT)
+		outbuf = stbuf + sizeof(struct fuse_create_in);
+	else
+		outbuf = stbuf + sizeof(struct fuse_open_in);
+
+	outbuf2 = outbuf;
+
+	// Convert and then reset the cd
+	iconv(cd_utf16le_to_utf8, &inbuf, &inbytes, &outbuf, &outbytes);
+	iconv(cd_utf16le_to_utf8, NULL, NULL, NULL, NULL);
+	size_t utf8len = outbuf - outbuf2;
+
+	// Convert the path to a unix-like path
+	fusent_convert_win_path(outbuf2, &utf8len);
+
+	// A huge hack to make this work for helloworld.
+	// TODO(cemeyer) make this general purpose (for any directory):
+	// (This will require getattr'ing the file, I think.)
+	if (!strncmp(outbuf2, "/", utf8len)) {
+		fino = FUSE_ROOT_ID;
+		basename = malloc(strlen("/") + 1);
+		memcpy(basename, "/", strlen("/") + 1);
+		goto reply_create_nt;
+	}
+
+	if (fuse_flags & O_CREAT) {
+		// Look up inode for the parent directory of the file we want to create:
+		struct fuse_create_in *args = (struct fuse_create_in *)stbuf;
+		args->flags = fuse_flags;
+		args->umask = S_IXGRP | S_IXOTH;
+
+		fuse_ino_t par_inode;
+		if (fusent_get_parent_inode(req, outbuf2, &basename, &par_inode) < 0) {
+			err = ENOENT;
+			fprintf(stderr, "CREATE failed because parent does not exist: (%d)`%s' fnamep: (%d)`%S'\n", utf8len, outbuf2, fnamelen, fnamep);
+			goto reply_err_nt;
+		}
+
+		// creat() expects just the basename of the file:
+		memmove(outbuf2, basename, outbuf - basename);
+		outbuf2[outbuf - basename] = '\0';
+
+		llop = FUSE_CREATE;
+		llinode = par_inode;
+		llargs = (char *)args;
+	}
+	else {
+		// Lookup inode for the file we are to open:
+		struct fuse_open_in *args = (struct fuse_open_in *)stbuf;
+		args->flags = fuse_flags;
+
+		fuse_ino_t inode;
+		if (fusent_get_inode(req, outbuf2, &inode, &basename) < 0) {
+			err = ENOENT;
+			fprintf(stderr, "OPEN failed because path does not exist: `%s'\n", outbuf2);
+			goto reply_err_nt;
+		}
+
+		fprintf(stderr, "OPEN: resolved `%s' -> %lu\n", outbuf2, inode);
+
+		fino = inode;
+
+		llop = FUSE_OPEN;
+		llinode = inode;
+		llargs = (char *)args;
+	}
+
+	struct fuse_out_header outh;
+
+	// OPEN => fuse_open_out;
+	// CREATE => fuse_entry_out + fuse_open_out
+	const size_t buflen = sizeof(struct fuse_entry_out) +
+		sizeof(struct fuse_open_out);
+
+	char *giantbuf = malloc(buflen);
+	req->response_hijack = &outh;
+	req->response_hijack_buf = giantbuf;
+	req->response_hijack_buflen = buflen;
+
+	fuse_ll_ops[llop].func(req, llinode, llargs);
+
+	req->response_hijack = NULL;
+	req->response_hijack_buf = NULL;
+
+	if (outh.error) {
+		// outh.error will be >= -1000 and <= 0:
+		err = -outh.error;
+		free(giantbuf);
+		fprintf(stderr, "CREATE or OPEN failed (%s,%d): `%s'\n", strerror(-outh.error), -outh.error, outbuf2);
+		goto reply_err_nt;
+	}
+
+	struct fuse_open_out *openresp = (struct fuse_open_out *)giantbuf;
+	if (llop == FUSE_CREATE) {
+		openresp = (struct fuse_open_out *)(giantbuf + sizeof(struct fuse_entry_out));
+		fino = ((struct fuse_entry_out *)giantbuf)->nodeid;
+	}
+
+	fi = malloc(sizeof(struct fuse_file_info));
+	fi->fh = openresp->fh;
+	fi->flags = openresp->open_flags;
+	free(giantbuf);
+
+reply_create_nt:
+	fprintf(stderr, "CREATE|OPEN: replying success!\n");
+	fusent_add_fop_mapping(ntreq->fop, fi, fino, basename, issync);
+	fusent_reply_create(req, ntreq->pirp, ntreq->fop);
+	free(stbuf);
+	return;
+
+reply_err_nt:
+	free(stbuf);
+	fprintf(stderr, "CREATE|OPEN: replying error(%d) `%s'\n", err, strerror(err));
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_READ request
+static void fusent_do_read(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	PFILE_OBJECT fop = ntreq->fop;
+	ULONG len = iosp->Parameters.Read.Length;
+	LARGE_INTEGER off = iosp->Parameters.Read.ByteOffset;
+	int err;
+
+	struct fuse_file_info *fi = NULL;
+	fuse_ino_t inode = 0;
+	WCHAR *bn = NULL;
+	if (fusent_fi_inode_basename_from_fop(fop, &fi, &inode, &bn) < 0) {
+		err = EBADF;
+		goto reply_err_nt;
+	}
+	if (!fi) {
+		err = EBADF;
+		fprintf(stderr, "READ: got fop without fi: %p\n", fop);
+		goto reply_err_nt;
+	}
+
+	uint64_t current_offset = fusent_get_file_offset(fop);
+
+	struct fuse_out_header outh;
+	char *giantbuf = malloc(sizeof(FUSENT_RESP) + len);
+	req->response_hijack = &outh;
+	req->response_hijack_buf = giantbuf + sizeof(FUSENT_RESP);
+	req->response_hijack_buflen = len;
+
+	struct fuse_read_in readargs;
+	readargs.fh = fi->fh;
+	readargs.flags = fi->flags;
+	readargs.lock_owner = fi->lock_owner;
+	readargs.size = len;
+	readargs.offset = fusent_readwrite_offset(fop, current_offset, off);
+
+	fuse_ll_ops[FUSE_READ].func(req, inode, &readargs);
+
+	req->response_hijack = NULL;
+	req->response_hijack_buf = NULL;
+
+	if (outh.error) {
+		free(giantbuf);
+		err = -outh.error;
+		goto reply_err_nt;
+	}
+
+	fusent_set_file_offset(fop, readargs.offset + outh.len - sizeof(struct fuse_out_header));
+
+	fusent_reply_read(req, ntreq->pirp, ntreq->fop,
+			outh.len - sizeof(struct fuse_out_header) + sizeof(FUSENT_RESP),
+			giantbuf);
+
+	free(giantbuf);
+	return;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_WRITE request
+static void fusent_do_write(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	PFILE_OBJECT fop = ntreq->fop;
+	ULONG len = iosp->Parameters.Write.Length;
+	LARGE_INTEGER off = iosp->Parameters.Write.ByteOffset;
+	int err;
+
+	struct fuse_file_info *fi = NULL;
+	fuse_ino_t inode = 0;
+	WCHAR *bn = NULL;
+	if (fusent_fi_inode_basename_from_fop(fop, &fi, &inode, &bn) < 0) {
+		err = EBADF;
+		goto reply_err_nt;
+	}
+
+	uint32_t stoutbuf[sizeof(struct fuse_write_out) / sizeof(uint32_t)];
+	uint8_t *outbufp;
+	uint32_t outbuflen;
+	fusent_decode_request_write((FUSENT_WRITE_REQ *)ntreq, &outbuflen, &outbufp);
+
+	struct fuse_out_header outh;
+	req->response_hijack = &outh;
+
+	// If the buffer for us to write is large enough to serve dual purpose as
+	// the output buffer, use it:
+	if (outbuflen >= sizeof(struct fuse_write_out)) {
+		req->response_hijack_buf = (char *)outbufp;
+		req->response_hijack_buflen = outbuflen;
+	}
+	// Otherwise, use a temporary stack buffer:
+	else {
+		req->response_hijack_buf = (char *)stoutbuf;
+		req->response_hijack_buflen = sizeof(struct fuse_write_out);
+		memcpy(stoutbuf, outbufp, outbuflen);
+	}
+
+	uint64_t current_offset = fusent_get_file_offset(fop);
+
+	struct fuse_write_in writeargs;
+	writeargs.fh = fi->fh;
+	writeargs.flags = fi->flags;
+	writeargs.lock_owner = fi->lock_owner;
+	writeargs.size = len;
+	writeargs.offset = fusent_readwrite_offset(fop, current_offset, off);
+
+	fuse_ll_ops[FUSE_WRITE].func(req, inode, &writeargs);
+
+	uint32_t written = ((struct fuse_write_out *)req->response_hijack_buf)->size;
+	req->response_hijack = NULL;
+	req->response_hijack_buf = NULL;
+
+	if (outh.error) {
+		err = -outh.error;
+		goto reply_err_nt;
+	}
+
+	fusent_set_file_offset(fop, writeargs.offset + written);
+
+	fusent_reply_write(req, ntreq->pirp, ntreq->fop, written);
+	return;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Takes the given directory, opendirs it, readdirs it, and compiles a windows directory listing buffer
+// and throws that into the fusent_fop_dir_map hash table.
+//
+// Returns zero on success, error number on failure (positive).
+static int fusent_do_buffer_dirlisting(FUSENT_REQ *ntreq, EXTENDED_IO_STACK_LOCATION *irpsp, fuse_req_t req, fuse_ino_t inode)
+{
+	PFILE_OBJECT fop = ntreq->fop;
+	int err;
+
+	struct fuse_open_in openargs;
+	memset(&openargs, 0, sizeof(openargs));
+	openargs.flags = O_RDONLY;
+	
+	// For now, we ignore FILE_INFORMATION_CLASS and just return some set of fields
+	// to the kernel, which sorts out which fields each request needs.
+	// FILE_INFORMATION_CLASS fic = irpsp->Parameters.QueryDirectory.FileInformationClass;
+	
+	uint32_t len = 8192; // Arbitrary length --cemeyer
+	uint32_t fusebuflen = 8192;
+
+	struct fuse_out_header outh;
+	char *giantbuf = malloc(fusebuflen);
+	req->response_hijack = &outh;
+	req->response_hijack_buf = giantbuf;
+	req->response_hijack_buflen = fusebuflen;
+
+	fuse_ll_ops[FUSE_OPENDIR].func(req, inode, &openargs);
+
+	req->response_hijack = NULL;
+	req->response_hijack_buf = NULL;
+
+	if (outh.error) {
+		err = -outh.error;
+		free(giantbuf);
+		fprintf(stderr, "OPENDIR failed (%s, %d)\n", strerror(err), err);
+		return err;
+	}
+	
+	struct fuse_open_out *outargs = (struct fuse_open_out *)giantbuf;
+	
+	struct fuse_file_info fi2;
+	memset(&fi2, 0, sizeof(fi2));
+	fi2.fh = outargs->fh;
+	fi2.flags = outargs->open_flags;
+	
+	fprintf(stderr, "OPENDIR succeeded!\n");
+	
+	struct fuse_read_in readargs;
+	readargs.fh = fi2.fh;
+	readargs.flags = fi2.flags;
+	readargs.lock_owner = fi2.lock_owner;
+	readargs.size = fusebuflen;
+	readargs.offset = 0; // TODO: care about this
+	
+	req->response_hijack = &outh;
+	req->response_hijack_buf = giantbuf;
+	req->response_hijack_buflen = fusebuflen;
+
+	fuse_ll_ops[FUSE_READDIR].func(req, inode, &readargs);
+
+	req->response_hijack = NULL;
+	req->response_hijack_buf = NULL;
+
+	if (outh.error) {
+		err = -outh.error;
+		free(giantbuf);
+		fprintf(stderr, "READDIR failed (%s, %d)\n", strerror(err), err);
+		// TODO releasedir
+		return err;
+	}
+	
+	char *p = giantbuf;
+	size_t nbytes = outh.len - sizeof(struct fuse_out_header);
+
+	char *outbuf = malloc(len);
+	char *o = outbuf;
+	size_t nbytesout = len;
+
+	// Hack (stolen from kernel/fuse_i.h):
+#define FUSE_NAME_MAX 1024
+
+	// Ripped more or less directly from the Linux kernel fuse fs function parse_dirfile in dir.c:
+	// Well, modified quite a bit now --cemeyer
+	WCHAR *fnbuf = malloc((FUSE_NAME_MAX+1) * sizeof(WCHAR));
+	FILE_DIRECTORY_INFORMATION *lastfdi = NULL;
+	while (nbytes >= FUSE_NAME_OFFSET && nbytesout >= sizeof(FILE_DIRECTORY_INFORMATION)) {
+		struct fuse_dirent *dirent = (struct fuse_dirent *)p;
+		size_t reclen = fuse_dirent_size(dirent->namelen);
+
+		// The fuse module gave us bad input; well, fuck...
+		if (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX) {
+			err = EIO;
+			free(fnbuf);
+			free(outbuf);
+			free(giantbuf);
+			return err;
+		}
+		if (reclen > nbytes) break;
+
+		FILE_DIRECTORY_INFORMATION *fdient = (FILE_DIRECTORY_INFORMATION *)o;
+		size_t utf16lenbytes = fusent_transcode(dirent->name, dirent->namelen, fnbuf, FUSE_NAME_MAX*sizeof(WCHAR), "UTF-8", "UTF-16LE");
+		fnbuf[utf16lenbytes / (sizeof(WCHAR))] = (WCHAR)0;
+
+		size_t fdilen = fusent_fdient_size(utf16lenbytes);
+		if (fdilen > nbytesout) break;
+
+		fprintf(stderr, "dirctrl: dirent->name: %.*s\treclen:0x%.8x\tino: %llu\n", (int)dirent->namelen, dirent->name, reclen, dirent->ino);
+
+		struct fuse_attr_out attr;
+		struct fuse_out_header outh2;
+		struct fuse_getattr_in args = { 0, 0, 0 };
+
+		// TODO lookup first if dirent->ino == FUSE_UNKNOWN_INO
+		//req->response_hijack = &outh2;
+		//req->response_hijack_buf = (char *)&attr;
+		//req->response_hijack_buflen = sizeof(struct fuse_attr_out);
+
+		//fuse_ll_ops[FUSE_GETATTR].func(req, dirent->ino, &args);
+
+		//req->response_hijack = NULL;
+		//req->response_hijack_buf = NULL;
+
+		//if (outh2.error) {
+		//	err = -outh2.error;
+		//	free(giantbuf);
+		//	free(fnbuf);
+		//	free(outbuf);
+		//	fprintf(stderr, "GETATTR failed mid-DIR_CONTROL (%s, %d)\n", strerror(err), err);
+		//	return err;
+		//}
+
+		memset(&attr, 0, sizeof(struct fuse_attr_out)); // temporary
+		struct fuse_attr *st = &attr.attr;
+
+		fdient->NextEntryOffset = fdilen;
+		fdient->FileIndex = 0; // we pick an arbitrary value; this is undefined on all but FAT anyways.
+
+		// Most of this is stolen from fusent_reply_query
+		fusent_unixtime_to_wintime(0, &fdient->CreationTime);
+		fusent_unixtime_to_wintime(st->atime, &fdient->LastAccessTime);
+		fusent_unixtime_to_wintime(st->mtime, &fdient->LastWriteTime);
+
+		// Take the most recent of {mtime,ctime} for windows' "changetime"
+		time_t ctime = (st->mtime > st->ctime)? st->mtime : st->ctime;
+		fusent_unixtime_to_wintime(ctime, &fdient->ChangeTime);
+
+		fdient->AllocationSize.QuadPart = ((int64_t)st->blocks) * 512;
+		fdient->EndOfFile.QuadPart = (int64_t)st->size;
+		fusent_unixmode_to_winattr(st->mode, &fdient->FileAttributes);
+		fdient->FileNameLength = utf16lenbytes;
+		memcpy(fdient->FileName, fnbuf, utf16lenbytes);
+
+		lastfdi = fdient;
+
+		p += reclen;
+		o += fdilen;
+		nbytes -= reclen;
+		nbytesout -= fdilen;
+		//fusent_set_file_offset(fop, fusent_get_file_offset(fop) + nbytes);
+	}
+	free(fnbuf);
+	free(giantbuf);
+
+	FUSENT_DIRLISTING *dl = malloc(sizeof(FUSENT_DIRLISTING));
+	dl->off = 0;
+	dl->len = 0;
+	dl->listing = NULL;
+	dl->singlefile = 0;
+	if (lastfdi) {
+		lastfdi->NextEntryOffset = 0;
+		dl->len = ((char *)lastfdi->FileName) + lastfdi->FileNameLength - outbuf;
+		dl->listing = outbuf;
+	}
+	else {
+		free(outbuf);
+	}
+
+	st_insert(fusent_fop_dirlisting_map, (st_data_t)fop, (st_data_t)dl);
+
+	// TODO release dir
+
+	return 0;
+}
+
+// Handle an IRP_MJ_DIRECTORY_CONTROL request
+static void fusent_do_directory_control(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	PFILE_OBJECT fop = ntreq->fop;
+	int err;
+	
+	// For more info on these params, see the MSDN on IRP_MJ_DIRECTORY_CONTROL:
+	// http://msdn.microsoft.com/en-us/library/ff548658(v=vs.85).aspx
+	EXTENDED_IO_STACK_LOCATION *irpsp = (EXTENDED_IO_STACK_LOCATION *)iosp;
+	UCHAR flags = irpsp->Flags;
+	if (irpsp->MinorFunction != IRP_MN_QUERY_DIRECTORY) {
+		err = ENOSYS;
+		goto reply_err_nt;
+	}
+	
+	// Make sure this file has already been opened:
+	struct fuse_file_info *fi = NULL;
+	fuse_ino_t inode = 0;
+	WCHAR* bn = NULL;
+	if (fusent_fi_inode_basename_from_fop(fop, &fi, &inode, &bn) < 0) {
+		err = EBADF;
+		goto reply_err_nt;
+	}
+
+	// Check if the dir listing asks for a restart, or if not, if we don't
+	// already have a buffer sitting somewhere:
+	int restart = 0;
+	if (!st_is_member(fusent_fop_dirlisting_map, (st_data_t)fop)) {
+		restart = 1;
+	}
+	else if (irpsp->Flags & SL_RESTART_SCAN) {
+		restart = 1;
+
+		// Nuke the dirlisting buffer from the map:
+		st_data_t irfop = (st_data_t)fop,
+			  rdl;
+		st_lookup(fusent_fop_dirlisting_map, irfop, &rdl);
+		FUSENT_DIRLISTING *dl = (FUSENT_DIRLISTING *)rdl;
+		if (dl->listing) free(dl->listing);
+		irfop = (st_data_t)fop;
+		st_delete(fusent_fop_dirlisting_map, &irfop, NULL);
+	}
+
+	if (restart) {
+		err = fusent_do_buffer_dirlisting(ntreq, irpsp, req, inode);
+		if (err) goto reply_err_nt;
+	}
+
+	st_data_t rdl;
+	st_lookup(fusent_fop_dirlisting_map, (st_data_t)fop, &rdl);
+	FUSENT_DIRLISTING *dl = (FUSENT_DIRLISTING *)rdl;
+
+	// If we've already traversed the entire directory:
+	if (dl->off >= dl->len) {
+		fprintf(stderr, "DIRECTORY_CONTROL: NO MORE FILES\n");
+		FUSENT_RESP resp;
+		fusent_fill_resp(&resp, ntreq->pirp, fop, 0);
+		resp.status = STATUS_NO_MORE_FILES;
+		fusent_sendmsg(req, &resp, sizeof(FUSENT_RESP));
+		return;
+	}
+
+	// Otherwise, copy as many as will fit into the waiting buf,
+	// and update offset:
+	size_t bytesleft = irpsp->Parameters.QueryDirectory.Length;
+	char *outbuf = malloc(sizeof(FUSENT_RESP) + bytesleft);
+	char *o = outbuf + sizeof(FUSENT_RESP);
+	char *p = dl->listing + dl->off;
+
+	int recordscopied = 0;
+	FILE_DIRECTORY_INFORMATION *lastfdi = NULL;
+	while (bytesleft >= sizeof(FILE_DIRECTORY_INFORMATION) && p < dl->listing + dl->len) {
+		FILE_DIRECTORY_INFORMATION *fdient = (FILE_DIRECTORY_INFORMATION *)p;
+		size_t fdilen = fusent_fdient_size(fdient->FileNameLength);
+
+		if (bytesleft < fdilen) break;
+
+		memcpy(o, p, fdilen);
+		lastfdi = (FILE_DIRECTORY_INFORMATION *)o;
+		o += fdilen;
+		p += fdilen;
+		bytesleft -= fdilen;
+		recordscopied ++;
+
+		fprintf(stderr, "  DIRCTRL: record->fnlen: %u\n", (unsigned)fdient->FileNameLength);
+
+		if (!fdient->NextEntryOffset) break;
+		if (irpsp->Flags & SL_RETURN_SINGLE_ENTRY) {
+			dl->singlefile = 1;
+			break;
+		}
+		if (dl->singlefile) break;
+	}
+
+	fprintf(stderr, "Records copied: %d\n", recordscopied);
+
+	// Buffer was too small to fit any entries:
+	// We are supposed to shove part of it in? I'm not sure
+	// how this should work; whatever:
+	if (!lastfdi) {
+		fprintf(stderr, "DIRECTORY_CONTROL: BUF TOO SMALL\n");
+		FUSENT_RESP resp;
+		fusent_fill_resp(&resp, ntreq->pirp, fop, 0);
+		resp.status = STATUS_BUFFER_OVERFLOW;
+		fusent_sendmsg(req, &resp, sizeof(FUSENT_RESP));
+		free(outbuf);
+		return;
+	}
+
+	// Last entry points to zero
+	lastfdi->NextEntryOffset = 0;
+	
+	// Update directory "progress"
+	fprintf(stderr, "DIRCTL: Advance dir offset from %llu to %llu\n", dl->off, (uint64_t)(p - dl->listing));
+	dl->off = p - dl->listing;
+
+	// Reply with a big fat buf!
+	fprintf(stderr, "DIRCTL: Replying with a N-byte buf: %08x (header: %08x)\n", o - outbuf, sizeof(FUSENT_RESP));
+	fusent_reply_dirctrl(req, ntreq->pirp, fop, o - outbuf, outbuf);
+	free(outbuf);
+	return;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_CLEANUP request
+static void fusent_do_cleanup(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	// TODO flush
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, 0);
+}
+
+// Handle an IRP_MJ_CLOSE request
+static void fusent_do_close(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: flush, release
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+/*
+// Handle an IRP_MJ_DEVICE_CONTROL request
+static void fusent_do_device_control(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_FILE_SYSTEM_CONTROL request
+static void fusent_do_file_system_control(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+*/
+
+// Handle an IRP_MJ_FLUSH_BUFFERS request
+static void fusent_do_flush_buffers(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+/*
+// Handle an IRP_MJ_INTERNAL_DEVICE_CONTROL request
+static void fusent_do_internal_device_control(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_PNP request
+static void fusent_do_pnp(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_POWER request
+static void fusent_do_power(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+*/
+
+// Handle an IRP_MJ_QUERY_INFORMATION request
+static void fusent_do_query_information(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	PFILE_OBJECT fop = ntreq->fop;
+	int err;
+
+	struct fuse_file_info *fi = NULL;
+	fuse_ino_t inode = 0;
+	WCHAR *basename = NULL;
+	if (fusent_fi_inode_basename_from_fop(fop, &fi, &inode, &basename) < 0) {
+		err = EBADF;
+		goto reply_err_nt;
+	}
+
+	struct fuse_out_header outh;
+	struct fuse_attr_out attr;
+	struct fuse_getattr_in args = { 0, 0, 0 };
+
+	req->response_hijack = &outh;
+	req->response_hijack_buf = (char *)&attr;
+	req->response_hijack_buflen = sizeof(struct fuse_attr_out);
+
+	fuse_ll_ops[FUSE_GETATTR].func(req, inode, &args);
+
+	req->response_hijack = NULL;
+	req->response_hijack_buf = NULL;
+
+	if (outh.error) {
+		err = -outh.error;
+		fprintf(stderr, "QUERY_INFO failed (%s, %d)\n", strerror(err), err);
+		goto reply_err_nt;
+	}
+
+	fusent_reply_query_information(req, ntreq->pirp, ntreq->fop, &attr.attr, basename);
+	return;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+/*
+// Handle an IRP_MJ_SET_INFORMATION request
+static void fusent_do_set_information(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_SHUTDOWN request
+static void fusent_do_shutdown(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+// Handle an IRP_MJ_SYSTEM_CONTROL request
+static void fusent_do_system_control(FUSENT_REQ *ntreq, IO_STACK_LOCATION *iosp, fuse_req_t req)
+{
+	UCHAR flags = iosp->Flags;
+	int err;
+
+	// TODO: fill in this function stub
+
+	err = ENOSYS;
+	goto reply_err_nt;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+*/
+
+// Initialize FUSE (HACK)
+static void fusent_do_init(struct fuse_ll *f)
+{
+	// TODO(cemeyer) call do_init or whatever fuse calls. low priority.
+
+	f->got_init = 1;
+
+	// stolen from the 2.6.38 kernel
+	f->conn.proto_major = 7;
+	f->conn.proto_minor = 16;
+
+	f->conn.capable = 0;
+	f->conn.want = 0;
+	f->conn.async_read = 0;
+	if (f->op.init) f->op.init(f->userdata, &f->conn);
+
+	// This might be good enough:
+	f->conn.max_write = 8192;
+}
+
+// Handle incoming FUSE-NT protocol messages:
+static void fusent_ll_process(void *data, const char *buf, size_t len,
+		struct fuse_chan *ch)
+{
+	struct fuse_ll *f = (struct fuse_ll *) data;
+	struct fuse_req *req;
+	int err;
+
+	FUSENT_REQ *ntreq = (FUSENT_REQ *)buf;
+
+	req = (struct fuse_req *) calloc(1, sizeof(struct fuse_req));
+	if (req == NULL) {
+		fprintf(stderr, "fuse: failed to allocate request\n");
+		return;
+	}
+
+	if (!f->got_init) {
+		fusent_do_init(f);
+	}
+
+	req->f = f;
+	req->unique = 0; // this might not be needed except for interrupts --cemeyer
+	req->ctx.uid = 0; // not sure these have any correct meanings
+	req->ctx.gid = 0;
+	req->ctx.pid = 0; // what is this used for? maybe need to pass as part of the request --cemeyer
+	req->ch = ch;
+	req->ctr = 1;
+	req->response_hijack = NULL;
+	list_init_req(req);
+	fuse_mutex_init(&req->lock);
+
+	int status;
+	IO_STACK_LOCATION *iosp;
+	uint8_t irptype;
+
+	err = EIO;
+
+	status = fusent_decode_irp(&ntreq->irp, &ntreq->iostack[0], &irptype, &iosp);
+	if (status < 0) goto reply_err_nt;
+
+	switch (irptype) {
+		case IRP_MJ_CREATE:
+			fprintf(stderr, "fusent: got CREATE on %p\n", ntreq->fop);
+			fusent_do_create(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_READ:
+			fprintf(stderr, "fusent: got READ on %p\n", ntreq->fop);
+			fusent_do_read(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_WRITE:
+			fusent_do_write(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_DIRECTORY_CONTROL:
+			fprintf(stderr, "fusent: got DIRECTORY_CONTROL on %p\n", ntreq->fop);
+			fusent_do_directory_control(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_CLEANUP:
+			fprintf(stderr, "fusent: got CLEANUP on %p\n", ntreq->fop);
+			fusent_do_cleanup(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_CLOSE:
+			fprintf(stderr, "fusent: got CLOSE on %p\n", ntreq->fop);
+			fusent_do_close(ntreq, iosp, req);
+			break;
+
+		/*
+		case IRP_MJ_DEVICE_CONTROL:
+			fusent_do_device_control(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_FILE_SYSTEM_CONTROL:
+			fusent_do_file_system_control(ntreq, iosp, req);
+			break;
+		*/
+
+		case IRP_MJ_FLUSH_BUFFERS:
+			fusent_do_flush_buffers(ntreq, iosp, req);
+			break;
+
+		/*
+		case IRP_MJ_INTERNAL_DEVICE_CONTROL:
+			fusent_do_internal_device_control(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_PNP:
+			fusent_do_pnp(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_POWER:
+			fusent_do_power(ntreq, iosp, req);
+			break;
+		*/
+
+		case IRP_MJ_QUERY_INFORMATION:
+			fprintf(stderr, "fusent: got QUERY_INFORMATION on %p\n", ntreq->fop);
+			fusent_do_query_information(ntreq, iosp, req);
+			break;
+
+		/*
+		case IRP_MJ_SET_INFORMATION:
+			fusent_do_set_information(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_SHUTDOWN:
+			fusent_do_shutdown(ntreq, iosp, req);
+			break;
+
+		case IRP_MJ_SYSTEM_CONTROL:
+			fusent_do_system_control(ntreq, iosp, req);
+			break;
+		*/
+
+		default:
+			err = ENOSYS;
+			goto reply_err_nt;
+	}
+	return;
+
+reply_err_nt:
+	fusent_reply_error(req, ntreq->pirp, ntreq->fop, err);
+}
+
+#else /* __CYGWIN__ */
 
 static void fuse_ll_process(void *data, const char *buf, size_t len,
 			    struct fuse_chan *ch)
 {
 	struct fuse_ll *f = (struct fuse_ll *) data;
-	struct fuse_in_header *in = (struct fuse_in_header *) buf;
-	const void *inarg = buf + sizeof(struct fuse_in_header);
 	struct fuse_req *req;
 	int err;
 
+	struct fuse_in_header *in = (struct fuse_in_header *) buf;
+	const void *inarg = buf + sizeof(struct fuse_in_header);
+
 	if (f->debug)
 		fprintf(stderr,
 			"unique: %llu, opcode: %s (%i), nodeid: %lu, insize: %zu\n",
 			(unsigned long long) in->unique,
 			opname((enum fuse_opcode) in->opcode), in->opcode,
 			(unsigned long) in->nodeid, len);
 
 	req = (struct fuse_req *) calloc(1, sizeof(struct fuse_req));
 	if (req == NULL) {
 		fprintf(stderr, "fuse: failed to allocate request\n");
 		return;
 	}
 
 	req->f = f;
 	req->unique = in->unique;
 	req->ctx.uid = in->uid;
 	req->ctx.gid = in->gid;
 	req->ctx.pid = in->pid;
 	req->ch = ch;
 	req->ctr = 1;
@@ -1500,40 +2949,41 @@ static void fuse_ll_process(void *data,
 		goto reply_err;
 
 	err = ENOSYS;
 	if (in->opcode >= FUSE_MAXOP || !fuse_ll_ops[in->opcode].func)
 		goto reply_err;
 	if (in->opcode != FUSE_INTERRUPT) {
 		struct fuse_req *intr;
 		pthread_mutex_lock(&f->lock);
 		intr = check_interrupt(f, req);
 		list_add_req(req, &f->list);
 		pthread_mutex_unlock(&f->lock);
 		if (intr)
 			fuse_reply_err(intr, EAGAIN);
 	}
 	fuse_ll_ops[in->opcode].func(req, in->nodeid, inarg);
 	return;
 
  reply_err:
 	fuse_reply_err(req, err);
 }
+#endif /* !__CYGWIN__ */
 
 enum {
 	KEY_HELP,
 	KEY_VERSION,
 };
 
 static struct fuse_opt fuse_ll_opts[] = {
 	{ "debug", offsetof(struct fuse_ll, debug), 1 },
 	{ "-d", offsetof(struct fuse_ll, debug), 1 },
 	{ "allow_root", offsetof(struct fuse_ll, allow_root), 1 },
 	{ "max_write=%u", offsetof(struct fuse_ll, conn.max_write), 0 },
 	{ "max_readahead=%u", offsetof(struct fuse_ll, conn.max_readahead), 0 },
 	{ "async_read", offsetof(struct fuse_ll, conn.async_read), 1 },
 	{ "sync_read", offsetof(struct fuse_ll, conn.async_read), 0 },
 	{ "atomic_o_trunc", offsetof(struct fuse_ll, atomic_o_trunc), 1},
 	{ "no_remote_lock", offsetof(struct fuse_ll, no_remote_lock), 1},
 	{ "big_writes", offsetof(struct fuse_ll, big_writes), 1},
 	FUSE_OPT_KEY("max_read=", FUSE_OPT_KEY_DISCARD),
 	FUSE_OPT_KEY("-h", KEY_HELP),
 	FUSE_OPT_KEY("--help", KEY_HELP),
@@ -1595,41 +3045,45 @@ static void fuse_ll_destroy(void *data)
 			f->op.destroy(f->userdata);
 	}
 
 	pthread_mutex_destroy(&f->lock);
 	free(f->cuse_data);
 	free(f);
 }
 
 /*
  * always call fuse_lowlevel_new_common() internally, to work around a
  * misfeature in the FreeBSD runtime linker, which links the old
  * version of a symbol to internal references.
  */
 struct fuse_session *fuse_lowlevel_new_common(struct fuse_args *args,
 					      const struct fuse_lowlevel_ops *op,
 					      size_t op_size, void *userdata)
 {
 	struct fuse_ll *f;
 	struct fuse_session *se;
 	struct fuse_session_ops sop = {
+#if defined __CYGWIN__
+		.process = fusent_ll_process,
+#else
 		.process = fuse_ll_process,
+#endif
 		.destroy = fuse_ll_destroy,
 	};
 
 	if (sizeof(struct fuse_lowlevel_ops) < op_size) {
 		fprintf(stderr, "fuse: warning: library too old, some operations may not work\n");
 		op_size = sizeof(struct fuse_lowlevel_ops);
 	}
 
 	f = (struct fuse_ll *) calloc(1, sizeof(struct fuse_ll));
 	if (f == NULL) {
 		fprintf(stderr, "fuse: failed to allocate fuse object\n");
 		goto out;
 	}
 
 	f->conn.async_read = 1;
 	f->conn.max_write = UINT_MAX;
 	f->conn.max_readahead = UINT_MAX;
 	f->atomic_o_trunc = 0;
 	list_init_req(&f->list);
 	list_init_req(&f->interrupts);
@@ -1648,41 +3102,41 @@ struct fuse_session *fuse_lowlevel_new_c
 	se = fuse_session_new(&sop, f);
 	if (!se)
 		goto out_free;
 
 	return se;
 
 out_free:
 	free(f);
 out:
 	return NULL;
 }
 
 
 struct fuse_session *fuse_lowlevel_new(struct fuse_args *args,
 				       const struct fuse_lowlevel_ops *op,
 				       size_t op_size, void *userdata)
 {
 	return fuse_lowlevel_new_common(args, op, op_size, userdata);
 }
 
-#ifdef linux
+#if defined(linux) && !defined(__CYGWIN__)
 int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[])
 {
 	char *buf;
 	size_t bufsize = 1024;
 	char path[128];
 	int ret;
 	int fd;
 	unsigned long pid = req->ctx.pid;
 	char *s;
 
 	sprintf(path, "/proc/%lu/task/%lu/status", pid, pid);
 
 retry:
 	buf = malloc(bufsize);
 	if (buf == NULL)
 		return -ENOMEM;
 
 	ret = -EIO;
 	fd = open(path, O_RDONLY);
 	if (fd == -1)
@@ -1717,41 +3171,41 @@ retry:
 		s = end;
 		if (ret < size)
 			list[ret] = val;
 		ret++;
 	}
 
 out_free:
 	free(buf);
 	return ret;
 }
 #else /* linux */
 /*
  * This is currently not implemented on other than Linux...
  */
 int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[])
 {
 	return -ENOSYS;
 }
 #endif
 
-#ifndef __FreeBSD__
+#if !defined __FreeBSD__ && !defined __CYGWIN__
 
 static void fill_open_compat(struct fuse_open_out *arg,
 			     const struct fuse_file_info_compat *f)
 {
 	arg->fh = f->fh;
 	if (f->direct_io)
 		arg->open_flags |= FOPEN_DIRECT_IO;
 	if (f->keep_cache)
 		arg->open_flags |= FOPEN_KEEP_CACHE;
 }
 
 static void convert_statfs_compat(const struct statfs *compatbuf,
 				  struct statvfs *buf)
 {
 	buf->f_bsize	= compatbuf->f_bsize;
 	buf->f_blocks	= compatbuf->f_blocks;
 	buf->f_bfree	= compatbuf->f_bfree;
 	buf->f_bavail	= compatbuf->f_bavail;
 	buf->f_files	= compatbuf->f_files;
 	buf->f_ffree	= compatbuf->f_ffree;
@@ -1819,43 +3273,47 @@ int fuse_sync_compat_args(struct fuse_ar
 	if (fuse_opt_parse(args, &conf, fuse_ll_opts_compat, NULL) == -1)
 		return -1;
 
 	if (fuse_opt_insert_arg(args, 1, "-osync_read"))
 		return -1;
 
 	if (conf.set_max_read) {
 		char tmpbuf[64];
 
 		sprintf(tmpbuf, "-omax_readahead=%u", conf.max_read);
 		if (fuse_opt_insert_arg(args, 1, tmpbuf) == -1)
 			return -1;
 	}
 	return 0;
 }
 
 FUSE_SYMVER(".symver fuse_reply_statfs_compat,fuse_reply_statfs@FUSE_2.4");
 FUSE_SYMVER(".symver fuse_reply_open_compat,fuse_reply_open@FUSE_2.4");
 FUSE_SYMVER(".symver fuse_lowlevel_new_compat,fuse_lowlevel_new@FUSE_2.4");
 
-#else /* __FreeBSD__ */
+#else /* __FreeBSD__ || __CYGWIN__ */
 
 int fuse_sync_compat_args(struct fuse_args *args)
 {
 	(void) args;
 	return 0;
 }
 
-#endif /* __FreeBSD__ */
+#endif /* __FreeBSD__ || __CYGWIN__ */
+
+#ifndef __CYGWIN__
 
 struct fuse_session *fuse_lowlevel_new_compat25(struct fuse_args *args,
 				const struct fuse_lowlevel_ops_compat25 *op,
 				size_t op_size, void *userdata)
 {
 	if (fuse_sync_compat_args(args) == -1)
 		return NULL;
 
 	return fuse_lowlevel_new_common(args,
 					(const struct fuse_lowlevel_ops *) op,
 					op_size, userdata);
 }
 
 FUSE_SYMVER(".symver fuse_lowlevel_new_compat25,fuse_lowlevel_new@FUSE_2.5");
+
+#endif /* __CYGWIN__ */
Index: fuse-2.8.5/lib/fuse_misc.h
===================================================================
--- fuse-2.8.5.orig/lib/fuse_misc.h
+++ fuse-2.8.5/lib/fuse_misc.h
@@ -1,36 +1,36 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB
 */
 
 #include "config.h"
 #include <pthread.h>
 
-/* Versioned symbols confuse the dynamic linker in uClibc */
-#ifndef __UCLIBC__
-#define FUSE_SYMVER(x) __asm__(x)
-#else
+/* Versioned symbols confuse the dynamic linker in uClibc and cygwin */
+#if defined(__UCLIBC__) || defined(__CYGWIN__)
 #define FUSE_SYMVER(x)
+#else
+#define FUSE_SYMVER(x) __asm__(x)
 #endif
 
 #ifndef USE_UCLIBC
 #define fuse_mutex_init(mut) pthread_mutex_init(mut, NULL)
 #else
 /* Is this hack still needed? */
 static inline void fuse_mutex_init(pthread_mutex_t *mut)
 {
 	pthread_mutexattr_t attr;
 	pthread_mutexattr_init(&attr);
 	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
 	pthread_mutex_init(mut, &attr);
 	pthread_mutexattr_destroy(&attr);
 }
 #endif
 
 #ifdef HAVE_STRUCT_STAT_ST_ATIM
 /* Linux */
 #define ST_ATIM_NSEC(stbuf) ((stbuf)->st_atim.tv_nsec)
 #define ST_CTIM_NSEC(stbuf) ((stbuf)->st_ctim.tv_nsec)
Index: fuse-2.8.5/lib/fusent_proto.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/lib/fusent_proto.c
@@ -0,0 +1,30 @@
+/*
+  FUSE-NT: Filesystem in Userspace (for Windows NT)
+  Copyright (C) 2011  The FUSE-NT Authors
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file LGPLv2.txt.
+*/
+
+#ifdef __CYGWIN__
+#include "fusent_proto.h"
+
+// Takes a FUSE_CREATE_REQ and finds the variably-located fields:
+void fusent_decode_request_create(FUSENT_CREATE_REQ *req, uint32_t *outfnamelen,
+		uint16_t **outfnamep)
+{
+	uint32_t *fnamelenp = (uint32_t *)(req->iostack + req->irp.StackCount);
+	*outfnamelen = *fnamelenp;
+	*outfnamep = (uint16_t *)(fnamelenp + 1);
+}
+
+// Takes a FUSE_WRITE_REQ and finds the variably-located fields:
+void fusent_decode_request_write(FUSENT_WRITE_REQ *req, uint32_t *outbuflen,
+		uint8_t **outbufp)
+{
+	uint32_t *buflenp = (uint32_t *)(req->iostack + req->irp.StackCount);
+	*outbuflen = *buflenp;
+	*outbufp = (uint8_t *)(buflenp + 1);
+}
+
+#endif /* __CYGWIN__ */
Index: fuse-2.8.5/lib/fusent_routines.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/lib/fusent_routines.c
@@ -0,0 +1,63 @@
+/*
+  FUSE-NT: Filesystem in Userspace (for Windows NT)
+  Copyright (C) 2011  The FUSE-NT Authors
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file LGPLv2.txt.
+*/
+
+#ifdef __CYGWIN__
+#include "fusent_routines.h"
+
+// Decodes an IRP (and associated IO stack) to locate the current stack entry
+// and the IRP major number.
+//
+// Returns non-negative on success.
+int fusent_decode_irp(IRP *irp, IO_STACK_LOCATION *iosp, uint8_t *outirptype,
+		IO_STACK_LOCATION **outiosp)
+{
+	// CurrentLocation is 1-indexed:
+	*outiosp = &iosp[irp->CurrentLocation - 1];
+	*outirptype = (*outiosp)->MajorFunction;
+
+	return 0;
+}
+
+// Translates a string from one encoding to another.
+// src, s_len - source string, and its length in bytes
+// dst, d_len - destination buffer, and its length in bytes
+// in_enc, out_enc - input/output charsets, e.g. "UTF-8"
+//
+// Returns negative on error, or the number of bytes output on success.
+size_t fusent_transcode(void *src, size_t s_len, void *dst, size_t d_len, const char *in_enc, const char *out_enc)
+{
+	size_t res = -1;
+	iconv_t cd;
+	if ((cd = iconv_open(out_enc, in_enc)) == (iconv_t)-1) goto leave;
+
+	char *in = src, *out = dst;
+	size_t inb = s_len, outb = d_len;
+
+	if (iconv(cd, &in, &inb, &out, &outb) == -1) goto close_cd;
+
+	res = d_len - outb;
+
+close_cd:
+	iconv_close(cd);
+leave:
+	return res;
+}
+
+// Translates (roughly) a Unix time_t (seconds since unix epoch) to a Windows' LARGE_INTEGER time (100-ns intervals since Jan 1, 1601).
+void fusent_unixtime_to_wintime(time_t t, LARGE_INTEGER *wintime)
+{
+	const int64_t ns100_per_s = 10000000;
+	int64_t tmp = ns100_per_s * t; // t is now 100-ns intervals since Jan 1 1970
+
+	// Very roughly translate the time back from the unix epoch to 1601 (estimates leap years, roughly):
+	tmp += (1970 - 1601) * 365.242199 * 24 * 60 * 60 * ns100_per_s;
+
+	wintime->QuadPart = tmp;
+}
+
+#endif /* __CYGWIN__ */
Index: fuse-2.8.5/lib/fuse_session.c
===================================================================
--- fuse-2.8.5.orig/lib/fuse_session.c
+++ fuse-2.8.5/lib/fuse_session.c
@@ -5,41 +5,45 @@
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB
 */
 
 #include "fuse_i.h"
 #include "fuse_misc.h"
 #include "fuse_common_compat.h"
 #include "fuse_lowlevel_compat.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 #include <errno.h>
 
 struct fuse_chan {
 	struct fuse_chan_ops op;
 
 	struct fuse_session *se;
 
+#if defined __CYGWIN__
+	HANDLE fd;
+#else
 	int fd;
+#endif
 
 	size_t bufsize;
 
 	void *data;
 
 	int compat;
 };
 
 struct fuse_session *fuse_session_new(struct fuse_session_ops *op, void *data)
 {
 	struct fuse_session *se = (struct fuse_session *) malloc(sizeof(*se));
 	if (se == NULL) {
 		fprintf(stderr, "fuse: failed to allocate session\n");
 		return NULL;
 	}
 
 	memset(se, 0, sizeof(*se));
 	se->op = *op;
 	se->data = data;
 
@@ -99,100 +103,118 @@ void fuse_session_exit(struct fuse_sessi
 void fuse_session_reset(struct fuse_session *se)
 {
 	if (se->op.exit)
 		se->op.exit(se->data, 0);
 	se->exited = 0;
 }
 
 int fuse_session_exited(struct fuse_session *se)
 {
 	if (se->op.exited)
 		return se->op.exited(se->data);
 	else
 		return se->exited;
 }
 
 void *fuse_session_data(struct fuse_session *se)
 {
 	return se->data;
 }
 
-static struct fuse_chan *fuse_chan_new_common(struct fuse_chan_ops *op, int fd,
+static struct fuse_chan *fuse_chan_new_common(struct fuse_chan_ops *op,
+#if defined __CYGWIN__
+					      HANDLE fd,
+#else
+					      int fd,
+#endif
 					      size_t bufsize, void *data,
 					      int compat)
 {
 	struct fuse_chan *ch = (struct fuse_chan *) malloc(sizeof(*ch));
 	if (ch == NULL) {
 		fprintf(stderr, "fuse: failed to allocate channel\n");
 		return NULL;
 	}
 
 	memset(ch, 0, sizeof(*ch));
 	ch->op = *op;
 	ch->fd = fd;
 	ch->bufsize = bufsize;
 	ch->data = data;
 	ch->compat = compat;
 
 	return ch;
 }
 
+#if defined __CYGWIN__
+struct fuse_chan *fuse_chan_new(struct fuse_chan_ops *op, HANDLE fd,
+				size_t bufsize, void *data)
+#else
 struct fuse_chan *fuse_chan_new(struct fuse_chan_ops *op, int fd,
 				size_t bufsize, void *data)
+#endif
 {
 	return fuse_chan_new_common(op, fd, bufsize, data, 0);
 }
 
+#if !defined __CYGWIN__
 struct fuse_chan *fuse_chan_new_compat24(struct fuse_chan_ops_compat24 *op,
 					 int fd, size_t bufsize, void *data)
 {
 	return fuse_chan_new_common((struct fuse_chan_ops *) op, fd, bufsize,
 				    data, 24);
 }
+#endif
 
+#if defined __CYGWIN__
+HANDLE fuse_chan_fd(struct fuse_chan *ch)
+#else
 int fuse_chan_fd(struct fuse_chan *ch)
+#endif
 {
 	return ch->fd;
 }
 
 size_t fuse_chan_bufsize(struct fuse_chan *ch)
 {
 	return ch->bufsize;
 }
 
 void *fuse_chan_data(struct fuse_chan *ch)
 {
 	return ch->data;
 }
 
 struct fuse_session *fuse_chan_session(struct fuse_chan *ch)
 {
 	return ch->se;
 }
 
 int fuse_chan_recv(struct fuse_chan **chp, char *buf, size_t size)
 {
 	struct fuse_chan *ch = *chp;
+#ifndef __CYGWIN__
 	if (ch->compat)
 		return ((struct fuse_chan_ops_compat24 *) &ch->op)
 			->receive(ch, buf, size);
 	else
+#endif
 		return ch->op.receive(chp, buf, size);
 }
 
 int fuse_chan_receive(struct fuse_chan *ch, char *buf, size_t size)
 {
 	int res;
 
 	res = fuse_chan_recv(&ch, buf, size);
 	return res >= 0 ? res : (res != -EINTR && res != -EAGAIN) ? -1 : 0;
 }
 
 int fuse_chan_send(struct fuse_chan *ch, const struct iovec iov[], size_t count)
 {
 	return ch->op.send(ch, iov, count);
 }
 
 void fuse_chan_destroy(struct fuse_chan *ch)
 {
 	fuse_session_remove_chan(ch);
 	if (ch->op.destroy)
Index: fuse-2.8.5/lib/helper.c
===================================================================
--- fuse-2.8.5.orig/lib/helper.c
+++ fuse-2.8.5/lib/helper.c
@@ -1,57 +1,62 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB.
 */
 
 #include "config.h"
 #include "fuse_i.h"
 #include "fuse_misc.h"
 #include "fuse_opt.h"
 #include "fuse_lowlevel.h"
 #include "fuse_common_compat.h"
+#include "fusent_translate.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <unistd.h>
 #include <string.h>
 #include <limits.h>
 #include <errno.h>
 #include <sys/param.h>
 
 enum  {
 	KEY_HELP,
 	KEY_HELP_NOHEADER,
 	KEY_VERSION,
 };
 
 struct helper_opts {
 	int singlethread;
 	int foreground;
 	int nodefault_subtype;
 	char *mountpoint;
 };
 
+#ifdef __CYGWIN__
+extern const char *fusent_argv0;
+#endif
+
 #define FUSE_HELPER_OPT(t, p) { t, offsetof(struct helper_opts, p), 1 }
 
 static const struct fuse_opt fuse_helper_opts[] = {
 	FUSE_HELPER_OPT("-d",		foreground),
 	FUSE_HELPER_OPT("debug",	foreground),
 	FUSE_HELPER_OPT("-f",		foreground),
 	FUSE_HELPER_OPT("-s",		singlethread),
 	FUSE_HELPER_OPT("fsname=",	nodefault_subtype),
 	FUSE_HELPER_OPT("subtype=",	nodefault_subtype),
 
 	FUSE_OPT_KEY("-h",		KEY_HELP),
 	FUSE_OPT_KEY("--help",		KEY_HELP),
 	FUSE_OPT_KEY("-ho",		KEY_HELP_NOHEADER),
 	FUSE_OPT_KEY("-V",		KEY_VERSION),
 	FUSE_OPT_KEY("--version",	KEY_VERSION),
 	FUSE_OPT_KEY("-d",		FUSE_OPT_KEY_KEEP),
 	FUSE_OPT_KEY("debug",		FUSE_OPT_KEY_KEEP),
 	FUSE_OPT_KEY("fsname=",		FUSE_OPT_KEY_KEEP),
 	FUSE_OPT_KEY("subtype=",	FUSE_OPT_KEY_KEEP),
 	FUSE_OPT_END
@@ -89,46 +94,53 @@ static int fuse_helper_opt_proc(void *da
 				struct fuse_args *outargs)
 {
 	struct helper_opts *hopts = data;
 
 	switch (key) {
 	case KEY_HELP:
 		usage(outargs->argv[0]);
 		/* fall through */
 
 	case KEY_HELP_NOHEADER:
 		helper_help();
 		return fuse_opt_add_arg(outargs, "-h");
 
 	case KEY_VERSION:
 		helper_version();
 		return 1;
 
 	case FUSE_OPT_KEY_NONOPT:
 		if (!hopts->mountpoint) {
 			char mountpoint[PATH_MAX];
+#if defined __CYGWIN__
+			// We don't normalize mountpoints for Windows; for now we expect only
+			// drive letter mounts (e.g., "F:") -- realpath() falls over on these.
+			strncpy(mountpoint, arg, PATH_MAX-1);
+			mountpoint[PATH_MAX-1] = '\0';
+#else
 			if (realpath(arg, mountpoint) == NULL) {
 				fprintf(stderr,
 					"fuse: bad mount point `%s': %s\n",
 					arg, strerror(errno));
 				return -1;
 			}
+#endif
 			return fuse_opt_add_opt(&hopts->mountpoint, mountpoint);
 		} else {
 			fprintf(stderr, "fuse: invalid argument `%s'\n", arg);
 			return -1;
 		}
 
 	default:
 		return 1;
 	}
 }
 
 static int add_default_subtype(const char *progname, struct fuse_args *args)
 {
 	int res;
 	char *subtype_opt;
 	const char *basename = strrchr(progname, '/');
 	if (basename == NULL)
 		basename = progname;
 	else if (basename[1] != '\0')
 		basename++;
@@ -178,113 +190,139 @@ err:
 }
 
 int fuse_daemonize(int foreground)
 {
 	int res;
 
 	if (!foreground) {
 		res = daemon(0, 0);
 		if (res == -1) {
 			perror("fuse: failed to daemonize program\n");
 			return -1;
 		}
 	}
 	return 0;
 }
 
 static struct fuse_chan *fuse_mount_common(const char *mountpoint,
 					   struct fuse_args *args)
 {
 	struct fuse_chan *ch;
+
+#if defined __CYGWIN__
+	HANDLE fd;
+
+	int err = fusent_kern_mount(mountpoint, args, &fd);
+	if (err < 0)
+		return NULL;
+#else
 	int fd;
 
 	/*
 	 * Make sure file descriptors 0, 1 and 2 are open, otherwise chaos
 	 * would ensue.
 	 */
 	do {
 		fd = open("/dev/null", O_RDWR);
 		if (fd > 2)
 			close(fd);
 	} while (fd >= 0 && fd <= 2);
 
 	fd = fuse_mount_compat25(mountpoint, args);
 	if (fd == -1)
 		return NULL;
+#endif
 
 	ch = fuse_kern_chan_new(fd);
+
 	if (!ch)
 		fuse_kern_unmount(mountpoint, fd);
 
 	return ch;
 }
 
 struct fuse_chan *fuse_mount(const char *mountpoint, struct fuse_args *args)
 {
 	return fuse_mount_common(mountpoint, args);
 }
 
 static void fuse_unmount_common(const char *mountpoint, struct fuse_chan *ch)
 {
+#if !defined __CYGWIN__
 	int fd = ch ? fuse_chan_fd(ch) : -1;
+#else
+	if (!ch) {
+		fprintf(stderr, "err: fuse_unmount_common called with NULL ch\n");
+		return;
+	}
+	HANDLE fd = fuse_chan_fd(ch);
+#endif
+
 	fuse_kern_unmount(mountpoint, fd);
 	fuse_chan_destroy(ch);
 }
 
 void fuse_unmount(const char *mountpoint, struct fuse_chan *ch)
 {
 	fuse_unmount_common(mountpoint, ch);
 }
 
 struct fuse *fuse_setup_common(int argc, char *argv[],
 			       const struct fuse_operations *op,
 			       size_t op_size,
 			       char **mountpoint,
 			       int *multithreaded,
+#if defined __CYGWIN__
+			       HANDLE *fd,
+#else
 			       int *fd,
+#endif
 			       void *user_data,
 			       int compat)
 {
 	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
 	struct fuse_chan *ch;
 	struct fuse *fuse;
 	int foreground;
 	int res;
 
 	res = fuse_parse_cmdline(&args, mountpoint, multithreaded, &foreground);
 	if (res == -1)
 		return NULL;
 
 	ch = fuse_mount_common(*mountpoint, &args);
 	if (!ch) {
 		fuse_opt_free_args(&args);
 		goto err_free;
 	}
 
 	fuse = fuse_new_common(ch, &args, op, op_size, user_data, compat);
 	fuse_opt_free_args(&args);
 	if (fuse == NULL)
 		goto err_unmount;
 
+	// Skip daemonizing on Cygwin for debugging:
+#ifndef __CYGWIN__
 	res = fuse_daemonize(foreground);
 	if (res == -1)
 		goto err_unmount;
+#endif
 
 	res = fuse_set_signal_handlers(fuse_get_session(fuse));
 	if (res == -1)
 		goto err_unmount;
 
 	if (fd)
 		*fd = fuse_chan_fd(ch);
 
 	return fuse;
 
 err_unmount:
 	fuse_unmount_common(*mountpoint, ch);
 	if (fuse)
 		fuse_destroy(fuse);
 err_free:
 	free(*mountpoint);
 	return NULL;
 }
 
 struct fuse *fuse_setup(int argc, char *argv[],
@@ -302,76 +340,86 @@ static void fuse_teardown_common(struct
 	fuse_remove_signal_handlers(se);
 	fuse_unmount_common(mountpoint, ch);
 	fuse_destroy(fuse);
 	free(mountpoint);
 }
 
 void fuse_teardown(struct fuse *fuse, char *mountpoint)
 {
 	fuse_teardown_common(fuse, mountpoint);
 }
 
 static int fuse_main_common(int argc, char *argv[],
 			    const struct fuse_operations *op, size_t op_size,
 			    void *user_data, int compat)
 {
 	struct fuse *fuse;
 	char *mountpoint;
 	int multithreaded;
 	int res;
 
+#ifdef __CYGWIN__
+	fusent_argv0 = strdup(argv[0]);
+	fusent_translate_setup();
+#endif
 	fuse = fuse_setup_common(argc, argv, op, op_size, &mountpoint,
 				 &multithreaded, NULL, user_data, compat);
 	if (fuse == NULL)
 		return 1;
 
 	if (multithreaded)
 		res = fuse_loop_mt(fuse);
 	else
 		res = fuse_loop(fuse);
 
 	fuse_teardown_common(fuse, mountpoint);
+#ifdef __CYGWIN__
+	fusent_translate_teardown();
+	free(fusent_argv0);
+#endif
 	if (res == -1)
 		return 1;
 
 	return 0;
 }
 
 int fuse_main_real(int argc, char *argv[], const struct fuse_operations *op,
 		   size_t op_size, void *user_data)
 {
 	return fuse_main_common(argc, argv, op, op_size, user_data, 0);
 }
 
 #undef fuse_main
 int fuse_main(void);
 int fuse_main(void)
 {
 	fprintf(stderr, "fuse_main(): This function does not exist\n");
 	return -1;
 }
 
 int fuse_version(void)
 {
 	return FUSE_VERSION;
 }
 
+#ifndef __CYGWIN__
+
 #include "fuse_compat.h"
 
 #ifndef __FreeBSD__
 
 struct fuse *fuse_setup_compat22(int argc, char *argv[],
 				 const struct fuse_operations_compat22 *op,
 				 size_t op_size, char **mountpoint,
 				 int *multithreaded, int *fd)
 {
 	return fuse_setup_common(argc, argv, (struct fuse_operations *) op,
 				 op_size, mountpoint, multithreaded, fd, NULL,
 				 22);
 }
 
 struct fuse *fuse_setup_compat2(int argc, char *argv[],
 				const struct fuse_operations_compat2 *op,
 				char **mountpoint, int *multithreaded,
 				int *fd)
 {
 	return fuse_setup_common(argc, argv, (struct fuse_operations *) op,
@@ -434,20 +482,22 @@ int fuse_main_real_compat25(int argc, ch
 {
 	return fuse_main_common(argc, argv, (struct fuse_operations *) op,
 				op_size, NULL, 25);
 }
 
 void fuse_teardown_compat22(struct fuse *fuse, int fd, char *mountpoint)
 {
 	(void) fd;
 	fuse_teardown_common(fuse, mountpoint);
 }
 
 int fuse_mount_compat25(const char *mountpoint, struct fuse_args *args)
 {
 	return fuse_kern_mount(mountpoint, args);
 }
 
 FUSE_SYMVER(".symver fuse_setup_compat25,fuse_setup@FUSE_2.5");
 FUSE_SYMVER(".symver fuse_teardown_compat22,fuse_teardown@FUSE_2.2");
 FUSE_SYMVER(".symver fuse_main_real_compat25,fuse_main_real@FUSE_2.5");
 FUSE_SYMVER(".symver fuse_mount_compat25,fuse_mount@FUSE_2.5");
+
+#endif /* __CYGWIN__ */
Index: fuse-2.8.5/lib/Makefile.am
===================================================================
--- fuse-2.8.5.orig/lib/Makefile.am
+++ fuse-2.8.5/lib/Makefile.am
@@ -16,29 +16,32 @@ iconv_source = modules/iconv.c
 else
 iconv_source =
 endif
 
 libfuse_la_SOURCES = 		\
 	fuse.c			\
 	fuse_i.h		\
 	fuse_kern_chan.c	\
 	fuse_loop.c		\
 	fuse_loop_mt.c		\
 	fuse_lowlevel.c		\
 	fuse_misc.h		\
 	fuse_mt.c		\
 	fuse_opt.c		\
 	fuse_session.c		\
 	fuse_signals.c		\
 	cuse_lowlevel.c		\
 	helper.c		\
 	modules/subdir.c	\
 	$(iconv_source)		\
-	$(mount_source)
+	$(mount_source)		\
+	st.c			\
+	fusent_routines.c	\
+	fusent_proto.c
 
 libfuse_la_LDFLAGS = @libfuse_libs@ -version-number 2:8:5 \
 	-Wl,--version-script,$(srcdir)/fuse_versionscript
 
 libulockmgr_la_SOURCES = ulockmgr.c
 libulockmgr_la_LDFLAGS = -pthread -version-number 1:0:1
 
 EXTRA_DIST = fuse_versionscript
Index: fuse-2.8.5/lib/mount.c
===================================================================
--- fuse-2.8.5.orig/lib/mount.c
+++ fuse-2.8.5/lib/mount.c
@@ -1,35 +1,42 @@
 /*
   FUSE: Filesystem in Userspace
   Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB.
 */
 
 #include "config.h"
 #include "fuse_i.h"
 #include "fuse_misc.h"
 #include "fuse_opt.h"
 #include "fuse_common_compat.h"
+#include "fuse_fs_defines.h"
 #include "mount_util.h"
 
+#ifdef __CYGWIN__
+# include "fusent_proto.h"
+# include <ctype.h>
+# include <wchar.h>
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <stddef.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <sys/wait.h>
 #include <sys/mount.h>
 
 #define FUSERMOUNT_PROG		"fusermount"
 #define FUSE_COMMFD_ENV		"_FUSE_COMMFD"
 
 #ifndef HAVE_FORK
 #define fork() vfork()
 #endif
 
 #ifndef MS_DIRSYNC
@@ -46,40 +53,44 @@ enum {
 	KEY_RO,
 	KEY_HELP,
 	KEY_VERSION,
 };
 
 struct mount_opts {
 	int allow_other;
 	int allow_root;
 	int ishelp;
 	int flags;
 	int nonempty;
 	int blkdev;
 	char *fsname;
 	char *subtype;
 	char *subtype_opt;
 	char *mtab_opts;
 	char *fusermount_opts;
 	char *kernel_opts;
 };
 
+#ifdef __CYGWIN__
+char *fusent_argv0;
+#endif
+
 #define FUSE_MOUNT_OPT(t, p) { t, offsetof(struct mount_opts, p), 1 }
 
 static const struct fuse_opt fuse_mount_opts[] = {
 	FUSE_MOUNT_OPT("allow_other",		allow_other),
 	FUSE_MOUNT_OPT("allow_root",		allow_root),
 	FUSE_MOUNT_OPT("nonempty",		nonempty),
 	FUSE_MOUNT_OPT("blkdev",		blkdev),
 	FUSE_MOUNT_OPT("fsname=%s",		fsname),
 	FUSE_MOUNT_OPT("subtype=%s",		subtype),
 	FUSE_OPT_KEY("allow_other",		KEY_KERN_OPT),
 	FUSE_OPT_KEY("allow_root",		KEY_ALLOW_ROOT),
 	FUSE_OPT_KEY("nonempty",		KEY_FUSERMOUNT_OPT),
 	FUSE_OPT_KEY("blkdev",			KEY_FUSERMOUNT_OPT),
 	FUSE_OPT_KEY("fsname=",			KEY_FUSERMOUNT_OPT),
 	FUSE_OPT_KEY("subtype=",		KEY_SUBTYPE_OPT),
 	FUSE_OPT_KEY("large_read",		KEY_KERN_OPT),
 	FUSE_OPT_KEY("blksize=",		KEY_KERN_OPT),
 	FUSE_OPT_KEY("default_permissions",	KEY_KERN_OPT),
 	FUSE_OPT_KEY("max_read=",		KEY_KERN_OPT),
 	FUSE_OPT_KEY("max_read=",		FUSE_OPT_KEY_KEEP),
@@ -248,91 +259,101 @@ static int receive_fd(int fd)
 
 	while(((rv = recvmsg(fd, &msg, 0)) == -1) && errno == EINTR);
 	if (rv == -1) {
 		perror("recvmsg");
 		return -1;
 	}
 	if(!rv) {
 		/* EOF */
 		return -1;
 	}
 
 	cmsg = CMSG_FIRSTHDR(&msg);
 	if (!cmsg->cmsg_type == SCM_RIGHTS) {
 		fprintf(stderr, "got control message of unknown type %d\n",
 			cmsg->cmsg_type);
 		return -1;
 	}
 	return *(int*)CMSG_DATA(cmsg);
 }
 
+#if defined __CYGWIN__
+void fuse_kern_unmount(const char *mountpoint, HANDLE fd)
+{
+	// TODO(cemeyer)
+	fprintf(stderr, "fuse_kern_unmount() got called.\n");
+}
+#else
 void fuse_kern_unmount(const char *mountpoint, int fd)
 {
 	int res;
 	int pid;
 
 	if (!mountpoint)
 		return;
 
 	if (fd != -1) {
 		struct pollfd pfd;
 
 		pfd.fd = fd;
 		pfd.events = 0;
 		res = poll(&pfd, 1, 0);
-		/* If file poll returns POLLERR on the device file descriptor,
-		   then the filesystem is already unmounted */
+		// If file poll returns POLLERR on the device file descriptor,
+		// then the filesystem is already unmounted
 		if (res == 1 && (pfd.revents & POLLERR))
 			return;
 
-		/* Need to close file descriptor, otherwise synchronous umount
-		   would recurse into filesystem, and deadlock */
+		// Need to close file descriptor, otherwise synchronous umount
+		// would recurse into filesystem, and deadlock
 		close(fd);
 	}
 
 	if (geteuid() == 0) {
 		fuse_mnt_umount("fuse", mountpoint, mountpoint,  1);
 		return;
 	}
 
 	res = umount2(mountpoint, 2);
 	if (res == 0)
 		return;
 
 	pid = fork();
 	if(pid == -1)
 		return;
 
 	if(pid == 0) {
 		const char *argv[] = { FUSERMOUNT_PROG, "-u", "-q", "-z",
 				       "--", mountpoint, NULL };
 
 		exec_fusermount(argv);
 		_exit(1);
 	}
 	waitpid(pid, NULL, 0);
 }
+#endif
 
+#ifndef __CYGWIN__
 void fuse_unmount_compat22(const char *mountpoint)
 {
 	fuse_kern_unmount(mountpoint, -1);
 }
+#endif
 
 static int fuse_mount_fusermount(const char *mountpoint, const char *opts,
 				 int quiet)
 {
 	int fds[2], pid;
 	int res;
 	int rv;
 
 	if (!mountpoint) {
 		fprintf(stderr, "fuse: missing mountpoint parameter\n");
 		return -1;
 	}
 
 	res = socketpair(PF_UNIX, SOCK_STREAM, 0, fds);
 	if(res == -1) {
 		perror("fuse: socketpair() failed");
 		return -1;
 	}
 
 	pid = fork();
@@ -368,43 +389,46 @@ static int fuse_mount_fusermount(const c
 		snprintf(env, sizeof(env), "%i", fds[0]);
 		setenv(FUSE_COMMFD_ENV, env, 1);
 		exec_fusermount(argv);
 		perror("fuse: failed to exec fusermount");
 		_exit(1);
 	}
 
 	close(fds[0]);
 	rv = receive_fd(fds[1]);
 	close(fds[1]);
 	waitpid(pid, NULL, 0); /* bury zombie */
 
 	return rv;
 }
 
 int fuse_mount_compat22(const char *mountpoint, const char *opts)
 {
 	return fuse_mount_fusermount(mountpoint, opts, 0);
 }
 
+#ifndef __CYGWIN__
 static int fuse_mount_sys(const char *mnt, struct mount_opts *mo,
 			  const char *mnt_opts)
 {
+	printf("fuse_mount_sys\n");
+	
 	char tmp[128];
 	const char *devname = "/dev/fuse";
 	char *source = NULL;
 	char *type = NULL;
 	struct stat stbuf;
 	int fd;
 	int res;
 
 	if (!mnt) {
 		fprintf(stderr, "fuse: missing mountpoint parameter\n");
 		return -1;
 	}
 
 	res = stat(mnt, &stbuf);
 	if (res == -1) {
 		fprintf(stderr ,"fuse: failed to access mountpoint %s: %s\n",
 			mnt, strerror(errno));
 		return -1;
 	}
 
@@ -435,160 +459,240 @@ static int fuse_mount_sys(const char *mn
 	source = malloc((mo->fsname ? strlen(mo->fsname) : 0) +
 			(mo->subtype ? strlen(mo->subtype) : 0) +
 			strlen(devname) + 32);
 
 	type = malloc((mo->subtype ? strlen(mo->subtype) : 0) + 32);
 	if (!type || !source) {
 		fprintf(stderr, "fuse: failed to allocate memory\n");
 		goto out_close;
 	}
 
 	strcpy(type, mo->blkdev ? "fuseblk" : "fuse");
 	if (mo->subtype) {
 		strcat(type, ".");
 		strcat(type, mo->subtype);
 	}
 	strcpy(source,
 	       mo->fsname ? mo->fsname : (mo->subtype ? mo->subtype : devname));
 
 	res = mount(source, mnt, type, mo->flags, mo->kernel_opts);
 	if (res == -1 && errno == ENODEV && mo->subtype) {
-		/* Probably missing subtype support */
+		// Probably missing subtype support
 		strcpy(type, mo->blkdev ? "fuseblk" : "fuse");
 		if (mo->fsname) {
 			if (!mo->blkdev)
 				sprintf(source, "%s#%s", mo->subtype,
 					mo->fsname);
 		} else {
 			strcpy(source, type);
 		}
 		res = mount(source, mnt, type, mo->flags, mo->kernel_opts);
 	}
 	if (res == -1) {
-		/*
-		 * Maybe kernel doesn't support unprivileged mounts, in this
-		 * case try falling back to fusermount
-		 */
+		 // Maybe kernel doesn't support unprivileged mounts, in this
+		 // case try falling back to fusermount
 		if (errno == EPERM) {
 			res = -2;
 		} else {
 			int errno_save = errno;
 			if (mo->blkdev && errno == ENODEV &&
 			    !fuse_mnt_check_fuseblk())
 				fprintf(stderr,
 					"fuse: 'fuseblk' support missing\n");
 			else
 				fprintf(stderr, "fuse: mount failed: %s\n",
 					strerror(errno_save));
 		}
 
 		goto out_close;
 	}
 
 	if (geteuid() == 0) {
 		char *newmnt = fuse_mnt_resolve_path("fuse", mnt);
 		res = -1;
 		if (!newmnt)
 			goto out_umount;
 
 		res = fuse_mnt_add_mount("fuse", source, newmnt, type,
 					 mnt_opts);
 		free(newmnt);
 		if (res == -1)
 			goto out_umount;
 	}
+
 	free(type);
 	free(source);
 
 	return fd;
 
 out_umount:
-	umount2(mnt, 2); /* lazy umount */
+	umount2(mnt, 2); // lazy umount
 out_close:
 	free(type);
 	free(source);
 	close(fd);
 	return res;
 }
+#endif
 
 static int get_mnt_flag_opts(char **mnt_optsp, int flags)
 {
 	int i;
 
 	if (!(flags & MS_RDONLY) && fuse_opt_add_opt(mnt_optsp, "rw") == -1)
 		return -1;
 
 	for (i = 0; mount_flags[i].opt != NULL; i++) {
 		if (mount_flags[i].on && (flags & mount_flags[i].flag) &&
 		    fuse_opt_add_opt(mnt_optsp, mount_flags[i].opt) == -1)
 			return -1;
 	}
 	return 0;
 }
 
+#if defined __CYGWIN__
+int fusent_kern_mount(const char *mountpoint, struct fuse_args *args, HANDLE *fd)
+#else
 int fuse_kern_mount(const char *mountpoint, struct fuse_args *args)
+#endif
 {
 	struct mount_opts mo;
 	int res = -1;
 	char *mnt_opts = NULL;
 
 	memset(&mo, 0, sizeof(mo));
 	mo.flags = MS_NOSUID | MS_NODEV;
 
 	if (args &&
 	    fuse_opt_parse(args, &mo, fuse_mount_opts, fuse_mount_opt_proc) == -1)
 		return -1;
 
 	if (mo.allow_other && mo.allow_root) {
 		fprintf(stderr, "fuse: 'allow_other' and 'allow_root' options are mutually exclusive\n");
 		goto out;
 	}
 	res = 0;
 	if (mo.ishelp)
 		goto out;
 
 	res = -1;
 	if (get_mnt_flag_opts(&mnt_opts, mo.flags) == -1)
 		goto out;
 	if (mo.kernel_opts && fuse_opt_add_opt(&mnt_opts, mo.kernel_opts) == -1)
 		goto out;
 	if (mo.mtab_opts &&  fuse_opt_add_opt(&mnt_opts, mo.mtab_opts) == -1)
 		goto out;
 
+#if defined __CYGWIN__
+	if (!mountpoint || strlen(mountpoint) != 2 || !isalpha((int)mountpoint[0]) ||
+			mountpoint[1] != ':') {
+		fprintf(stderr, "fusent: mountpoint is only allowed to be an (unused) drive, e.g. `U:'\n");
+		goto out;
+	}
+
+# define FUSE_DEV_MAXLEN 80
+# define FUSE_ARGV0_LEN 40
+	char devnameb[FUSE_DEV_MAXLEN];
+	char argv0name[FUSE_ARGV0_LEN];
+
+	char *slptr = strrchr(fusent_argv0, '/');
+	if (!slptr) slptr = fusent_argv0;
+	else slptr += 1; // skip slash
+
+	strncpy(argv0name, slptr, FUSE_ARGV0_LEN);
+	argv0name[FUSE_ARGV0_LEN-1] = '\0';
+
+	if (snprintf(devnameb, FUSE_DEV_MAXLEN, "\\Device\\Fuse\\%s-%d",
+				argv0name, getpid()) > FUSE_DEV_MAXLEN) {
+		fprintf(stderr, "fusent: argv[0] + pid is larger than %d chars (`%s-%d')\n",
+				FUSE_DEV_MAXLEN-1, fusent_argv0, getpid());
+		goto out;
+	}
+
+	size_t devlen = strlen(devnameb);
+	WCHAR devnamebwc[FUSE_DEV_MAXLEN];
+
+	if (fusent_transcode(devnameb, devlen, devnamebwc, sizeof(WCHAR) * FUSE_DEV_MAXLEN,
+				"US-ASCII", "UTF-16LE") != devlen * sizeof(WCHAR)) {
+		fprintf(stderr, "fusent: error transcoding devname (`%s') to WCHAR\n",
+				devnameb);
+		goto out;
+	}
+
+	// Null-terminate for RtlInitUnicodeString
+	devnamebwc[devlen] = (WCHAR)0;
+
+	UNICODE_STRING unidev;
+	RtlInitUnicodeString(&unidev, devnamebwc);
+
+	OBJECT_ATTRIBUTES oa;
+	InitializeObjectAttributes(&oa, &unidev, 0, NULL, NULL);
+
+	// Open the \\Device\\Fuse\\Blah handle
+	IO_STATUS_BLOCK iosb;
+	NTSTATUS stat = NtCreateFile(fd, GENERIC_READ | GENERIC_WRITE,
+			&oa, &iosb, NULL, FILE_ATTRIBUTE_NORMAL,
+			FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
+			FILE_WRITE_THROUGH, NULL, 0);
+
+	if (stat != STATUS_SUCCESS) {
+		fprintf(stderr, "fusent: failed to open device file (0x%08x)\n", (unsigned)stat);
+		goto out;
+	}
+
+	// Send "mount" signal to kernel module
+	stat = NtFsControlFile(*fd, NULL, NULL, NULL, &iosb, IRP_FUSE_MOUNT, NULL, 0, NULL, 0);
+
+	if (stat != STATUS_SUCCESS) {
+		fprintf(stderr, "fusent: mount ACK failed (0x%08x)\n", (unsigned)stat);
+		CloseHandle(fd);
+		goto out;
+	}
+
+	if (!DefineDosDevice(DDD_RAW_TARGET_PATH, mountpoint, devnameb)) {
+		// Drive letter creation failed:
+		DWORD winerr = GetLastError();
+		fprintf(stderr, "fusent: got error mounting device on `%s': %08x\n",
+				mountpoint, winerr);
+		goto out;
+	}
+	
+	// Declare mount a success:
+	res = 0;
+#else
 	res = fuse_mount_sys(mountpoint, &mo, mnt_opts);
 	if (res == -2) {
 		if (mo.fusermount_opts &&
 		    fuse_opt_add_opt(&mnt_opts, mo.fusermount_opts) == -1)
 			goto out;
 
 		if (mo.subtype) {
 			char *tmp_opts = NULL;
 
 			res = -1;
 			if (fuse_opt_add_opt(&tmp_opts, mnt_opts) == -1 ||
 			    fuse_opt_add_opt(&tmp_opts, mo.subtype_opt) == -1) {
 				free(tmp_opts);
 				goto out;
 			}
 
 			res = fuse_mount_fusermount(mountpoint, tmp_opts, 1);
 			free(tmp_opts);
 			if (res == -1)
 				res = fuse_mount_fusermount(mountpoint,
 							    mnt_opts, 0);
 		} else {
 			res = fuse_mount_fusermount(mountpoint, mnt_opts, 0);
 		}
 	}
+#endif
+
 out:
 	free(mnt_opts);
 	free(mo.fsname);
 	free(mo.subtype);
 	free(mo.fusermount_opts);
 	free(mo.subtype_opt);
 	free(mo.kernel_opts);
 	free(mo.mtab_opts);
 	return res;
 }
-
-FUSE_SYMVER(".symver fuse_mount_compat22,fuse_mount@FUSE_2.2");
-FUSE_SYMVER(".symver fuse_unmount_compat22,fuse_unmount@FUSE_2.2");
Index: fuse-2.8.5/lib/mount_util.c
===================================================================
--- fuse-2.8.5.orig/lib/mount_util.c
+++ fuse-2.8.5/lib/mount_util.c
@@ -4,40 +4,41 @@
 
   This program can be distributed under the terms of the GNU LGPLv2.
   See the file COPYING.LIB.
 */
 
 #include "mount_util.h"
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
 #include <mntent.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
 #include <sys/mount.h>
 #include <sys/param.h>
 
+#ifndef __CYGWIN__
 static int mtab_needs_update(const char *mnt)
 {
 	int res;
 	struct stat stbuf;
 
 	/* If mtab is within new mount, don't touch it */
 	if (strncmp(mnt, _PATH_MOUNTED, strlen(mnt)) == 0 &&
 	    _PATH_MOUNTED[strlen(mnt)] == '/')
 		return 0;
 
 	/*
 	 * Skip mtab update if /etc/mtab:
 	 *
 	 *  - doesn't exist,
 	 *  - is a symlink,
 	 *  - is on a read-only filesystem.
 	 */
 	res = lstat(_PATH_MOUNTED, &stbuf);
 	if (res == -1) {
 		if (errno == ENOENT)
@@ -342,20 +343,21 @@ int fuse_mnt_check_empty(const char *pro
 	}
 	return 0;
 }
 
 int fuse_mnt_check_fuseblk(void)
 {
 	char buf[256];
 	FILE *f = fopen("/proc/filesystems", "r");
 	if (!f)
 		return 1;
 
 	while (fgets(buf, sizeof(buf), f))
 		if (strstr(buf, "fuseblk\n")) {
 			fclose(f);
 			return 1;
 		}
 
 	fclose(f);
 	return 0;
 }
+#endif /* !__CYGWIN__ */
Index: fuse-2.8.5/lib/st.c
===================================================================
--- /dev/null
+++ fuse-2.8.5/lib/st.c
@@ -0,0 +1,1316 @@
+/* This is a public domain general purpose hash table package written by Peter Moore @ UCB. */
+
+/* static	char	sccsid[] = "@(#) st.c 5.1 89/12/14 Crucible"; */
+
+#include "st.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+typedef struct st_table_entry st_table_entry;
+
+struct st_table_entry {
+    st_index_t hash;
+    st_data_t key;
+    st_data_t record;
+    st_table_entry *next;
+    st_table_entry *fore, *back;
+};
+
+#define ST_DEFAULT_MAX_DENSITY 5
+#define ST_DEFAULT_INIT_TABLE_SIZE 11
+
+    /*
+     * DEFAULT_MAX_DENSITY is the default for the largest we allow the
+     * average number of items per bin before increasing the number of
+     * bins
+     *
+     * DEFAULT_INIT_TABLE_SIZE is the default for the number of bins
+     * allocated initially
+     *
+     */
+
+static const struct st_hash_type type_numhash = {
+    st_numcmp,
+    st_numhash,
+};
+
+/* extern int strcmp(const char *, const char *); */
+static st_index_t strhash(st_data_t);
+static const struct st_hash_type type_strhash = {
+    strcmp,
+    strhash,
+};
+
+static st_index_t strcasehash(st_data_t);
+static const struct st_hash_type type_strcasehash = {
+    st_strcasecmp,
+    strcasehash,
+};
+
+static void rehash(st_table *);
+
+#define numberof(array) (int)(sizeof(array) / sizeof((array)[0]))
+
+#define alloc(type) (type*)malloc((size_t)sizeof(type))
+#define Calloc(n,s) (char*)calloc((n),(s))
+
+#define EQUAL(table,x,y) ((x)==(y) || (*(table)->type->compare)((x),(y)) == 0)
+
+/* remove cast to unsigned int in the future */
+#define do_hash(key,table) (unsigned int)(st_index_t)(*(table)->type->hash)((key))
+#define do_hash_bin(key,table) (do_hash((key), (table))%(table)->num_bins)
+
+/*
+ * MINSIZE is the minimum size of a dictionary.
+ */
+
+#define MINSIZE 8
+
+/*
+Table of prime numbers 2^n+a, 2<=n<=30.
+*/
+static const unsigned int primes[] = {
+	8 + 3,
+	16 + 3,
+	32 + 5,
+	64 + 3,
+	128 + 3,
+	256 + 27,
+	512 + 9,
+	1024 + 9,
+	2048 + 5,
+	4096 + 3,
+	8192 + 27,
+	16384 + 43,
+	32768 + 3,
+	65536 + 45,
+	131072 + 29,
+	262144 + 3,
+	524288 + 21,
+	1048576 + 7,
+	2097152 + 17,
+	4194304 + 15,
+	8388608 + 9,
+	16777216 + 43,
+	33554432 + 35,
+	67108864 + 15,
+	134217728 + 29,
+	268435456 + 3,
+	536870912 + 11,
+	1073741824 + 85,
+	0
+};
+
+static st_index_t
+new_size(st_index_t size)
+{
+    int i;
+
+#if 0
+    for (i=3; i<31; i++) {
+	if ((1<<i) > size) return 1<<i;
+    }
+    return -1;
+#else
+    st_index_t newsize;
+
+    for (i = 0, newsize = MINSIZE; i < numberof(primes); i++, newsize <<= 1) {
+	if (newsize > size) return primes[i];
+    }
+    /* Ran out of polynomials */
+    return -1;			/* should raise exception */
+#endif
+}
+
+#ifdef HASH_LOG
+#include <unistd.h>
+static struct {
+    int all, total, num, str, strcase;
+}  collision;
+static int init_st = 0;
+
+static void
+stat_col(void)
+{
+    char fname[10+sizeof(long)*3];
+    FILE *f = fopen((snprintf(fname, sizeof(fname), "/tmp/col%ld", (long)getpid()), fname), "w");
+    fprintf(f, "collision: %d / %d (%6.2f)\n", collision.all, collision.total,
+	    ((double)collision.all / (collision.total)) * 100);
+    fprintf(f, "num: %d, str: %d, strcase: %d\n", collision.num, collision.str, collision.strcase);
+    fclose(f);
+}
+#endif
+
+#define MAX_PACKED_NUMHASH (ST_DEFAULT_INIT_TABLE_SIZE/2)
+
+st_table*
+st_init_table_with_size(const struct st_hash_type *type, st_index_t size)
+{
+    st_table *tbl;
+
+#ifdef HASH_LOG
+# if HASH_LOG+0 < 0
+    {
+	const char *e = getenv("ST_HASH_LOG");
+	if (!e || !*e) init_st = 1;
+    }
+# endif
+    if (init_st == 0) {
+	init_st = 1;
+	atexit(stat_col);
+    }
+#endif
+
+    size = new_size(size);	/* round up to prime number */
+
+    tbl = alloc(st_table);
+    tbl->type = type;
+    tbl->num_entries = 0;
+    tbl->entries_packed = type == &type_numhash && size/2 <= MAX_PACKED_NUMHASH;
+    tbl->num_bins = size;
+    tbl->bins = (st_table_entry **)Calloc(size, sizeof(st_table_entry*));
+    tbl->head = 0;
+    tbl->tail = 0;
+
+    return tbl;
+}
+
+st_table*
+st_init_table(const struct st_hash_type *type)
+{
+    return st_init_table_with_size(type, 0);
+}
+
+st_table*
+st_init_numtable(void)
+{
+    return st_init_table(&type_numhash);
+}
+
+st_table*
+st_init_numtable_with_size(st_index_t size)
+{
+    return st_init_table_with_size(&type_numhash, size);
+}
+
+st_table*
+st_init_strtable(void)
+{
+    return st_init_table(&type_strhash);
+}
+
+st_table*
+st_init_strtable_with_size(st_index_t size)
+{
+    return st_init_table_with_size(&type_strhash, size);
+}
+
+st_table*
+st_init_strcasetable(void)
+{
+    return st_init_table(&type_strcasehash);
+}
+
+st_table*
+st_init_strcasetable_with_size(st_index_t size)
+{
+    return st_init_table_with_size(&type_strcasehash, size);
+}
+
+void
+st_clear(st_table *table)
+{
+    register st_table_entry *ptr, *next;
+    st_index_t i;
+
+    if (table->entries_packed) {
+        table->num_entries = 0;
+        return;
+    }
+
+    for(i = 0; i < table->num_bins; i++) {
+	ptr = table->bins[i];
+	table->bins[i] = 0;
+	while (ptr != 0) {
+	    next = ptr->next;
+	    free(ptr);
+	    ptr = next;
+	}
+    }
+    table->num_entries = 0;
+    table->head = 0;
+    table->tail = 0;
+}
+
+void
+st_free_table(st_table *table)
+{
+    st_clear(table);
+    free(table->bins);
+    free(table);
+}
+
+size_t
+st_memsize(const st_table *table)
+{
+    if (table->entries_packed) {
+	return table->num_bins * sizeof (void *) + sizeof(st_table);
+    }
+    else {
+	return table->num_entries * sizeof(struct st_table_entry) + table->num_bins * sizeof (void *) + sizeof(st_table);
+    }
+}
+
+#define PTR_NOT_EQUAL(table, ptr, hash_val, key) \
+((ptr) != 0 && ((ptr)->hash != (hash_val) || !EQUAL((table), (key), (ptr)->key)))
+
+#ifdef HASH_LOG
+static void
+count_collision(const struct st_hash_type *type)
+{
+    collision.all++;
+    if (type == &type_numhash) {
+	collision.num++;
+    }
+    else if (type == &type_strhash) {
+	collision.strcase++;
+    }
+    else if (type == &type_strcasehash) {
+	collision.str++;
+    }
+}
+#define COLLISION (collision_check ? count_collision(table->type) : (void)0)
+#define FOUND_ENTRY (collision_check ? collision.total++ : (void)0)
+#else
+#define COLLISION
+#define FOUND_ENTRY
+#endif
+
+#define FIND_ENTRY(table, ptr, hash_val, bin_pos) do {\
+    (bin_pos) = (hash_val)%(table)->num_bins;\
+    (ptr) = (table)->bins[(bin_pos)];\
+    FOUND_ENTRY;\
+    if (PTR_NOT_EQUAL((table), (ptr), (hash_val), key)) {\
+	COLLISION;\
+	while (PTR_NOT_EQUAL((table), (ptr)->next, (hash_val), key)) {\
+	    (ptr) = (ptr)->next;\
+	}\
+	(ptr) = (ptr)->next;\
+    }\
+} while (0)
+
+#define collision_check 0
+
+int
+st_lookup(st_table *table, register st_data_t key, st_data_t *value)
+{
+    st_index_t hash_val, bin_pos;
+    register st_table_entry *ptr;
+
+    if (table->entries_packed) {
+        st_index_t i;
+        for (i = 0; i < table->num_entries; i++) {
+            if ((st_data_t)table->bins[i*2] == key) {
+                if (value !=0) *value = (st_data_t)table->bins[i*2+1];
+                return 1;
+            }
+        }
+        return 0;
+    }
+
+    hash_val = do_hash(key, table);
+    FIND_ENTRY(table, ptr, hash_val, bin_pos);
+
+    if (ptr == 0) {
+	return 0;
+    }
+    else {
+	if (value != 0)  *value = ptr->record;
+	return 1;
+    }
+}
+
+int
+st_get_key(st_table *table, register st_data_t key, st_data_t *result)
+{
+    st_index_t hash_val, bin_pos;
+    register st_table_entry *ptr;
+
+    if (table->entries_packed) {
+        st_index_t i;
+        for (i = 0; i < table->num_entries; i++) {
+            if ((st_data_t)table->bins[i*2] == key) {
+                if (result !=0) *result = (st_data_t)table->bins[i*2];
+                return 1;
+            }
+        }
+        return 0;
+    }
+
+    hash_val = do_hash(key, table);
+    FIND_ENTRY(table, ptr, hash_val, bin_pos);
+
+    if (ptr == 0) {
+	return 0;
+    }
+    else {
+	if (result != 0)  *result = ptr->key;
+	return 1;
+    }
+}
+
+#undef collision_check
+#define collision_check 1
+
+#define MORE_PACKABLE_P(table) \
+    ((st_index_t)((table)->num_entries+1) * 2 <= (table)->num_bins && \
+     (table)->num_entries+1 <= MAX_PACKED_NUMHASH)
+
+#define ADD_DIRECT(table, key, value, hash_val, bin_pos)\
+do {\
+    st_table_entry *entry;\
+    if ((table)->num_entries > ST_DEFAULT_MAX_DENSITY * (table)->num_bins) {\
+	rehash(table);\
+        (bin_pos) = (hash_val) % (table)->num_bins;\
+    }\
+    \
+    entry = alloc(st_table_entry);\
+    \
+    entry->hash = (hash_val);\
+    entry->key = (key);\
+    entry->record = (value);\
+    entry->next = (table)->bins[(bin_pos)];\
+    if ((table)->head != 0) {\
+	entry->fore = 0;\
+	(entry->back = (table)->tail)->fore = entry;\
+	(table)->tail = entry;\
+    }\
+    else {\
+	(table)->head = (table)->tail = entry;\
+	entry->fore = entry->back = 0;\
+    }\
+    (table)->bins[(bin_pos)] = entry;\
+    (table)->num_entries++;\
+} while (0)
+
+static void
+unpack_entries(register st_table *table)
+{
+    st_index_t i;
+    struct st_table_entry *packed_bins[MAX_PACKED_NUMHASH*2];
+    st_table tmp_table = *table;
+
+    memcpy(packed_bins, table->bins, sizeof(struct st_table_entry *) * table->num_entries*2);
+    table->bins = packed_bins;
+    tmp_table.entries_packed = 0;
+    tmp_table.num_entries = 0;
+    memset(tmp_table.bins, 0, sizeof(struct st_table_entry *) * tmp_table.num_bins);
+    for (i = 0; i < table->num_entries; i++) {
+        st_insert(&tmp_table, (st_data_t)packed_bins[i*2], (st_data_t)packed_bins[i*2+1]);
+    }
+    *table = tmp_table;
+}
+
+int
+st_insert(register st_table *table, register st_data_t key, st_data_t value)
+{
+    st_index_t hash_val, bin_pos;
+    register st_table_entry *ptr;
+
+    if (table->entries_packed) {
+        st_index_t i;
+        for (i = 0; i < table->num_entries; i++) {
+            if ((st_data_t)table->bins[i*2] == key) {
+                table->bins[i*2+1] = (struct st_table_entry*)value;
+                return 1;
+            }
+        }
+        if (MORE_PACKABLE_P(table)) {
+            i = table->num_entries++;
+            table->bins[i*2] = (struct st_table_entry*)key;
+            table->bins[i*2+1] = (struct st_table_entry*)value;
+            return 0;
+        }
+        else {
+            unpack_entries(table);
+        }
+    }
+
+    hash_val = do_hash(key, table);
+    FIND_ENTRY(table, ptr, hash_val, bin_pos);
+
+    if (ptr == 0) {
+	ADD_DIRECT(table, key, value, hash_val, bin_pos);
+	return 0;
+    }
+    else {
+	ptr->record = value;
+	return 1;
+    }
+}
+
+int
+st_insert2(register st_table *table, register st_data_t key, st_data_t value,
+	   st_data_t (*func)(st_data_t))
+{
+    st_index_t hash_val, bin_pos;
+    register st_table_entry *ptr;
+
+    if (table->entries_packed) {
+        st_index_t i;
+        for (i = 0; i < table->num_entries; i++) {
+            if ((st_data_t)table->bins[i*2] == key) {
+                table->bins[i*2+1] = (struct st_table_entry*)value;
+                return 1;
+            }
+        }
+        if (MORE_PACKABLE_P(table)) {
+            i = table->num_entries++;
+            table->bins[i*2] = (struct st_table_entry*)key;
+            table->bins[i*2+1] = (struct st_table_entry*)value;
+            return 0;
+        }
+        else {
+            unpack_entries(table);
+        }
+    }
+
+    hash_val = do_hash(key, table);
+    FIND_ENTRY(table, ptr, hash_val, bin_pos);
+
+    if (ptr == 0) {
+	key = (*func)(key);
+	ADD_DIRECT(table, key, value, hash_val, bin_pos);
+	return 0;
+    }
+    else {
+	ptr->record = value;
+	return 1;
+    }
+}
+
+void
+st_add_direct(st_table *table, st_data_t key, st_data_t value)
+{
+    st_index_t hash_val, bin_pos;
+
+    if (table->entries_packed) {
+        int i;
+        if (MORE_PACKABLE_P(table)) {
+            i = table->num_entries++;
+            table->bins[i*2] = (struct st_table_entry*)key;
+            table->bins[i*2+1] = (struct st_table_entry*)value;
+            return;
+        }
+        else {
+            unpack_entries(table);
+        }
+    }
+
+    hash_val = do_hash(key, table);
+    bin_pos = hash_val % table->num_bins;
+    ADD_DIRECT(table, key, value, hash_val, bin_pos);
+}
+
+static void
+rehash(register st_table *table)
+{
+    register st_table_entry *ptr, **new_bins;
+    st_index_t i, new_num_bins, hash_val;
+
+    new_num_bins = new_size(table->num_bins+1);
+    new_bins = (st_table_entry**)
+	realloc(table->bins, new_num_bins * sizeof(st_table_entry*));
+    for (i = 0; i < new_num_bins; ++i) new_bins[i] = 0;
+    table->num_bins = new_num_bins;
+    table->bins = new_bins;
+
+    if ((ptr = table->head) != 0) {
+	do {
+	    hash_val = ptr->hash % new_num_bins;
+	    ptr->next = new_bins[hash_val];
+	    new_bins[hash_val] = ptr;
+	} while ((ptr = ptr->fore) != 0);
+    }
+}
+
+st_table*
+st_copy(st_table *old_table)
+{
+    st_table *new_table;
+    st_table_entry *ptr, *entry, *prev, **tail;
+    st_index_t num_bins = old_table->num_bins;
+    st_index_t hash_val;
+
+    new_table = alloc(st_table);
+    if (new_table == 0) {
+	return 0;
+    }
+
+    *new_table = *old_table;
+    new_table->bins = (st_table_entry**)
+	Calloc((unsigned)num_bins, sizeof(st_table_entry*));
+
+    if (new_table->bins == 0) {
+	free(new_table);
+	return 0;
+    }
+
+    if (old_table->entries_packed) {
+        memcpy(new_table->bins, old_table->bins, sizeof(struct st_table_entry *) * old_table->num_bins);
+        return new_table;
+    }
+
+    if ((ptr = old_table->head) != 0) {
+	prev = 0;
+	tail = &new_table->head;
+	do {
+	    entry = alloc(st_table_entry);
+	    if (entry == 0) {
+		st_free_table(new_table);
+		return 0;
+	    }
+	    *entry = *ptr;
+	    hash_val = entry->hash % num_bins;
+	    entry->next = new_table->bins[hash_val];
+	    new_table->bins[hash_val] = entry;
+	    entry->back = prev;
+	    *tail = prev = entry;
+	    tail = &entry->fore;
+	} while ((ptr = ptr->fore) != 0);
+	new_table->tail = prev;
+    }
+
+    return new_table;
+}
+
+#define REMOVE_ENTRY(table, ptr) do					\
+    {									\
+	if ((ptr)->fore == 0 && (ptr)->back == 0) {			\
+	    (table)->head = 0;						\
+	    (table)->tail = 0;						\
+	}								\
+	else {								\
+	    st_table_entry *fore = (ptr)->fore, *back = (ptr)->back;	\
+	    if (fore) fore->back = back;				\
+	    if (back) back->fore = fore;				\
+	    if ((ptr) == (table)->head) (table)->head = fore;		\
+	    if ((ptr) == (table)->tail) (table)->tail = back;		\
+	}								\
+	(table)->num_entries--;						\
+    } while (0)
+
+int
+st_delete(register st_table *table, register st_data_t *key, st_data_t *value)
+{
+    st_index_t hash_val;
+    st_table_entry **prev;
+    register st_table_entry *ptr;
+
+    if (table->entries_packed) {
+        st_index_t i;
+        for (i = 0; i < table->num_entries; i++) {
+            if ((st_data_t)table->bins[i*2] == *key) {
+                if (value != 0) *value = (st_data_t)table->bins[i*2+1];
+                table->num_entries--;
+                memmove(&table->bins[i*2], &table->bins[(i+1)*2],
+                        sizeof(struct st_table_entry*) * 2*(table->num_entries-i));
+                return 1;
+            }
+        }
+        if (value != 0) *value = 0;
+        return 0;
+    }
+
+    hash_val = do_hash_bin(*key, table);
+
+    for (prev = &table->bins[hash_val]; (ptr = *prev) != 0; prev = &ptr->next) {
+	if (EQUAL(table, *key, ptr->key)) {
+	    *prev = ptr->next;
+	    REMOVE_ENTRY(table, ptr);
+	    if (value != 0) *value = ptr->record;
+	    *key = ptr->key;
+	    free(ptr);
+	    return 1;
+	}
+    }
+
+    if (value != 0) *value = 0;
+    return 0;
+}
+
+int
+st_delete_safe(register st_table *table, register st_data_t *key, st_data_t *value, st_data_t never)
+{
+    st_index_t hash_val;
+    register st_table_entry *ptr;
+
+    if (table->entries_packed) {
+	st_index_t i;
+	for (i = 0; i < table->num_entries; i++) {
+	    if ((st_data_t)table->bins[i*2] == *key) {
+		if (value != 0) *value = (st_data_t)table->bins[i*2+1];
+		table->bins[i*2] = (void *)never;
+		return 1;
+	    }
+	}
+	if (value != 0) *value = 0;
+	return 0;
+    }
+
+    hash_val = do_hash_bin(*key, table);
+    ptr = table->bins[hash_val];
+
+    for (; ptr != 0; ptr = ptr->next) {
+	if ((ptr->key != never) && EQUAL(table, ptr->key, *key)) {
+	    REMOVE_ENTRY(table, ptr);
+	    *key = ptr->key;
+	    if (value != 0) *value = ptr->record;
+	    ptr->key = ptr->record = never;
+	    return 1;
+	}
+    }
+
+    if (value != 0) *value = 0;
+    return 0;
+}
+
+void
+st_cleanup_safe(st_table *table, st_data_t never)
+{
+    st_table_entry *ptr, **last, *tmp;
+    st_index_t i;
+
+    if (table->entries_packed) {
+	st_index_t i = 0, j = 0;
+	while ((st_data_t)table->bins[i*2] != never) {
+	    if (i++ == table->num_entries) return;
+	}
+	for (j = i; ++i < table->num_entries;) {
+	    if ((st_data_t)table->bins[i*2] == never) continue;
+	    table->bins[j*2] = table->bins[i*2];
+	    table->bins[j*2+1] = table->bins[i*2+1];
+	    j++;
+	}
+	table->num_entries = j;
+	return;
+    }
+
+    for (i = 0; i < table->num_bins; i++) {
+	ptr = *(last = &table->bins[i]);
+	while (ptr != 0) {
+	    if (ptr->key == never) {
+		tmp = ptr;
+		*last = ptr = ptr->next;
+		free(tmp);
+	    }
+	    else {
+		ptr = *(last = &ptr->next);
+	    }
+	}
+    }
+}
+
+int
+st_foreach(st_table *table, int (*func)(ANYARGS), st_data_t arg)
+{
+    st_table_entry *ptr, **last, *tmp;
+    enum st_retval retval;
+    st_index_t i;
+
+    if (table->entries_packed) {
+        for (i = 0; i < table->num_entries; i++) {
+            st_index_t j;
+            st_data_t key, val;
+            key = (st_data_t)table->bins[i*2];
+            val = (st_data_t)table->bins[i*2+1];
+            retval = (*func)(key, val, arg);
+	    if (!table->entries_packed) goto unpacked;
+            switch (retval) {
+	      case ST_CHECK:	/* check if hash is modified during iteration */
+                for (j = 0; j < table->num_entries; j++) {
+                    if ((st_data_t)table->bins[j*2] == key)
+                        break;
+                }
+                if (j == table->num_entries) {
+                    /* call func with error notice */
+                    retval = (*func)(0, 0, arg, 1);
+                    return 1;
+                }
+		/* fall through */
+	      case ST_CONTINUE:
+		break;
+	      case ST_STOP:
+		return 0;
+	      case ST_DELETE:
+                table->num_entries--;
+                memmove(&table->bins[i*2], &table->bins[(i+1)*2],
+                        sizeof(struct st_table_entry*) * 2*(table->num_entries-i));
+                i--;
+                break;
+            }
+        }
+        return 0;
+      unpacked:
+	ptr = table->head;
+	while (i-- > 0) {
+	    if (!(ptr = ptr->fore)) return 0;
+	}
+    }
+    else {
+	ptr = table->head;
+    }
+
+    if (ptr != 0) {
+	do {
+	    i = ptr->hash % table->num_bins;
+	    retval = (*func)(ptr->key, ptr->record, arg);
+	    switch (retval) {
+	      case ST_CHECK:	/* check if hash is modified during iteration */
+		for (tmp = table->bins[i]; tmp != ptr; tmp = tmp->next) {
+		    if (!tmp) {
+			/* call func with error notice */
+			retval = (*func)(0, 0, arg, 1);
+			return 1;
+		    }
+		}
+		/* fall through */
+	      case ST_CONTINUE:
+		ptr = ptr->fore;
+		break;
+	      case ST_STOP:
+		return 0;
+	      case ST_DELETE:
+		last = &table->bins[ptr->hash % table->num_bins];
+		for (; (tmp = *last) != 0; last = &tmp->next) {
+		    if (ptr == tmp) {
+			tmp = ptr->fore;
+			*last = ptr->next;
+			REMOVE_ENTRY(table, ptr);
+			free(ptr);
+			if (ptr == tmp) return 0;
+			ptr = tmp;
+			break;
+		    }
+		}
+	    }
+	} while (ptr && table->head);
+    }
+    return 0;
+}
+
+#if 0  /* unused right now */
+int
+st_reverse_foreach(st_table *table, int (*func)(ANYARGS), st_data_t arg)
+{
+    st_table_entry *ptr, **last, *tmp;
+    enum st_retval retval;
+    int i;
+
+    if (table->entries_packed) {
+        for (i = table->num_entries-1; 0 <= i; i--) {
+            int j;
+            st_data_t key, val;
+            key = (st_data_t)table->bins[i*2];
+            val = (st_data_t)table->bins[i*2+1];
+            retval = (*func)(key, val, arg);
+            switch (retval) {
+	      case ST_CHECK:	/* check if hash is modified during iteration */
+                for (j = 0; j < table->num_entries; j++) {
+                    if ((st_data_t)table->bins[j*2] == key)
+                        break;
+                }
+                if (j == table->num_entries) {
+                    /* call func with error notice */
+                    retval = (*func)(0, 0, arg, 1);
+                    return 1;
+                }
+		/* fall through */
+	      case ST_CONTINUE:
+		break;
+	      case ST_STOP:
+		return 0;
+	      case ST_DELETE:
+                table->num_entries--;
+                memmove(&table->bins[i*2], &table->bins[(i+1)*2],
+                        sizeof(struct st_table_entry*) * 2*(table->num_entries-i));
+                break;
+            }
+        }
+        return 0;
+    }
+
+    if ((ptr = table->head) != 0) {
+	ptr = ptr->back;
+	do {
+	    retval = (*func)(ptr->key, ptr->record, arg, 0);
+	    switch (retval) {
+	      case ST_CHECK:	/* check if hash is modified during iteration */
+		i = ptr->hash % table->num_bins;
+		for (tmp = table->bins[i]; tmp != ptr; tmp = tmp->next) {
+		    if (!tmp) {
+			/* call func with error notice */
+			retval = (*func)(0, 0, arg, 1);
+			return 1;
+		    }
+		}
+		/* fall through */
+	      case ST_CONTINUE:
+		ptr = ptr->back;
+		break;
+	      case ST_STOP:
+		return 0;
+	      case ST_DELETE:
+		last = &table->bins[ptr->hash % table->num_bins];
+		for (; (tmp = *last) != 0; last = &tmp->next) {
+		    if (ptr == tmp) {
+			tmp = ptr->back;
+			*last = ptr->next;
+			REMOVE_ENTRY(table, ptr);
+			free(ptr);
+			ptr = tmp;
+			break;
+		    }
+		}
+		ptr = ptr->next;
+		free(tmp);
+		table->num_entries--;
+	    }
+	} while (ptr && table->head);
+    }
+    return 0;
+}
+#endif
+
+/*
+ * hash_32 - 32 bit Fowler/Noll/Vo FNV-1a hash code
+ *
+ * @(#) $Hash32: Revision: 1.1 $
+ * @(#) $Hash32: Id: hash_32a.c,v 1.1 2003/10/03 20:38:53 chongo Exp $
+ * @(#) $Hash32: Source: /usr/local/src/cmd/fnv/RCS/hash_32a.c,v $
+ *
+ ***
+ *
+ * Fowler/Noll/Vo hash
+ *
+ * The basis of this hash algorithm was taken from an idea sent
+ * as reviewer comments to the IEEE POSIX P1003.2 committee by:
+ *
+ *      Phong Vo (http://www.research.att.com/info/kpv/)
+ *      Glenn Fowler (http://www.research.att.com/~gsf/)
+ *
+ * In a subsequent ballot round:
+ *
+ *      Landon Curt Noll (http://www.isthe.com/chongo/)
+ *
+ * improved on their algorithm.  Some people tried this hash
+ * and found that it worked rather well.  In an EMail message
+ * to Landon, they named it the ``Fowler/Noll/Vo'' or FNV hash.
+ *
+ * FNV hashes are designed to be fast while maintaining a low
+ * collision rate. The FNV speed allows one to quickly hash lots
+ * of data while maintaining a reasonable collision rate.  See:
+ *
+ *      http://www.isthe.com/chongo/tech/comp/fnv/index.html
+ *
+ * for more details as well as other forms of the FNV hash.
+ ***
+ *
+ * To use the recommended 32 bit FNV-1a hash, pass FNV1_32A_INIT as the
+ * Fnv32_t hashval argument to fnv_32a_buf() or fnv_32a_str().
+ *
+ ***
+ *
+ * Please do not copyright this code.  This code is in the public domain.
+ *
+ * LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
+ * EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+ * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+ * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * By:
+ *	chongo <Landon Curt Noll> /\oo/\
+ *      http://www.isthe.com/chongo/
+ *
+ * Share and Enjoy!	:-)
+ */
+
+/*
+ * 32 bit FNV-1 and FNV-1a non-zero initial basis
+ *
+ * The FNV-1 initial basis is the FNV-0 hash of the following 32 octets:
+ *
+ *              chongo <Landon Curt Noll> /\../\
+ *
+ * NOTE: The \'s above are not back-slashing escape characters.
+ * They are literal ASCII  backslash 0x5c characters.
+ *
+ * NOTE: The FNV-1a initial basis is the same value as FNV-1 by definition.
+ */
+#define FNV1_32A_INIT 0x811c9dc5
+
+/*
+ * 32 bit magic FNV-1a prime
+ */
+#define FNV_32_PRIME 0x01000193
+
+#ifdef ST_USE_FNV1
+static st_index_t
+strhash(st_data_t arg)
+{
+    register const char *string = (const char *)arg;
+    register st_index_t hval = FNV1_32A_INIT;
+
+    /*
+     * FNV-1a hash each octet in the buffer
+     */
+    while (*string) {
+	/* xor the bottom with the current octet */
+	hval ^= (unsigned int)*string++;
+
+	/* multiply by the 32 bit FNV magic prime mod 2^32 */
+	hval *= FNV_32_PRIME;
+    }
+    return hval;
+}
+#else
+
+#ifndef UNALIGNED_WORD_ACCESS
+# if defined __i386__ || defined _M_IX86
+#   define UNALIGNED_WORD_ACCESS 1
+# endif
+#endif
+#ifndef UNALIGNED_WORD_ACCESS
+# define UNALIGNED_WORD_ACCESS 0
+#endif
+
+/* MurmurHash described in http://murmurhash.googlepages.com/ */
+#ifndef MURMUR
+#define MURMUR 2
+#endif
+
+#define MurmurMagic_1 (st_index_t)0xc6a4a793
+#define MurmurMagic_2 (st_index_t)0x5bd1e995
+#if MURMUR == 1
+#define MurmurMagic MurmurMagic_1
+#elif MURMUR == 2
+#if SIZEOF_ST_INDEX_T > 4
+#define MurmurMagic ((MurmurMagic_1 << 32) | MurmurMagic_2)
+#else
+#define MurmurMagic MurmurMagic_2
+#endif
+#endif
+
+static inline st_index_t
+murmur(st_index_t h, st_index_t k, int r)
+{
+    const st_index_t m = MurmurMagic;
+#if MURMUR == 1
+    h += k;
+    h *= m;
+    h ^= h >> r;
+#elif MURMUR == 2
+    k *= m;
+    k ^= k >> r;
+    k *= m;
+
+    h *= m;
+    h ^= k;
+#endif
+    return h;
+}
+
+static inline st_index_t
+murmur_finish(st_index_t h)
+{
+#if MURMUR == 1
+    h = murmur(h, 0, 10);
+    h = murmur(h, 0, 17);
+#elif MURMUR == 2
+    h ^= h >> 13;
+    h *= MurmurMagic;
+    h ^= h >> 15;
+#endif
+    return h;
+}
+
+#define murmur_step(h, k) murmur((h), (k), 16)
+
+#if MURMUR == 1
+#define murmur1(h) murmur_step((h), 16)
+#else
+#define murmur1(h) murmur_step((h), 24)
+#endif
+
+st_index_t
+st_hash(const void *ptr, size_t len, st_index_t h)
+{
+    const char *data = ptr;
+    st_index_t t = 0;
+
+    h += 0xdeadbeef;
+
+#define data_at(n) (st_index_t)((unsigned char)data[(n)])
+#define UNALIGNED_ADD_4 UNALIGNED_ADD(2); UNALIGNED_ADD(1); UNALIGNED_ADD(0)
+#if SIZEOF_ST_INDEX_T > 4
+#define UNALIGNED_ADD_8 UNALIGNED_ADD(6); UNALIGNED_ADD(5); UNALIGNED_ADD(4); UNALIGNED_ADD(3); UNALIGNED_ADD_4
+#if SIZEOF_ST_INDEX_T > 8
+#define UNALIGNED_ADD_16 UNALIGNED_ADD(14); UNALIGNED_ADD(13); UNALIGNED_ADD(12); UNALIGNED_ADD(11); \
+    UNALIGNED_ADD(10); UNALIGNED_ADD(9); UNALIGNED_ADD(8); UNALIGNED_ADD(7); UNALIGNED_ADD_8
+#define UNALIGNED_ADD_ALL UNALIGNED_ADD_16
+#endif
+#define UNALIGNED_ADD_ALL UNALIGNED_ADD_8
+#else
+#define UNALIGNED_ADD_ALL UNALIGNED_ADD_4
+#endif
+    if (len >= sizeof(st_index_t)) {
+#if !UNALIGNED_WORD_ACCESS
+	int align = (int)((st_data_t)data % sizeof(st_index_t));
+	if (align) {
+	    st_index_t d = 0;
+	    int sl, sr, pack;
+
+	    switch (align) {
+#ifdef WORDS_BIGENDIAN
+# define UNALIGNED_ADD(n) case SIZEOF_ST_INDEX_T - (n) - 1: \
+		t |= data_at(n) << CHAR_BIT*(SIZEOF_ST_INDEX_T - (n) - 2)
+#else
+# define UNALIGNED_ADD(n) case SIZEOF_ST_INDEX_T - (n) - 1:	\
+		t |= data_at(n) << CHAR_BIT*(n)
+#endif
+		UNALIGNED_ADD_ALL;
+#undef UNALIGNED_ADD
+	    }
+
+#ifdef WORDS_BIGENDIAN
+	    t >>= (CHAR_BIT * align) - CHAR_BIT;
+#else
+	    t <<= (CHAR_BIT * align);
+#endif
+
+	    data += sizeof(st_index_t)-align;
+	    len -= sizeof(st_index_t)-align;
+
+	    sl = CHAR_BIT * (SIZEOF_ST_INDEX_T-align);
+	    sr = CHAR_BIT * align;
+
+	    while (len >= sizeof(st_index_t)) {
+		d = *(st_index_t *)data;
+#ifdef WORDS_BIGENDIAN
+		t = (t << sr) | (d >> sl);
+#else
+		t = (t >> sr) | (d << sl);
+#endif
+		h = murmur_step(h, t);
+		t = d;
+		data += sizeof(st_index_t);
+		len -= sizeof(st_index_t);
+	    }
+
+	    pack = len < (size_t)align ? (int)len : align;
+	    d = 0;
+	    switch (pack) {
+#ifdef WORDS_BIGENDIAN
+# define UNALIGNED_ADD(n) case (n) + 1: \
+		d |= data_at(n) << CHAR_BIT*(SIZEOF_ST_INDEX_T - (n) - 1)
+#else
+# define UNALIGNED_ADD(n) case (n) + 1: \
+		d |= data_at(n) << CHAR_BIT*(n)
+#endif
+		UNALIGNED_ADD_ALL;
+#undef UNALIGNED_ADD
+	    }
+#ifdef WORDS_BIGENDIAN
+	    t = (t << sr) | (d >> sl);
+#else
+	    t = (t >> sr) | (d << sl);
+#endif
+
+#if MURMUR == 2
+	    if (len < (size_t)align) goto skip_tail;
+#endif
+	    h = murmur_step(h, t);
+	    data += pack;
+	    len -= pack;
+	}
+	else
+#endif
+	{
+	    do {
+		h = murmur_step(h, *(st_index_t *)data);
+		data += sizeof(st_index_t);
+		len -= sizeof(st_index_t);
+	    } while (len >= sizeof(st_index_t));
+	}
+    }
+
+    t = 0;
+    switch (len) {
+#ifdef WORDS_BIGENDIAN
+# define UNALIGNED_ADD(n) case (n) + 1: \
+	t |= data_at(n) << CHAR_BIT*(SIZEOF_ST_INDEX_T - (n) - 1)
+#else
+# define UNALIGNED_ADD(n) case (n) + 1: \
+	t |= data_at(n) << CHAR_BIT*(n)
+#endif
+	UNALIGNED_ADD_ALL;
+#undef UNALIGNED_ADD
+#if MURMUR == 1
+	h = murmur_step(h, t);
+#elif MURMUR == 2
+# if !UNALIGNED_WORD_ACCESS
+      skip_tail:
+# endif
+	h ^= t;
+	h *= MurmurMagic;
+#endif
+    }
+
+    return murmur_finish(h);
+}
+
+st_index_t
+st_hash_uint32(st_index_t h, uint32_t i)
+{
+    return murmur_step(h + i, 16);
+}
+
+st_index_t
+st_hash_uint(st_index_t h, st_index_t i)
+{
+    st_index_t v = 0;
+    h += i;
+#ifdef WORDS_BIGENDIAN
+#if SIZEOF_ST_INDEX_T*CHAR_BIT > 12*8
+    v = murmur1(v + (h >> 12*8));
+#endif
+#if SIZEOF_ST_INDEX_T*CHAR_BIT > 8*8
+    v = murmur1(v + (h >> 8*8));
+#endif
+#if SIZEOF_ST_INDEX_T*CHAR_BIT > 4*8
+    v = murmur1(v + (h >> 4*8));
+#endif
+#endif
+    v = murmur1(v + h);
+#ifndef WORDS_BIGENDIAN
+#if SIZEOF_ST_INDEX_T*CHAR_BIT > 4*8
+    v = murmur1(v + (h >> 4*8));
+#endif
+#if SIZEOF_ST_INDEX_T*CHAR_BIT > 8*8
+    v = murmur1(v + (h >> 8*8));
+#endif
+#if SIZEOF_ST_INDEX_T*CHAR_BIT > 12*8
+    v = murmur1(v + (h >> 12*8));
+#endif
+#endif
+    return v;
+}
+
+st_index_t
+st_hash_end(st_index_t h)
+{
+    h = murmur_step(h, 10);
+    h = murmur_step(h, 17);
+    return h;
+}
+
+#undef st_hash_start
+st_index_t
+st_hash_start(st_index_t h)
+{
+    return h;
+}
+
+static st_index_t
+strhash(st_data_t arg)
+{
+    register const char *string = (const char *)arg;
+    return st_hash(string, strlen(string), FNV1_32A_INIT);
+}
+#endif
+
+int
+st_strcasecmp(const char *s1, const char *s2)
+{
+    unsigned int c1, c2;
+
+    while (1) {
+        c1 = (unsigned char)*s1++;
+        c2 = (unsigned char)*s2++;
+        if (c1 == '\0' || c2 == '\0') {
+            if (c1 != '\0') return 1;
+            if (c2 != '\0') return -1;
+            return 0;
+        }
+        if ((unsigned int)(c1 - 'A') <= ('Z' - 'A')) c1 += 'a' - 'A';
+        if ((unsigned int)(c2 - 'A') <= ('Z' - 'A')) c2 += 'a' - 'A';
+        if (c1 != c2) {
+            if (c1 > c2)
+                return 1;
+            else
+                return -1;
+        }
+    }
+}
+
+int
+st_strncasecmp(const char *s1, const char *s2, size_t n)
+{
+    unsigned int c1, c2;
+
+    while (n--) {
+        c1 = (unsigned char)*s1++;
+        c2 = (unsigned char)*s2++;
+        if (c1 == '\0' || c2 == '\0') {
+            if (c1 != '\0') return 1;
+            if (c2 != '\0') return -1;
+            return 0;
+        }
+        if ((unsigned int)(c1 - 'A') <= ('Z' - 'A')) c1 += 'a' - 'A';
+        if ((unsigned int)(c2 - 'A') <= ('Z' - 'A')) c2 += 'a' - 'A';
+        if (c1 != c2) {
+            if (c1 > c2)
+                return 1;
+            else
+                return -1;
+        }
+    }
+    return 0;
+}
+
+static st_index_t
+strcasehash(st_data_t arg)
+{
+    register const char *string = (const char *)arg;
+    register st_index_t hval = FNV1_32A_INIT;
+
+    /*
+     * FNV-1a hash each octet in the buffer
+     */
+    while (*string) {
+	unsigned int c = (unsigned char)*string++;
+	if ((unsigned int)(c - 'A') <= ('Z' - 'A')) c += 'a' - 'A';
+	hval ^= c;
+
+	/* multiply by the 32 bit FNV magic prime mod 2^32 */
+	hval *= FNV_32_PRIME;
+    }
+    return hval;
+}
+
+int
+st_numcmp(st_data_t x, st_data_t y)
+{
+    return x != y;
+}
+
+st_index_t
+st_numhash(st_data_t n)
+{
+    return (st_index_t)n;
+}
